---
title: Software Engineering
slug: software-engineering-intro
description: Software Engineering Notes
---

**Main Source:**

- This note, **Software-Engineering-9th-Edition-by-Ian-Sommerville**

### Intro

**Software engineering** is an engineering discipline that is concerned with software programs. A software system is developed by programmers, which use programming languages like Python, Java, C++, or JavaScript to write instructions that the computer can understand and execute.

The difficulty of making software can vary depending on the type of software being made and the complexity of the software. A simple software made by individual may not involve more than one program. A complex software made by team of individuals may need multiple programs or components to work together. Often they require extra configuration to ensure the software can be run on different types of devices.

As software become more complex, more people coming to develop and more people using it, various principles of software engineering may be needed. Software engineering principles are a set of guidelines that help guide the development of high-quality software products.

An individual programmer may not need to structure their code in a specific standard. They can even name their program's variable or function in their own language. However, as we are developing the software in a larger scope with more people on it, we may need to follow specific standard or even document our code.

Not only making collaboration possible, following a specific standard helps to improve software development process efficiency. The simplest example of software engineering standard that probably everyone has done before is the [DRY (Don't Repeat Yourself)](/cs-notes/software-engineering/software-principles#dry). In short, the principle encourages us to avoid code duplication. Instead of coding the same instruction multiple times, we can move it to a function that we can reuse it anytime.

### Software Characteristics

A good software is associated with several characteristics:

- **Functionality**: A software is designed to solve problem, whether a general problem, example of them are databases, word processors, drawing apps, or notes app. It can also be a custom software, such as the one that operates on an embedded device like fridge.
- **Reliability**: A reliable software operates consistently and predictably under various conditions. It should be stable, robust, and resistant to failures. Users should be able to depend on the software to perform as expected without unexpected crashes, errors, or data loss.
- **Usability**: This refers to how easily and efficiently users can interact with the software. Good software is user-friendly, intuitive, easy-to-learn, and well-designed, taking into account the needs and expectations of its target users.
- **Performance**: Good software is efficient, responsive, fast, and utilize system resources optimally. Users should not experience excessive delays or slowdowns while using the software.
- **Maintainability**: Often times a software is updated to introduce new features or bug fixes. Maintainable software is easy to modify and maintain. It should be well-organized, have a comprehensive documentation, and follow good coding practices.
- **Scalability**: Scalable software can handle increasing workloads, user demands, and data volumes without significant degradation in performance or functionality. It should be designed to accommodate future growth and potential changes in requirements.
- **Security**: Good software prioritizes security and protects against security vulnerabilities to ensure the confidentiality, integrity, and availability of user data.
- **Compatibility**: Good software is compatible with diverse computing environments, operating systems, and devices.
- **Testability**: Software creation goes through many tests to ensure its functionality. A good software should be easy to test and thoroughly tested.

### All pages

- [Software Process](/cs-notes/software-engineering/software-process)
- Software Design
  - [Software Principles](/cs-notes/software-engineering/software-principles)
  - [Diagrams](/cs-notes/software-engineering/diagrams)
  - Design Patterns
    - [Creational Patterns](/cs-notes/software-engineering/creational-patterns)
    - [Structural Patterns](/cs-notes/software-engineering/structural-patterns)
    - [Behavioral Patterns](/cs-notes/software-engineering/behavioral-patterns)
- Software Architecture
  - [Client-Server](/cs-notes/software-engineering/client-server)
  - [Event-Driven](/cs-notes/software-engineering/event-driven)
  - [Master-Slave](/cs-notes/software-engineering/master-slave)
  - [Peer-to-Peer](/cs-notes/software-engineering/peer-to-peer)
  - [Layered](/cs-notes/software-engineering/layered)
  - [Other Architecture Patterns](/cs-notes/software-engineering/other-architecture-patterns)
- Software Management
  - [Software Testing](/cs-notes/software-engineering/software-testing)
  - [Software Debugging](/cs-notes/software-engineering/software-debugging)
  - [Build & Package Management](/cs-notes/software-engineering/build-and-package-management)
  - [Version Control](/cs-notes/software-engineering/version-control)
  - [Open Sourcing](/cs-notes/software-engineering/open-sourcing)
  - [Modularization](/cs-notes/software-engineering/modularization)
  - [Software Deployment](/cs-notes/software-engineering/software-deployment)
- [System Design](/cs-notes/software-engineering/system-design)
- [System Design Examples](/cs-notes/software-engineering/system-design-examples)
