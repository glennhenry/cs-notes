"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[9494],{28453:(e,s,t)=>{t.d(s,{R:()=>r,x:()=>o});var a=t(96540);const n={},i=a.createContext(n);function r(e){const s=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),a.createElement(i.Provider,{value:s},e.children)}},28682:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"data-structures-and-algorithms/topological-sort/topological-sort","title":"Topological Sort","description":"Topological Sort","source":"@site/docs/data-structures-and-algorithms/26-topological-sort/topological-sort.md","sourceDirName":"data-structures-and-algorithms/26-topological-sort","slug":"/data-structures-and-algorithms/topological-sort","permalink":"/cs-notes/data-structures-and-algorithms/topological-sort","draft":false,"unlisted":false,"editUrl":"https://github.com/glennhenry/cs-notes/tree/main/docs/data-structures-and-algorithms/26-topological-sort/topological-sort.md","tags":[],"version":"current","lastUpdatedBy":"glennhenry","lastUpdatedAt":1723455088000,"frontMatter":{"slug":"/data-structures-and-algorithms/topological-sort","id":"topological-sort","title":"Topological Sort","description":"Topological Sort"},"sidebar":"sidebar","previous":{"title":"Union Find","permalink":"/cs-notes/data-structures-and-algorithms/union-find"},"next":{"title":"Minimum Spanning Tree","permalink":"/cs-notes/data-structures-and-algorithms/minimum-spanning-tree"}}');var n=t(74848),i=t(28453);const r={slug:"/data-structures-and-algorithms/topological-sort",id:"topological-sort",title:"Topological Sort",description:"Topological Sort"},o=void 0,l={},c=[{value:"Algorithm",id:"algorithm",level:3}];function h(e){const s={a:"a",annotation:"annotation",code:"code",h3:"h3",img:"img",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.p,{children:(0,n.jsx)(s.strong,{children:"Main Source:"})}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:(0,n.jsx)(s.strong,{children:(0,n.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Topological_sorting",children:"Topological sorting \u2014 Wikipedia"})})}),"\n",(0,n.jsx)(s.li,{children:(0,n.jsx)(s.strong,{children:(0,n.jsx)(s.a,{href:"https://youtu.be/7J3GadLzydI?si=KKS4GPSjS7SAd_om",children:"Topological Sort Visualized and Explained \u2014 Carl the Person"})})}),"\n"]}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"Topological Sort"})," is an algorithm used to order the vertices of a ",(0,n.jsx)(s.a,{href:"/data-structures-and-algorithms/graph#directed",children:"directed graph"}),", so that each vertex appears before any of its successors in the ordering. It provides a linear ordering of the vertices that respects the directed edges of the graph."]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"Topological sort",src:t(56561).A+"",width:"424",height:"296"})}),"\n",(0,n.jsx)(s.p,{children:"The one that is pointed should be done after the one pointing to it. The main application of topological sorting is in scheduling problems, where certain tasks must be performed before others."}),"\n",(0,n.jsx)(s.h3,{id:"algorithm",children:"Algorithm"}),"\n",(0,n.jsxs)(s.p,{children:["The algorithm can be implemented using ",(0,n.jsx)(s.a,{href:"/data-structures-and-algorithms/traversal#depth-first-search-dfs",children:"DFS"})," or ",(0,n.jsx)(s.a,{href:"/data-structures-and-algorithms/traversal#breadth-first-search-bfs",children:"BFS"})," traversal."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{children:"function topologicalSort(graph):\n    mark all vertices as unvisited\n    initialize an empty stack\n\n    for each vertex in the graph:\n        if the vertex is unvisited:\n            visit(vertex, stack)\n\n    return reversed(stack)\n\nfunction visit(vertex, stack):\n    mark the vertex as visited\n\n    for each neighbor of vertex:\n        if the neighbor is unvisited:\n            visit(neighbor, stack)\n\n    push vertex onto stack\n"})}),"\n",(0,n.jsxs)(s.p,{children:["In this code, it is implemented using DFS, in the ",(0,n.jsx)(s.code,{children:"visit"})," function. For each neighbor of the vertex, if the neighbor is unvisited, the visit function is called recursively on that neighbor. After visiting all the neighbors of a vertex, that vertex is pushed onto the stack. The stack is used to maintain the ordering of the vertices based on the topological sort property."]}),"\n",(0,n.jsx)(s.p,{children:"We will also need to return the reverse order of the stack, to ensure that the top element of the stack represents the first vertex in the topological ordering."}),"\n",(0,n.jsxs)(s.p,{children:["The time complexity for topological sort is ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mi,{children:"O"}),(0,n.jsx)(s.mo,{stretchy:"false",children:"("}),(0,n.jsx)(s.mi,{children:"V"}),(0,n.jsx)(s.mo,{children:"+"}),(0,n.jsx)(s.mi,{children:"E"}),(0,n.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(V + E)"})]})})}),(0,n.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,n.jsx)(s.span,{className:"mopen",children:"("}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,n.jsx)(s.span,{className:"mbin",children:"+"}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"}),(0,n.jsx)(s.span,{className:"mclose",children:")"})]})]})]}),", where ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsx)(s.mi,{children:"V"})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"V"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"})]})})]})," and ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsx)(s.mi,{children:"E"})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"E"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"})]})})]})," is the number of vertices and edges, respectively. We will need to traverse the whole graph in order to obtain the vertices ordering. The space complexity is ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mi,{children:"O"}),(0,n.jsx)(s.mo,{stretchy:"false",children:"("}),(0,n.jsx)(s.mi,{children:"V"}),(0,n.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(V)"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,n.jsx)(s.span,{className:"mopen",children:"("}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,n.jsx)(s.span,{className:"mclose",children:")"})]})})]})," to store the visited vertices."]})]})}function d(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},56561:(e,s,t)=>{t.d(s,{A:()=>a});const a=t.p+"assets/images/topological-sort-cd259c1dd712a9c4b675e6459d58c5d3.png"}}]);