"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[5048],{20003:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var t=i(85893),s=i(11151);const r={slug:"/compilers/compilers-fundamentals",id:"compilers-fundamentals",title:"Compilers Fundamentals",description:"Compilers Fundamentals"},o=void 0,a={id:"compilers/compilers-fundamentals/compilers-fundamentals",title:"Compilers Fundamentals",description:"Compilers Fundamentals",source:"@site/docs/compilers/01-compilers-fundamentals/compilers-fundamentals.md",sourceDirName:"compilers/01-compilers-fundamentals",slug:"/compilers/compilers-fundamentals",permalink:"/cs-notes/compilers/compilers-fundamentals",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/compilers/01-compilers-fundamentals/compilers-fundamentals.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1714636545e3,frontMatter:{slug:"/compilers/compilers-fundamentals",id:"compilers-fundamentals",title:"Compilers Fundamentals",description:"Compilers Fundamentals"},sidebar:"sidebar",previous:{title:"Compilers",permalink:"/cs-notes/compilers"},next:{title:"Syntax",permalink:"/cs-notes/compilers/syntax"}},l={},c=[{value:"Compiler Toolchain",id:"compiler-toolchain",level:3},{value:"Compilation Process",id:"compilation-process",level:4},{value:"Compilation Example",id:"compilation-example",level:3},{value:"Types &amp; Classification of Compilers",id:"types--classification-of-compilers",level:3}];function d(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Main Source :"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Chapter 1, Programming Language Pragmatics - Michael L. Scott"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Compiler",children:"Compiler - Wikipedia"})})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Compiler is program that translate computer code from one programming language (source language) to the target language, typically a lower-level language like assembly language, machine code, or bytecode."}),"\n",(0,t.jsx)(n.h3,{id:"compiler-toolchain",children:"Compiler Toolchain"}),"\n",(0,t.jsx)(n.p,{children:"Toolchain is the collection of software tools that work together to transform source code into a working program. Compilation is just one of the process in a toolchain."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.img,{alt:"Compiler toolchain",src:i(68808).Z+"",width:"790",height:"349"}),(0,t.jsx)(n.br,{}),"\n","Source : Book 1 page 5"]}),"\n",(0,t.jsx)(n.p,{children:"Let's assume we are using language like C and C++."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Preprocessing"})," : Preprocessor prepare the source code before the actual compilation. It handles directives like ",(0,t.jsx)(n.code,{children:"#include"}),", ",(0,t.jsx)(n.code,{children:"#define"}),", and conditional compilation (",(0,t.jsx)(n.code,{children:"#ifdef"}),", ",(0,t.jsx)(n.code,{children:"#ifndef"}),"). For example, it may substitute a macro with actual value defined, including function defined in header files to the main source code, etc."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Compilation"})," : The main part of the toolchain, explained ",(0,t.jsx)(n.a,{href:"#compilation-process",children:"below"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Assembler"})," : Compilation generates machine code, typically in the form of ",(0,t.jsx)(n.a,{href:"/compilers/assembly-language",children:"assembly language"}),". This assembly language is lower-level enough to be considered as machine code, but it is still human-readable. Assembler takes generated assembly code to produce ",(0,t.jsx)(n.strong,{children:"object files"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Linking"})," : The object file contains real machine code to be executed on the CPU, but it is not yet complete. The linking process is required to resolve external references used in our program to create a complete executable. For example, the function ",(0,t.jsx)(n.code,{children:"printf"})," is provided by the C standard library. Our source code, which is already in the form of machine code, should locate and load the definition of the function. The linker, divided into static and dynamic linker, loads and links together all object files and library files into memory."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Static Linker"})," : Static linker links file by directly including pre-compiled libraries in our program final executable compile-time. Static libraries are identified by file with ",(0,t.jsx)(n.code,{children:".a"})," format on Unix or ",(0,t.jsx)(n.code,{children:".lib"})," format on Windows."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dynamic Linker"})," : Dynamic linker links pre-compiled libraries during runtime. Instead of including all the library code in the executable, the dynamic linker dynamically loads the required libraries into memory and resolves references to symbols during program execution. Dynamic libraries are identified by ",(0,t.jsx)(n.code,{children:".so"})," format on Unix or ",(0,t.jsx)(n.code,{children:".dll"})," format on Windows."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"compilation-process",children:"Compilation Process"}),"\n",(0,t.jsxs)(n.p,{children:["The process of compilation can be broken down further into 6 (or 7) steps. The first 3 steps is the ",(0,t.jsx)(n.strong,{children:"front end"})," stage, where the compilers interact with high-level source code (language-dependent). The 3 (or 4) later steps are called ",(0,t.jsx)(n.strong,{children:"back end"})," stage, where the compiler focuses on generating code that is specific to the target machine from the output of front end (machine-dependent). The front end stages of compiler is same for any machine, but compiler may have different internal structure during the backend stages."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.img,{alt:"Compilation process",src:i(59801).Z+"",width:"449",height:"384"}),(0,t.jsx)(n.br,{}),"\n","Source : Book 2 page 763"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Lexical Analysis (Scanning)"})," : The first steps filter out unnecessary symbols from the source code, keeping only necessary input that comes from the language (we call it tokens). This includes removing white spaces and comments, while keeping identifier (e.g., variable names, function names), keywords, literals, operators, etc. The compiler may use the ",(0,t.jsx)(n.strong,{children:"symbol table"})," for storing global information about the compilation and code."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Syntax Analysis (Parsing)"})," : This steps analyze code correctness according to defined grammar. A ",(0,t.jsx)(n.strong,{children:"parse tree"})," (or sometimes ",(0,t.jsx)(n.strong,{children:"abstract syntax tree (AST)"}),") is constructed from the produced tokens from the previous step. The parse tree represents code organization based on grammar rules. For instance, a language may use ",(0,t.jsx)(n.a,{href:"/theory-of-computation-and-automata/context-free-grammar",children:"context-free grammar"})," do define its grammar. The compiler identifies if tokens belong to any valid categories. Compiler will continue constructing the tree whenever it encounters valid grammar, while encountering unexpected tokens gives a ",(0,t.jsx)(n.strong,{children:"syntax error"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["If a grammar is defined as ",(0,t.jsx)(n.code,{children:"<while_statement> -> while <boolean_expression> <statement>"}),", it basically means that a while statement must start with the keyword ",(0,t.jsx)(n.code,{children:"while"})," followed by an expression that returns a boolean type, and finally a statement, which performs the actual operation. The boolean expression could be a comparison, equality checking, or other. If the compiler receives ",(0,t.jsx)(n.code,{children:"while x = 3"}),", this may not conform to the grammar since ",(0,t.jsx)(n.code,{children:"x = 3"})," is not a valid boolean expression. It is more like assignment, where the grammar may look like ",(0,t.jsx)(n.code,{children:"<identifier> = <literals>"})," (i.e., ",(0,t.jsx)(n.code,{children:"x"})," is an identifier, a name given by the programmers, and 3 is a literal number)."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.img,{alt:"Parse tree",src:i(51631).Z+"",width:"420",height:"320"}),(0,t.jsx)(n.br,{}),"\n","Source : ",(0,t.jsx)(n.a,{href:"https://ruslanspivak.com/lsbasi-part7/",children:"https://ruslanspivak.com/lsbasi-part7/"})]}),"\n",(0,t.jsxs)(n.p,{children:["The above is an example of a parse tree. When the compiler sees ",(0,t.jsx)(n.code,{children:"2 * 7 + 3"}),", it recognizes that it is an expression. It knows that expression should be ",(0,t.jsx)(n.code,{children:"<term> +|-|*|/ <term>"})," (i.e., a term combined with one choice of operator and followed by another term). It further recognizes that one of the term itself is nested with the operator ",(0,t.jsx)(n.code,{children:"*"}),". A term can be obtained from a single factor, just like what 3 is, or consist of a factor multiplied by another term (which could be another single factor)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Semantic Analysis"})," : This step takes parse tree or AST from the previous step. The compiler checks the meaning of the code beyond its syntax. This can include type checking, scoping rules, and other language semantics. It may enforce that an integer type cannot be added to a string, or checking whether a variable is defined before it is used. This step produces a ",(0,t.jsx)(n.strong,{children:"decorated AST"})," which contain the semantic information."]}),"\n",(0,t.jsxs)(n.p,{children:["For instance, language like Java won't allow a string to be accessed with square bracket like an array (called string indexing). In contrast, Python allows you to get character at some index like ",(0,t.jsx)(n.code,{children:"str[3]"}),". This will be a compile-time error in Java, as it violates the language's semantics and type system (certain rules may only be checked at runtime)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Intermediate Code Generation"})," (optional) : Optionally, the AST may be translated into an intermediate language first. In some cases, the AST can be directly subjected to optimization techniques and transformed into target code without the need for an additional intermediate representation."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Machine-independent Optimization"})," : These optimizations are applied without considering the specific target machine architecture. For example, some function can be inlined, meaning the actual content of a function is substituted to the call site. This can reduce the overhead of calling a function (i.e., reduce ",(0,t.jsx)(n.a,{href:"/programming-language-theory/subroutines#call-stack",children:"call stack"})," and jumps operation)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Target Code Generation"})," : Compiler translates the decorated AST into target code specific to the target machine architecture. The target code can be assembly language or directly machine code. The target code generation stage involves mapping the high-level constructs of the source language to the low-level instructions of the target machine."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Machine-dependent Optimization"})," : Once the target code is generated, the compiler can apply additional optimizations that are specific to the target machine architecture. Examples of machine-dependent optimizations include instruction scheduling, ",(0,t.jsx)(n.a,{href:"/programming-language-theory/target-architecture#register-allocation",children:"register allocation"}),", and target-specific code transformations."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["Sometimes the process is divided into three-stage, it is called the ",(0,t.jsx)(n.strong,{children:"three-stage compiler structure"}),". In short, the 1st-3rd steps is the front end stage (language-dependent), the 4th step is middle end (machine-independent), and the 5th-6th step is the back end (machine-dependent)."]})}),"\n",(0,t.jsx)(n.h3,{id:"compilation-example",children:"Compilation Example"}),"\n",(0,t.jsx)(n.p,{children:"Suppose we have a hypothetical programming language, and we want to compile these three lines of code."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"a = 5;\nb = 1;\nc = a + b;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The scanning process removes unnecessary characters, such as whitespace, newline character, and semicolon that acts as end of line. For example, in the first line of code, we will obtain the tokens ",(0,t.jsx)(n.code,{children:"a"}),", ",(0,t.jsx)(n.code,{children:"="}),", ",(0,t.jsx)(n.code,{children:"5"}),". The ",(0,t.jsx)(n.code,{children:"a"})," doesn't correspond to any keyword of the language, so it is considered as an identifier that comes from the user. The ",(0,t.jsx)(n.code,{children:"="})," is the assignment operator that indicates right-hand side value is assigned to left-hand side identifier. The ",(0,t.jsx)(n.code,{children:"5"})," is a literal number, suppose it is an integer."]}),"\n",(0,t.jsxs)(n.p,{children:["The language will need a grammar to describe what a valid expression is. The grammar for this language is specified with ",(0,t.jsx)(n.a,{href:"/programming-language-theory/syntax#bnf",children:"BNF"}),". This will be explained more later at ",(0,t.jsx)(n.a,{href:"/programming-language-theory/syntax",children:"syntax"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"<assignment> ::= <identifier> = <expression>\n<expression> ::= <term> | <expression> + <term>\n<term> ::= <identifier> | <number>\n<identifier> ::= (list of valid character for identifier)\n<number> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"::="}),' denotes "can be replaced by" or "is defined as" (i.e., the left-hand side can be replaced with expression on the right-hand side). The ',(0,t.jsx)(n.code,{children:"|"}),' denotes an "or", it signifies that the left-hand side can be replaced to any one of the alternatives on the right-hand side.']}),"\n",(0,t.jsxs)(n.p,{children:["In the ",(0,t.jsx)(n.code,{children:"<assignment> ::= <identifier> = <expression>"})," rule, it simply says that : for an assignment to be valid, it must consist of an identifier, followed by the ",(0,t.jsx)(n.code,{children:"="})," symbol right after it, and an expression. For the identifier itself to be valid, it must consist of valid character for identifier, denoted by the ",(0,t.jsx)(n.code,{children:"<identifier>"})," rule. An expression must either be a term (which itself can be an identifier or a number) or can be another expression with the addition operator (+) and a term."]}),"\n",(0,t.jsxs)(n.p,{children:["With the expression ",(0,t.jsx)(n.code,{children:"a = 5"})," or ",(0,t.jsx)(n.code,{children:"b = 1"}),", the parser recognize that this conforms to the grammar rule for assignment (i.e., ",(0,t.jsx)(n.code,{children:"a"})," is valid identifier and; ",(0,t.jsx)(n.code,{children:"5"})," and ",(0,t.jsx)(n.code,{children:"1"})," are expression which is replaced into a term and further replaced to number). The ",(0,t.jsx)(n.code,{children:"c = a + b"})," is an assignment, in which the right-hand side expression follows the rule ",(0,t.jsx)(n.code,{children:"<expression> ::= <expression> + <term>"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"After all this parsing, the code appear to be correct, therefore an abstract syntax tree (AST) will be constructed. For the three lines of code, the constructed will look something like below."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"   =          =\n  / \\        / \\\n /   \\      /   \\\na     5    b     1\n\n   =\n  / \\\n /   \\\nc     +\n     / \\\n    a   b\n"})}),"\n",(0,t.jsx)(n.p,{children:"Then, the tree is traversed and intermediate representation (IR) of this is created. The IR may look like this."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"LOAD R1 5\nSTORE a R1\n\nLOAD R1 1\nSTORE b R1\n\nLOAD R1 a\nLOAD R2 b\nADD R1, R2 R3\nSTORE c R3\n"})}),"\n",(0,t.jsxs)(n.p,{children:['For instance, it "LOAD" the integer 5 into R1 (register 1), then store the value on R1 into an identifier ',(0,t.jsx)(n.code,{children:"a"}),". Notice that the first two assignment can be simplified. It is not necessary to load a value into register if we eventually store it back to a variable. The ",(0,t.jsx)(n.code,{children:"LOAD R1 5 STORE a R1"})," can be simplified into ",(0,t.jsx)(n.code,{children:"STORE a 5"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"With this IR, we can finally transform the program into assembly code instructions, which a CPU can execute. For example, one may look like below."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"mov [a], dword 5\nmov [b], dword 1\n\nmov eax, [a]\nmov ebx, [b]\nadd eax, ebx\nmov [c], eax\n"})}),"\n",(0,t.jsx)(n.h3,{id:"types--classification-of-compilers",children:"Types & Classification of Compilers"}),"\n",(0,t.jsx)(n.p,{children:"Classification on how compiler process source code :"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"One-pass Compiler"})," : Scanning, parsing, semantic analysis, up to code generation is done in a single pass. Source code can be directly translated into final machine code without intermediate representation. Parse tree may not be generated, so semantic analysis is performed during parsing. It is said one-pass compiler to be smaller and faster, but difficult to make and may not be able to generate program as efficient as multi-pass compiler."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Multi-pass Compiler"})," : Processes the source several of times. This allows for better code generation at the higher cost of time and memory (depending on the number of passes and the algorithm itself)."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Types of compilers :"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cross Compiler"})," : Compiler that generates executable code for a target platform different from the one on which the compiler itself runs. For example, compiling code on a Windows machine for execution on a Linux system."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Decompiler"})," : Takes an executable or binary file as input and attempts to reconstruct the original source code from which the executable was compiled. It is the reverse of compilation, going from low-level language to a higher-level language."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Transpiler"})," : Also known as ",(0,t.jsx)(n.strong,{children:"source-to-source compiler"}),", it is a compiler that translate source language to an equivalent source code in the same or different language. This includes tools like obfuscator (transform source code into a less readable and more difficult-to-understand form), minimizer (reduces the size of the source code by removing unnecessary characters such as, whitespace, and comments), and optimizer (analyzes source code and optimize it)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.a,{href:"/computer-and-programming-fundamentals/interpreter#jit-compilation",children:"Just-In-Time (JIT)"})," Compiler"]})," : A compiler that compiles code just-in-time it is executed. It dynamically compiles and optimizes code while the program is running."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},59801:(e,n,i)=>{i.d(n,{Z:()=>t});const t=i.p+"assets/images/compilation-process-5755907dbd2c8cea8c01c97d1ea7b41b.png"},68808:(e,n,i)=>{i.d(n,{Z:()=>t});const t=i.p+"assets/images/compiler-toolchain-5d57280edd4fb8756a8685ef810541f3.png"},51631:(e,n,i)=>{i.d(n,{Z:()=>t});const t=i.p+"assets/images/parse-tree-dda8029183d58cd01987baeca3dc1ea2.png"},11151:(e,n,i)=>{i.d(n,{Z:()=>a,a:()=>o});var t=i(67294);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);