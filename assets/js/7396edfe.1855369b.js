"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[9750],{15430:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>s,default:()=>l,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var a=n(85893),i=n(11151);const r={slug:"/operating-system/multithreading",id:"multithreading",title:"Multithreading",description:"Multithreading"},s=void 0,o={id:"operating-system/multithreading/multithreading",title:"Multithreading",description:"Multithreading",source:"@site/docs/operating-system/04-multithreading/multithreading.md",sourceDirName:"operating-system/04-multithreading",slug:"/operating-system/multithreading",permalink:"/cs-notes/operating-system/multithreading",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/operating-system/04-multithreading/multithreading.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1723455088e3,frontMatter:{slug:"/operating-system/multithreading",id:"multithreading",title:"Multithreading",description:"Multithreading"},sidebar:"sidebar",previous:{title:"Process Management",permalink:"/cs-notes/operating-system/process-management"},next:{title:"Process Synchronization",permalink:"/cs-notes/operating-system/process-synchronization"}},h={},c=[{value:"Thread",id:"thread",level:3},{value:"Multithreading Model",id:"multithreading-model",level:3},{value:"User &amp; Kernel Thread",id:"user--kernel-thread",level:4},{value:"Relationship Model",id:"relationship-model",level:4},{value:"Thread Management",id:"thread-management",level:3},{value:"Thread Creation &amp; Termination",id:"thread-creation--termination",level:4},{value:"Example",id:"example",level:5},{value:"Thread Execution &amp; Scheduling",id:"thread-execution--scheduling",level:4},{value:"Thread Implementation",id:"thread-implementation",level:4},{value:"Thread Communication",id:"thread-communication",level:4},{value:"Thread Synchronization",id:"thread-synchronization",level:4},{value:"Synchronization Primitives",id:"synchronization-primitives",level:5},{value:"Locks / Mutex",id:"locks--mutex",level:6},{value:"Monitor &amp; Condition Variables",id:"monitor--condition-variables",level:6},{value:"Semaphores",id:"semaphores",level:6},{value:"Barriers",id:"barriers",level:6},{value:"Spinlocks",id:"spinlocks",level:6},{value:"Scheduler-based &amp; Busy-waiting",id:"scheduler-based--busy-waiting",level:5},{value:"Atomic Operation",id:"atomic-operation",level:5},{value:"Thread Pool",id:"thread-pool",level:4},{value:"Multithreading Problems",id:"multithreading-problems",level:3}];function d(e){const t={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h3:"h3",h4:"h4",h5:"h5",h6:"h6",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Main Source:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.strong,{children:"[Chapter 4 Threads - Abraham Silberschatz-Operating System Concepts (9th,2012_12)]"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.strong,{children:"[Chapter 5 Process Synchronization - Abraham Silberschatz-Operating System Concepts (9th,2012_12)]"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Multithreading_(computer_architecture)",children:"Multithreading (computer architecture) \u2014 Wikipedia"})})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Thread_(computing)",children:"Thread (computing) \u2014 Wikipedia"})})}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.strong,{children:"Chapter 12, Programming Language Pragmatics - Michael L. Scott"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Multithreading"})," is a concept that enable us to use multiple thread to execute tasks. See ",(0,a.jsx)(t.a,{href:"/computer-and-programming-fundamentals/concurrency",children:"concurrency"})," for an introduction to concurrency."]}),"\n",(0,a.jsx)(t.h3,{id:"thread",children:"Thread"}),"\n",(0,a.jsxs)(t.p,{children:['Thread is a unit of execution in CPU, it can execute a set of instruction. Basically, it is a "worker" in a CPU. Thread exist within a ',(0,a.jsx)(t.a,{href:"/operating-system/process-management#process--thread",children:"process"})," and has its own data including thread ID, program counter, a register set, and a stack."]}),"\n",(0,a.jsx)(t.p,{children:"In multithreading, instead of just one thread or one worker in a process, multiple thread is utilized. The benefit is we are not limited to complete a single task at a time. For example, a mobile app can fetch data from remote server while also loading data from local storage. If possible, we can also divide a computationally intensive task into smaller, parallelizable subtasks, and use multiple threads to speeds up the overall execution time (achieving parallelism)."}),"\n",(0,a.jsxs)(t.p,{children:["A thread can also be ",(0,a.jsx)(t.strong,{children:"blocked"}),", which means the thread is unable to make progress or continue its execution because it is waiting for a certain event such as I/O results or condition to occur. Blocked thread can be inefficient, as it is unable to perform any useful work."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.img,{alt:"Multithreading",src:n(34611).Z+"",width:"842",height:"329"}),(0,a.jsx)(t.br,{}),"\n","Source: ",(0,a.jsx)(t.a,{href:"https://towardsdatascience.com/multithreading-and-multiprocessing-in-10-minutes-20d9b3c6a867",children:"https://towardsdatascience.com/multithreading-and-multiprocessing-in-10-minutes-20d9b3c6a867"})]}),"\n",(0,a.jsx)(t.p,{children:"The image above shows the illustration of multithreading. Each thread holds different data, but they share the same memory space and resources of the parent process. In contrast, multiprocessing is when we utilize a processor that has several cores. Each core would have their own data and thread that will execute simultaneously."}),"\n",(0,a.jsxs)(t.p,{children:["Utilizing multiple threads is typically more efficient than making multiple process that execute the same tasks (",(0,a.jsx)(t.a,{href:"/computer-and-programming-fundamentals/concurrency#multiprocessing",children:"multiprocessing"}),"). Threads have a smaller memory footprint, require less time for ",(0,a.jsx)(t.a,{href:"/operating-system/process-management#context-switch",children:"context switching"}),", and have lower scheduling overhead. Also, separate process means ",(0,a.jsx)(t.a,{href:"/operating-system/inter-process-communication",children:"IPC"})," is required to communicate between processes, whereas thread shares the same memory within a process, thus communication will be easier."]}),"\n",(0,a.jsx)(t.h3,{id:"multithreading-model",children:"Multithreading Model"}),"\n",(0,a.jsx)(t.h4,{id:"user--kernel-thread",children:"User & Kernel Thread"}),"\n",(0,a.jsxs)(t.p,{children:["There are two types of thread, ",(0,a.jsx)(t.strong,{children:"user thread"})," and ",(0,a.jsx)(t.strong,{children:"kernel thread"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["User threads, also known as ",(0,a.jsx)(t.strong,{children:"green threads"}),", are implemented and managed by a thread library or runtime system at the user level, without direct involvement of the operating system kernel. The creation, scheduling, utilization, and synchronization of user threads are handled entirely in the user space (memory space where user applications run). They may not be able to access the memory used by kernel."]}),"\n",(0,a.jsxs)(t.p,{children:["On the other hand, kernel threads, which is also known as ",(0,a.jsx)(t.strong,{children:"native threads"}),", are managed directly by the operating system kernel. Each kernel thread is represented as a separate entity within the operating system and has its own program counter, stack, and thread control block."]}),"\n",(0,a.jsx)(t.p,{children:"User threads are generally lightweight, however, they are not fully aware of the underlying thread management mechanisms. If a user thread blocks or performs an operation that blocks, it can potentially block the entire process, including all other user threads."}),"\n",(0,a.jsx)(t.p,{children:"Kernel threads are heavyweight, they require system calls and interaction with the operating system kernel for creation and management. The benefit of kernel thread is that they are fully managed by the OS, this allows for better utilization of system resources and efficient scheduling across multiple processors (achieving true parallelism)."}),"\n",(0,a.jsx)(t.h4,{id:"relationship-model",children:"Relationship Model"}),"\n",(0,a.jsx)(t.p,{children:"Relationship model between user and kernel thread describe how they are associated with each other."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Many-to-One"}),": This model involves mapping multiple user-level threads to a single kernel-level thread. The thread management and scheduling are performed by a thread library or runtime system at the user level. From the programming language, we can see and use multiple thread, but under the hood the operating system sees only a single thread. This model has efficient management, but may not take full advantage of multiprocessor systems as the execution of multiple threads is handled by a single kernel-level thread."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"One-to-One"}),": In this model, each user-level thread is mapped to a separate kernel-level thread by the operating system. This model provides more concurrency and true parallelism to the kernel-level. However, the overhead of creating and managing kernel-level threads can be higher compared to other models."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Many-to-Many"}),": This model combines the aspect of many-to-one and one-to-one. Many-to-many model consist of many kernel threads and smaller or equal number of user thread. The operating system can create multiple kernel-level threads, while the thread library manages and schedules the user-level threads across the available kernel-level threads."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.img,{alt:"Relationship model",src:n(90637).Z+"",width:"551",height:"286"}),(0,a.jsx)(t.br,{}),"\n","Source: ",(0,a.jsx)(t.a,{href:"https://www.researchgate.net/figure/Three-types-of-thread-models-Popular-operating-systems-5-22-24-adopt-the_fig1_346379550",children:"https://www.researchgate.net/figure/Three-types-of-thread-models-Popular-operating-systems-5-22-24-adopt-the_fig1_346379550"})]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"thread-management",children:"Thread Management"}),"\n",(0,a.jsx)(t.p,{children:"Multithreading implementation depends on the programming language used. Threading process involves thread creation, execution and scheduling, synchronization, and termination."}),"\n",(0,a.jsx)(t.h4,{id:"thread-creation--termination",children:"Thread Creation & Termination"}),"\n",(0,a.jsxs)(t.p,{children:["The thread library provided by programming languages have specific function or method to create and manage threads. For example, in Java, we can create a thread by implementing the ",(0,a.jsx)(t.code,{children:"Thread"})," class or the ",(0,a.jsx)(t.code,{children:"Runnable"})," interface and then invoking the ",(0,a.jsx)(t.code,{children:"start()"})," method. In C++, you can use the ",(0,a.jsx)(t.code,{children:"std::thread"})," class or the threading utilities provided by libraries like POSIX threads (",(0,a.jsx)(t.code,{children:"pthread_create()"})," function)."]}),"\n",(0,a.jsx)(t.p,{children:"When creating thread, we can specify thread attributes such as stack size, thread priority, CPU affinity. After a thread is created, it is assigned a unique identifier called the thread ID."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.img,{alt:"Thread creation in Java",src:n(35354).Z+"",width:"663",height:"383"}),(0,a.jsx)(t.br,{}),"\n","Source: ",(0,a.jsx)(t.a,{href:"http://java-latte.blogspot.com/2015/07/create-thread-using-method-reference-in-java-8.html",children:"http://java-latte.blogspot.com/2015/07/create-thread-using-method-reference-in-java-8.html"})]}),"\n",(0,a.jsxs)(t.p,{children:["Thread can be stopped explicitly using function like ",(0,a.jsx)(t.code,{children:"stop()"})," in Java. Sometimes, the thread may not stop immediately due to specific logic or condition that is required to execute before it can safely terminate. Thread can also terminate naturally when it finishes its execution, where it automatically exits, and its resources are released by the system (or saved to ",(0,a.jsx)(t.a,{href:"#thread-pool",children:"thread pool"}),")."]}),"\n",(0,a.jsxs)(t.p,{children:["It is important to note that thread termination should be handled carefully. For example, a thread may have used some data structure, but when it is not freed before the termination, this can cause ",(0,a.jsx)(t.a,{href:"/computer-security/other-attack-and-exploit#memory-leak",children:"memory leak"}),"."]}),"\n",(0,a.jsx)(t.h5,{id:"example",children:"Example"}),"\n",(0,a.jsxs)(t.p,{children:["One reason to implement the ",(0,a.jsx)(t.code,{children:"Thread"})," class is to encapsulate application logic that is intended to be run in separate thread. In a server app, it is expected that the server handle multiple request in parallel. Let's say server is trying to read and write an input."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"public class ClientHandlerThread extends Thread {\n    private Socket clientSocket;\n\n    public ClientHandlerThread(Socket clientSocket) {\n        this.clientSocket = clientSocket;\n    }\n\n    public void run() {\n        try {\n            // Get the input stream from the client\n            InputStream inputStream = clientSocket.getInputStream();\n\n            // Read the client's request\n            byte[] buffer = new byte[1024];\n            int bytesRead = inputStream.read(buffer);\n\n            // Process the request (example: convert to uppercase)\n            String request = new String(buffer, 0, bytesRead);\n            String response = request.toUpperCase();\n\n            // Get the output stream to send the response to the client\n            OutputStream outputStream = clientSocket.getOutputStream();\n\n            // Send the response back to the client\n            outputStream.write(response.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            // Close the client socket\n            try {\n                clientSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"This implementation of thread encapsulate the logic of reading, processing, and responding back to user request. We can use it like below."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:'public class Server {\n    public static void main(String[] args) {\n        try {\n            // Create a server socket\n            ServerSocket serverSocket = new ServerSocket(8080);\n            System.out.println("Server listening on port 8080");\n\n            while (true) {\n                // Accept client connections\n                Socket clientSocket = serverSocket.accept();\n                System.out.println("Client connected: " + clientSocket.getInetAddress());\n\n                // Create a new thread to handle the client connection\n                ClientHandlerThread clientHandlerThread = new ClientHandlerThread(clientSocket);\n                clientHandlerThread.start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["For each client connection, we create a new thread through the ",(0,a.jsx)(t.code,{children:"ClientHandlerThread"})," and start it to handle the connection."]}),"\n",(0,a.jsx)(t.h4,{id:"thread-execution--scheduling",children:"Thread Execution & Scheduling"}),"\n",(0,a.jsxs)(t.p,{children:["In Java, we can start the execution of a thread, by calling the ",(0,a.jsx)(t.code,{children:"start()"})," method on the ",(0,a.jsx)(t.code,{children:"Thread"})," object. The ",(0,a.jsx)(t.code,{children:"start()"})," method internally calls the thread's ",(0,a.jsx)(t.code,{children:"run()"})," method, which contains the code that will be executed by the thread. The JVM manages the execution of threads and ensures that the ",(0,a.jsx)(t.code,{children:"run()"})," method is executed concurrently with other threads."]}),"\n",(0,a.jsxs)(t.p,{children:["Thread scheduling in Java is handled by the JVM and the operating system. The JVM uses a ",(0,a.jsx)(t.a,{href:"/operating-system/process-management#multitasking",children:"preemptive scheduling algorithm"}),", where the operating system decides when to switch between threads. Similar to process scheduling, this involves ",(0,a.jsx)(t.a,{href:"/operating-system/process-management#context-switch",children:"context switch"})," to save the thread state, determining based on some ",(0,a.jsx)(t.a,{href:"/operating-system/process-management#scheduling-algorithms",children:"scheduling algorithm"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["Java provides methods like ",(0,a.jsx)(t.code,{children:"yield()"})," and ",(0,a.jsx)(t.code,{children:"sleep()"})," to influence thread scheduling. The ",(0,a.jsx)(t.code,{children:"yield()"})," method allows a thread to voluntarily give up its remaining time slice, allowing other threads to run. The ",(0,a.jsx)(t.code,{children:"sleep()"})," method pauses the execution of a thread for a specified period of time."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.img,{alt:"Thread state in Java",src:n(81155).Z+"",width:"552",height:"449"}),(0,a.jsx)(t.br,{}),"\n","Source: ",(0,a.jsx)(t.a,{href:"https://medium.com/spring-boot/multithreading-in-java-with-examples-25b0bc80831b",children:"https://medium.com/spring-boot/multithreading-in-java-with-examples-25b0bc80831b"})]}),"\n",(0,a.jsx)(t.h4,{id:"thread-implementation",children:"Thread Implementation"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.a,{href:"#relationship-model",children:"relationship model"})," of thread relates to how they are implemented. One process correspond to one kernel thread that executes tasks for that process. The language runtime or library implement a ",(0,a.jsx)(t.strong,{children:"thread scheduler"})," that will schedule the execution of thread as well as managing thread pool for the process. The OS kernel implements a ",(0,a.jsx)(t.strong,{children:"process scheduler"})," that will schedule the physical processor to execute certain process. This implementation is known as the ",(0,a.jsx)(t.strong,{children:"two-level implementation of thread"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.img,{alt:"Thread implementation",src:n(62109).Z+"",width:"472",height:"381"}),(0,a.jsx)(t.br,{}),"\n","Source: Programming Language Pragmatics - Michael L. Scott page 614"]}),"\n",(0,a.jsx)(t.h4,{id:"thread-communication",children:"Thread Communication"}),"\n",(0,a.jsxs)(t.p,{children:["Multiple threads exist within the same process, external threads can communicate using the ",(0,a.jsx)(t.a,{href:"/operating-system/inter-process-communication",children:"IPC mechanism"}),". There are two method, the first method is ",(0,a.jsx)(t.a,{href:"/operating-system/inter-process-communication#shared-memory",children:"shared memory"}),", where each thread read and write data in the same region of memory. The other method is ",(0,a.jsx)(t.a,{href:"/operating-system/inter-process-communication#message-passing",children:"message passing"}),", where they send messages or signals to each other. One thread can send a message to another thread, which then receives and processes the message."]}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsx)(t.p,{children:"Although they are for process communication, it may be used to communicate between thread if they are running in separate processes. If threads were to communicate between the same process, typically they would directly access and communicate with each other through shared variables or data structures."})}),"\n",(0,a.jsx)(t.h4,{id:"thread-synchronization",children:"Thread Synchronization"}),"\n",(0,a.jsxs)(t.p,{children:["Synchronizing threads is crucial to ensure proper coordination and consistency when multiple threads access shared resources and communicate. This helps prevent ",(0,a.jsx)(t.a,{href:"#multithreading-problems",children:"concurrency issues"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["When a code or data structure can be safely accessed and modified by multiple threads concurrently without causing unexpected or incorrect behavior, this is called ",(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.a,{href:"/computer-and-programming-fundamentals/concurrency#thread-safe",children:"thread safe"})}),"."]}),"\n",(0,a.jsx)(t.h5,{id:"synchronization-primitives",children:"Synchronization Primitives"}),"\n",(0,a.jsx)(t.p,{children:"These are fundamental, low-level mechanism used in multithreaded environment to synchronize."}),"\n",(0,a.jsx)(t.h6,{id:"locks--mutex",children:"Locks / Mutex"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Mutex (mutual exclusion)"})," is a synchronization primitive that ensure only one thread to access a shared resource. It works by having a lock, a thread that wants to access the resource must ",(0,a.jsx)(t.em,{children:"acquire"})," the lock first. If the lock is already held by another thread, the requesting thread will be blocked until the lock is ",(0,a.jsx)(t.em,{children:"released"}),". If the thread that access the resource has finished, only then the lock will be released."]}),"\n",(0,a.jsx)(t.p,{children:"The mutex technique can be implemented in the software-level by memory synchronization instructions provided by the hardware architecture."}),"\n",(0,a.jsx)(t.p,{children:"There are three types of locks:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Shared lock"}),": Multiple thread is able to read same data simultaneously."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Exclusive lock (mutex)"}),": When a thread acquire an exclusive lock, it has exclusive access to the data until the lock is released."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Update lock"}),": Combination of shared and exclusive locks, allowing multiple thread to read, but only one thread to update the data at a time."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.img,{alt:"Mutex",src:n(86890).Z+"",width:"584",height:"164"}),(0,a.jsx)(t.br,{}),"\n","Source: ",(0,a.jsx)(t.a,{href:"https://www.javatpoint.com/mutex-vs-semaphore",children:"https://www.javatpoint.com/mutex-vs-semaphore"})]}),"\n",(0,a.jsx)(t.h6,{id:"monitor--condition-variables",children:"Monitor & Condition Variables"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Condition variables"})," are synchronization primitives that allow threads to wait for a specific condition to become true before proceeding with their execution. Condition variables are typically used together with lock, forming another construct, ",(0,a.jsx)(t.strong,{children:"monitors"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Monitors"})," is a higher-level synchronization construct that combines mutex and condition variables. The mutex is used to ensure only one thread is accessing the resource, while the condition variables is used for additional coordination between the threads."]}),"\n",(0,a.jsxs)(t.p,{children:["In a sense, condition variable is actually a ",(0,a.jsx)(t.a,{href:"/data-structures-and-algorithms/queue",children:"queue"}),". Threads will be kept in the queue until a condition is met. The condition variable has three operations:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Wait"}),': The "wait" operation temporarily release the associated mutex and enter a wait state on a condition variable, effectively blocking its execution. It is typically called when the thread or process encounters a condition that prevents it from proceeding.']}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Signal"}),': The "signal" operation is used to awaken one waiting thread or process that is blocked on a particular condition variable, such as wait state. It notifies a single waiting thread or process that the condition it was waiting for may have changed. The awakened thread or process can then reacquire the associated lock or mutex and continue its execution.']}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Broadcast"}),': The "broadcast" operation is used to awaken all waiting threads or processes that are blocked on a particular condition variable.']}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Monitors work like following:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"When a thread wants to access the shared data, it first needs to acquire the monitor's lock. If the lock is already held by another thread, the requesting thread will be blocked until the lock becomes available."}),"\n",(0,a.jsx)(t.li,{children:"Once a thread has acquired the lock, it enters the monitor and gains exclusive access to the shared data. The thread can then perform operations on the data inside a critical section."}),"\n",(0,a.jsx)(t.li,{children:"In the case of success operation, once a thread completes, it releases the monitor's lock, allowing other threads to acquire it. The thread exits the monitor, making it available for other threads to enter."}),"\n",(0,a.jsx)(t.li,{children:"In the case when the thread encounter whatever condition that prevent it from proceeding, such as a specific state of the shared resource, it may signal or broadcast the other threads."}),"\n",(0,a.jsx)(t.li,{children:"Another thread, which are signaled, can modify the shared data in a way that affects the other waiting threads' conditions, in which it can signal or broadcast again."}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.img,{alt:"Monitors",src:n(73849).Z+"",width:"517",height:"491"}),(0,a.jsx)(t.br,{}),"\n","Source: ",(0,a.jsx)(t.a,{href:"https://dev.to/l04db4l4nc3r/process-synchronization-monitors-in-go-4g4k",children:"https://dev.to/l04db4l4nc3r/process-synchronization-monitors-in-go-4g4k"})]}),"\n",(0,a.jsx)(t.h6,{id:"semaphores",children:"Semaphores"}),"\n",(0,a.jsx)(t.p,{children:"Semaphore allows specified number of thread to access a shared resource. A semaphore maintains a count, and when a thread wants to access resource, it attempts to acquire the semaphore. If the count is greater than zero, the thread is allowed to proceed, and the count is decremented. If the count is zero, indicating that the resource is currently in use, the thread will be blocked until another thread releases the semaphore, which increments the count."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.img,{alt:"Semaphores",src:n(69429).Z+"",width:"509",height:"226"}),(0,a.jsx)(t.br,{}),"\n","Source: ",(0,a.jsx)(t.a,{href:"https://stackoverflow.com/questions/34519/what-is-a-semaphore",children:"https://stackoverflow.com/questions/34519/what-is-a-semaphore"})]}),"\n",(0,a.jsx)(t.h6,{id:"barriers",children:"Barriers"}),"\n",(0,a.jsx)(t.p,{children:"Barrier is a way to synchronize a group of threads at a specific point in code. Threads reach the barrier and wait until all participating threads have arrived. Once all threads have reached the barrier, they are released simultaneously, allowing them to continue their execution."}),"\n",(0,a.jsx)(t.p,{children:"It is typically used in parallel tasks where they need to synchronize their progress at certain stages of execution, such as dividing a larger computation into smaller parts and waiting for all parts to complete before proceeding to the next stage."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.img,{alt:"Barriers",src:n(72388).Z+"",width:"634",height:"208"}),(0,a.jsx)(t.br,{}),"\n","Source: ",(0,a.jsx)(t.a,{href:"https://www.ictdemy.com/java/threads/multithreading-in-java-barrier-countdownlatch",children:"https://www.ictdemy.com/java/threads/multithreading-in-java-barrier-countdownlatch"})]}),"\n",(0,a.jsx)(t.h6,{id:"spinlocks",children:"Spinlocks"}),"\n",(0,a.jsxs)(t.p,{children:["A thread ",(0,a.jsx)(t.em,{children:"spins"}),", which means that it continuously executes a loop that frequently checks a condition, waiting for a certain state to be reached."]}),"\n",(0,a.jsx)(t.p,{children:"The basic idea of a spinlock is that a thread attempting to acquire the lock repeatedly checks if the lock is available in a tight loop, spinning until it becomes available. The thread keeps spinning until it successfully acquires the lock, at which point it can proceed with the critical section of code or the shared resource it wants to access."}),"\n",(0,a.jsx)(t.p,{children:"This differs from traditional locks where the thread would be put to sleep if the lock is unavailable. Spinlocks are useful in situations where the expected wait time for acquiring a lock is very short, and the overhead of putting a thread to sleep and waking it up is considered too costly."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.img,{alt:"Spinlocks",src:n(31501).Z+"",width:"423",height:"236"}),(0,a.jsx)(t.br,{}),"\n","Source: ",(0,a.jsx)(t.a,{href:"https://www.quora.com/What-are-the-advantages-and-disadvantages-of-using-a-spinlock-in-the-kernel-of-an-operating-system-keep-in-mind-there-may-be-multiple-processors",children:"https://www.quora.com/What-are-the-advantages-and-disadvantages-of-using-a-spinlock-in-the-kernel-of-an-operating-system-keep-in-mind-there-may-be-multiple-processors"})]}),"\n",(0,a.jsx)(t.h5,{id:"scheduler-based--busy-waiting",children:"Scheduler-based & Busy-waiting"}),"\n",(0,a.jsxs)(t.p,{children:["Locks, monitors, and semaphores are considered ",(0,a.jsx)(t.strong,{children:"scheduler-based synchronization"})," mechanisms. With these mechanisms, threads are required to yield CPU time to a scheduler and depend on it to schedule their execution. Barriers and spinlocks are considered ",(0,a.jsx)(t.strong,{children:"busy-waiting synchronization"})," mechanisms, in which threads repeatedly check for synchronization conditions to be satisfied in a loop."]}),"\n",(0,a.jsxs)(t.p,{children:["Scheduler-based synchronization introduces potential delays due to ",(0,a.jsx)(t.a,{href:"/operating-system/process-management#context-switch",children:"context switches"})," that occur when a thread is switched during scheduling. When a thread encounters a synchronization point and needs to wait for a condition to be satisfied (e.g., acquiring a lock or waiting for a signal), it enters a blocked or waiting state. The thread is then removed from the set of active threads that can execute, and the scheduler performs a context switch to switch to another eligible thread that can make progress."]}),"\n",(0,a.jsx)(t.p,{children:"In contrast, without relying on the scheduler, the busy-waiting mechanism can achieve lower latency, but it may consume more CPU resources as the thread continuously loops."}),"\n",(0,a.jsx)(t.h5,{id:"atomic-operation",children:"Atomic Operation"}),"\n",(0,a.jsxs)(t.p,{children:["Atomic operations are operations that are guaranteed to be executed atomically without interruption. They provide a way to perform thread-safe operations on shared variables without the need for locks or synchronization primitives. Atomic operations are typically used for simple operations like incrementing or decrementing a variable. Atomic operations are supported directly by the OS or hardware with specific instructions. For example, we may be able to write to a memory location and return the old value, this is often called ",(0,a.jsx)(t.strong,{children:"test-and-set"})," instruction."]}),"\n",(0,a.jsx)(t.h4,{id:"thread-pool",children:"Thread Pool"}),"\n",(0,a.jsx)(t.p,{children:"Thread pool is a technique to improve performance and resource management in multithreaded applications."}),"\n",(0,a.jsxs)(t.p,{children:["When there are pre-allocated threads which are waiting and ready to be used to execute tasks, they are stored in ",(0,a.jsx)(t.strong,{children:"thread pools"}),". Thread pool isn't just a place where you store thread after their creation, it is a place where you maintain a set of reusable threads. These threads are created in advance and added to the pool. When a task arrives, a thread from the pool is assigned to execute it. Once the task is completed, the thread is returned to the pool for reuse. Thread pool allows for efficient resource management, it helps to reduce the resource exhaustion when creating new thread."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.img,{alt:"Thread pool",src:n(82709).Z+"",width:"479",height:"214"}),(0,a.jsx)(t.br,{}),"\n","Source: ",(0,a.jsx)(t.a,{href:"https://dip-mazumder.medium.com/how-to-determine-java-thread-pool-size-a-comprehensive-guide-4f73a4758273",children:"https://dip-mazumder.medium.com/how-to-determine-java-thread-pool-size-a-comprehensive-guide-4f73a4758273"})]}),"\n",(0,a.jsx)(t.h3,{id:"multithreading-problems",children:"Multithreading Problems"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Race conditions"}),": Race conditions occur when multiple threads access shared data concurrently and try to modify it simultaneously. This can lead to unpredictable and incorrect results, because each thread may observe the data differently, some may access it after modification, and so may not."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Race condition",src:n(42174).Z+"",width:"819",height:"378"})}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Starvation"}),": Starvation occurs when a thread is blocked from gaining access to required resources. This can lead to a thread not making progress and adversely affect overall system performance."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Deadlocks"}),": Deadlocks occurs when two or more threads are blocked indefinitely waiting for each other."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.img,{alt:"Deadlock",src:n(9560).Z+"",width:"380",height:"257"}),(0,a.jsx)(t.br,{}),"\n","Source: ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Deadlock",children:"https://en.wikipedia.org/wiki/Deadlock"})]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Livelock"}),": Livelock is similar to a deadlock, but in a livelock, the processes or threads are not blocked or waiting for a resource explicitly. Instead, they are continuously reacting to each other's actions in a way that prevents any of them from making forward progress."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.img,{alt:"Livelock",src:n(44602).Z+"",width:"636",height:"422"}),(0,a.jsx)(t.br,{}),"\n","Source: ",(0,a.jsx)(t.a,{href:"http://15418.courses.cs.cmu.edu/spring2014/lecture/snoopimpl1/slide_021",children:"http://15418.courses.cs.cmu.edu/spring2014/lecture/snoopimpl1/slide_021"})]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.admonition,{type:"tip",children:(0,a.jsxs)(t.p,{children:["In relation to concurrency, see also ",(0,a.jsx)(t.a,{href:"/computer-and-programming-fundamentals/concurrency",children:"concurrency"}),"."]})})]})}function l(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},72388:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/barrier-e14f940e5159ac96f53246fed3656e06.png"},9560:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/deadlock-cae19d8db430f8355244b5ae6e57977f.gif"},44602:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/livelock-3ef0ca56e62834558f82634e28a83877.png"},73849:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/monitors-345e5729bd0f08db0e1b96e33283a1e0.png"},34611:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/multithread-9188c0330bdee33732c95c88e88325d7.png"},86890:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/mutex-9b6e70af45c9214f8854b350da3885fe.png"},42174:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/race-condition-2409cdf955c3ea05e59fee5de1c766ae.png"},90637:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/relationship-model-c899acc248ce46e84641242df298f23a.png"},69429:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/semaphore-94bc8b06417209ea4e31b0e949df9dd3.png"},31501:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/spinlock-0823f5449cd9f5e12b67ef1a53ef50de.png"},35354:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/thread-creation-992c1a16f51cb5b9cffa5338804acd5d.png"},62109:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/thread-implementation-1027e4737a9ab2b7393c85a63c4a1df5.png"},82709:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/thread-pool-adb1157d7d2b6e29c6bab18fdb8eb502.png"},81155:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/thread-state-in-java-f97c0ed50e4fbf6a9fe666737179fd9b.png"},11151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>s});var a=n(67294);const i={},r=a.createContext(i);function s(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);