"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[6881],{3905:(e,a,t)=>{t.d(a,{Zo:()=>l,kt:()=>u});var n=t(67294);function s(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function r(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach((function(a){s(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function m(e,a){if(null==e)return{};var t,n,s=function(e,a){if(null==e)return{};var t,n,s={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||(s[t]=e[t]);return s}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var p=n.createContext({}),o=function(e){var a=n.useContext(p),t=a;return e&&(t="function"==typeof e?e(a):r(r({},a),e)),t},l=function(e){var a=o(e.components);return n.createElement(p.Provider,{value:a},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},h=n.forwardRef((function(e,a){var t=e.components,s=e.mdxType,i=e.originalType,p=e.parentName,l=m(e,["components","mdxType","originalType","parentName"]),c=o(t),h=s,u=c["".concat(p,".").concat(h)]||c[h]||d[h]||i;return t?n.createElement(u,r(r({ref:a},l),{},{components:t})):n.createElement(u,r({ref:a},l))}));function u(e,a){var t=arguments,s=a&&a.mdxType;if("string"==typeof e||s){var i=t.length,r=new Array(i);r[0]=h;var m={};for(var p in a)hasOwnProperty.call(a,p)&&(m[p]=a[p]);m.originalType=e,m[c]="string"==typeof e?e:s,r[1]=m;for(var o=2;o<i;o++)r[o]=t[o];return n.createElement.apply(null,r)}return n.createElement.apply(null,t)}h.displayName="MDXCreateElement"},8681:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>p,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>m,toc:()=>o});var n=t(87462),s=(t(67294),t(3905));const i={slug:"/deep-learning/diffusion-model",id:"diffusion-model",title:"Diffusion Model",description:"Diffusion Model"},r=void 0,m={unversionedId:"deep-learning/diffusion-model/diffusion-model",id:"deep-learning/diffusion-model/diffusion-model",title:"Diffusion Model",description:"Diffusion Model",source:"@site/docs/deep-learning/15-diffusion-model/diffusion-model.md",sourceDirName:"deep-learning/15-diffusion-model",slug:"/deep-learning/diffusion-model",permalink:"/cs-notes/deep-learning/diffusion-model",draft:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/deep-learning/15-diffusion-model/diffusion-model.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1697883255,formattedLastUpdatedAt:"Oct 21, 2023",frontMatter:{slug:"/deep-learning/diffusion-model",id:"diffusion-model",title:"Diffusion Model",description:"Diffusion Model"},sidebar:"sidebar",previous:{title:"Vision Transformers",permalink:"/cs-notes/deep-learning/transformers/vision-transformers"},next:{title:"Reinforcement Learning Fundamental",permalink:"/cs-notes/deep-learning/reinforcement-learning/reinforcement-learning-fundamental"}},p={},o=[{value:"Denoising Diffusion Model",id:"denoising-diffusion-model",level:2},{value:"Denoising Diffusion Probabilistic Model (DDPM)",id:"denoising-diffusion-probabilistic-model-ddpm",level:3},{value:"Forward Process",id:"forward-process",level:4},{value:"Reverse Process",id:"reverse-process",level:4},{value:"Training Objective",id:"training-objective",level:4},{value:"Summary",id:"summary",level:4},{value:"Denoising Diffusion Implicit Models (DDIM)",id:"denoising-diffusion-implicit-models-ddim",level:3},{value:"Conditional &amp; Unconditional Generation",id:"conditional--unconditional-generation",level:3},{value:"Unconditional",id:"unconditional",level:4},{value:"Conditional",id:"conditional",level:4},{value:"Score-Based Diffusion Model (SBDM)",id:"score-based-diffusion-model-sbdm",level:2},{value:"Score Function",id:"score-function",level:3},{value:"Continuous Diffusion Model",id:"continuous-diffusion-model",level:2},{value:"Sampler",id:"sampler",level:3},{value:"Ancestral Sampler",id:"ancestral-sampler",level:4},{value:"Latent Diffusion Model (LDM)",id:"latent-diffusion-model-ldm",level:2},{value:"Stable Diffusion",id:"stable-diffusion",level:3},{value:"Architecture",id:"architecture",level:4},{value:"Contrastive Language-Image Pre-Training (CLIP)",id:"contrastive-language-image-pre-training-clip",level:2}],l={toc:o},c="wrapper";function d(e){let{components:a,...i}=e;return(0,s.kt)(c,(0,n.Z)({},l,i,{components:a,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Main Source :")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},(0,s.kt)("a",{parentName:"strong",href:"https://en.wikipedia.org/wiki/Diffusion_model"},"Wikipedia Diffusion model"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},(0,s.kt)("a",{parentName:"strong",href:"https://youtu.be/fbLgFrlTnGU?si=tR6le4piBvVpeR_9"},"What are Diffusion Models? - Ari Seff"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},(0,s.kt)("a",{parentName:"strong",href:"https://www.assemblyai.com/blog/diffusion-models-for-machine-learning-introduction/"},"Introduction to Diffusion Models for Machine Learning - AssemblyAI"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},(0,s.kt)("a",{parentName:"strong",href:"https://youtu.be/aUqbWBQTKaA?si=BONjB3Ul4iGOmy-1"},"[Lab Seminar] DDIM: Denoising Diffusion Implicit Model (ICLR, 2021) - DSAIL SKKU"))),(0,s.kt)("li",{parentName:"ul"},"Good article : ",(0,s.kt)("strong",{parentName:"li"},(0,s.kt)("a",{parentName:"strong",href:"https://theaisummer.com/diffusion-models/"},"How diffusion models work: the math from scratch by Sergios Karagiannakos,Nikolas Adaloglou"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},(0,s.kt)("a",{parentName:"strong",href:"https://stable-diffusion-art.com/samplers/"},"Stable Diffusion Samplers: A Comprehensive Guide"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},(0,s.kt)("a",{parentName:"strong",href:"https://youtu.be/J87hffSMB60?si=yPxmuVSLbgcxPJTN"},"How does Stable Diffusion work? \u2013 Latent Diffusion Models EXPLAINED - AI Coffee Break with Letitia"))),(0,s.kt)("li",{parentName:"ul"},"LDM / stable diffusion paper : ",(0,s.kt)("strong",{parentName:"li"},(0,s.kt)("a",{parentName:"strong",href:"https://arxiv.org/abs/2112.10752"},"High-Resolution Image Synthesis with Latent Diffusion Models")))),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Diffusion Model")," is a class of generative model, meaning it generates new data by learning the underlying distribution of a given dataset and uses this knowledge to generate new data samples. Diffusion model is typically used for tasks including image generation, image denoising, generating high-resolution image, and etc."),(0,s.kt)("p",null,"Diffusion model is inspired by the concept of ",(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Diffusion"},"diffusion")," in physics, which is a stochastic phenomenon where particles spread out from an area of high concentration to an area of low concentration, eventually leading to a uniform concentration. The underlying principles and equations of diffusion in physics provide a mathematical foundation that is adapted and applied to model to generates data."),(0,s.kt)("p",null,"The idea of diffusion model is, we model the target image (the target image we want to generate) as a data distribution (called target distribution), and then the model will aim to transform a simple base distribution, typically a Gaussian distribution, into the target distribution through an iterative diffusion process."),(0,s.kt)("video",{width:"720",height:"360",controls:!0},(0,s.kt)("source",{src:"https://learnopencv.com/wp-content/uploads/2023/02/denoising-diffusion-probabilistic-models_flower_inference_2.mp4",type:"video/mp4"})),(0,s.kt)("p",null,"Source : ",(0,s.kt)("a",{parentName:"p",href:"https://learnopencv.com/denoising-diffusion-probabilistic-models/"},"https://learnopencv.com/denoising-diffusion-probabilistic-models/")),(0,s.kt)("h2",{id:"denoising-diffusion-model"},"Denoising Diffusion Model"),(0,s.kt)("p",null,"There are many variation of diffusion model, each with their own concept, ",(0,s.kt)("strong",{parentName:"p"},"Denoising Diffusion Model")," is the type of diffusion model that uses the diffusion concept."),(0,s.kt)("h3",{id:"denoising-diffusion-probabilistic-model-ddpm"},"Denoising Diffusion Probabilistic Model (DDPM)"),(0,s.kt)("p",null,"The type of denoising diffusion model that learns the underlying ",(0,s.kt)("strong",{parentName:"p"},"probability distribution")," of a dataset and generate new samples from that distribution."),(0,s.kt)("p",null,"The overall process of denoising diffusion model consist of two steps, the forward process that gradually add noise to the image, and the reverse process that tries to reverse the process or remove the noise to generate clean samples."),(0,s.kt)("h4",{id:"forward-process"},"Forward Process"),(0,s.kt)("p",null,"In DDPM, the noising process is modeled using a ",(0,s.kt)("a",{parentName:"p",href:"/deep-learning/reinforcement-learning/markov-models#markov-chain"},(0,s.kt)("strong",{parentName:"a"},"Markov chain")),". Markov chain is a mathematical model that assumes the future state of a system only depends on current step. In other word, the current state of a system depends only on the previous state. The key idea behind using a Markov chain in diffusion models is to describe the evolution of the system's state as an iterative stochastic process."),(0,s.kt)("p",null,"The forward process begins with adding noise to the image in gradual manner, the process will be divided into discrete time steps. The noise, we are adding is modeled using a ",(0,s.kt)("strong",{parentName:"p"},"Gaussian (normal) distribution"),". A Gaussian distribution is characterized by its mean (",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"\u03bc")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mu")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"\u03bc"))))),") and variance (",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("msup",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msup"},"\u03c3"),(0,s.kt)("mn",{parentName:"msup"},"2"))),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\sigma^2")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8141em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"\u03c3"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))))))),"), which determine the central tendency and spread of the distribution, respectively."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Gaussian distribution noises",src:t(90543).Z,width:"666",height:"245"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://analyticsindiamag.com/a-guide-to-different-types-of-noises-and-image-denoising-methods/"},"https://analyticsindiamag.com/a-guide-to-different-types-of-noises-and-image-denoising-methods/")),(0,s.kt)("p",null,"Utilizing the Markov chain with diffusion model, the distribution of noise at some time step ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"t")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"t")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6151em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"t")))))," only depends on previous time step ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"t"),(0,s.kt)("mo",{parentName:"mrow"},"\u2212"),(0,s.kt)("mn",{parentName:"mrow"},"1")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"t-1")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6984em",verticalAlign:"-0.0833em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.kt)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"1"))))),". Following the calculation in Markov chain, current step distribution will be calculated by the product of each previously conditional step."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Forward process notation",src:t(80186).Z,width:"369",height:"249"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://youtu.be/fbLgFrlTnGU?si=tR6le4piBvVpeR_9&t=109"},"https://youtu.be/fbLgFrlTnGU?si=tR6le4piBvVpeR_9&t=109")),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"The forward process is fixed, meaning it doesn't have learnable parameters.")),(0,s.kt)("p",null,"In the context of diffusion model, the type of Gaussian distribution used is the ",(0,s.kt)("strong",{parentName:"p"},"diagonal Gaussian distribution"),". The variance, denoted as ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"\u03b2")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\beta")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05278em"}},"\u03b2"))))),", varies at each time step and is constrained to be within the range of 0 and 1. The lower variance implies that the diffusion or transformation of the distribution occurs more gradually and with smaller perturbations, which may help us on the reverse process."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Gaussian distribution",src:t(43061).Z,width:"490",height:"103"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://youtu.be/fbLgFrlTnGU?si=mN1d8DKDP9vYJjQ0&t=129"},"https://youtu.be/fbLgFrlTnGU?si=mN1d8DKDP9vYJjQ0&t=129")),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"The beta parameters is used to control or adjust the noise added in forward process or removed in the reverse process, this technique is also called ",(0,s.kt)("strong",{parentName:"p"},"noise scheduling"),".")),(0,s.kt)("p",null,"As we iteratively perform the forward diffusion process, the noise gradually converges towards a Gaussian distribution. Mathematically speaking, the noise can be approximated as a ",(0,s.kt)("strong",{parentName:"p"},"multivariate Gaussian distribution with a mean vector of zero and an identity covariance matrix"),"."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Getting closer to identity matrix",src:t(81777).Z,width:"471",height:"192"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://youtu.be/fbLgFrlTnGU?si=C8gzMh3VVKSUXqBg&t=163"},"https://youtu.be/fbLgFrlTnGU?si=C8gzMh3VVKSUXqBg&t=163")),(0,s.kt)("h4",{id:"reverse-process"},"Reverse Process"),(0,s.kt)("p",null,"The reverse process will also be modeled using Markov chain, the noise will be assumed as a ",(0,s.kt)("strong",{parentName:"p"},"unimodal diagonal Gaussian distribution")," (the formula above in the image below), which takes current state (",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("msub",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msub"},"x"),(0,s.kt)("mi",{parentName:"msub"},"t"))),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x_t")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.5806em",verticalAlign:"-0.15em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.2806em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"t")))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,s.kt)("span",{parentName:"span"})))))))))),") and current time step (",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"t")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"t")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6151em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"))))),") as input."),(0,s.kt)("p",null,"In the reverse process of a diffusion model, it involves inferring the previous step given the current step. The calculation is done by multiplying the product of conditional distributions at each time step in reverse order (",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("msub",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msub"},"x"),(0,s.kt)("mrow",{parentName:"msub"},(0,s.kt)("mi",{parentName:"mrow"},"t"),(0,s.kt)("mo",{parentName:"mrow"},"\u2212"),(0,s.kt)("mn",{parentName:"mrow"},"1"))),(0,s.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,s.kt)("msub",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msub"},"x"),(0,s.kt)("mi",{parentName:"msub"},"t"))),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x_{t - 1} | x_t")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"t"),(0,s.kt)("span",{parentName:"span",className:"mbin mtight"},"\u2212"),(0,s.kt)("span",{parentName:"span",className:"mord mtight"},"1"))))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.2083em"}},(0,s.kt)("span",{parentName:"span"})))))),(0,s.kt)("span",{parentName:"span",className:"mord"},"\u2223"),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.2806em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"t")))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,s.kt)("span",{parentName:"span"})))))))))),") with the Gaussian noise distribution, denoted as ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"p"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("msub",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msub"},"x"),(0,s.kt)("mi",{parentName:"msub"},"T")),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"p(x_T)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3283em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.13889em"}},"T")))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,s.kt)("span",{parentName:"span"})))))),(0,s.kt)("span",{parentName:"span",className:"mclose"},")"))))),", which was generated during the forward process (We assume the forward diffusion approaches Gaussian distribution)."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Reverse process notation",src:t(73497).Z,width:"462",height:"340"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://youtu.be/fbLgFrlTnGU?si=v6ixlxk-gmWiHtDW&t=279"},"https://youtu.be/fbLgFrlTnGU?si=v6ixlxk-gmWiHtDW&t=279")),(0,s.kt)("p",null,"The inference process is where the process is made learnable or adjustable. In the implementation of reverse process, there are two parameters, the mean (",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"\u03bc")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mu")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"\u03bc"))))),") and the variance (",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u03a3")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\Sigma")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6833em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"\u03a3"))))),") of the Gaussian distribution. The variance is made fixed and only the mean is made learnable, for training stabilization purposes. In essence, the model will dynamically learn and adapt the optimal parameters to effectively reverse the diffusion process."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Reverse process implementation",src:t(8960).Z,width:"524",height:"110"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://youtu.be/fbLgFrlTnGU?si=o0xlAFVkGm6B4nHr&t=651"},"https://youtu.be/fbLgFrlTnGU?si=o0xlAFVkGm6B4nHr&t=651")),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"The implementation of the reverse or denoising process typically uses the ",(0,s.kt)("a",{parentName:"p",href:"/deep-learning/u-net"},"U-Net architecture")," for image data or a ",(0,s.kt)("a",{parentName:"p",href:"/deep-learning/transformers/transformers-architecture"},"transformers")," for non-image data.")),(0,s.kt)("h4",{id:"training-objective"},"Training Objective"),(0,s.kt)("p",null,"The forward and reverse process can be understood as process that transform data or distribution (the input image) in two different directions. The forward process involves adding noise that will make the data distribution approach Gaussian distribution. The reverse process involves transforming the data back to its original distribution. This is done by approximating the unnoised data, by doing this, we effectively generate new data points during this process."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"The objective of diffusion model",src:t(98540).Z,width:"283",height:"291"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://youtu.be/fbLgFrlTnGU?si=lOk5eb9Au4EJumjW&t=376"},"https://youtu.be/fbLgFrlTnGU?si=lOk5eb9Au4EJumjW&t=376")," (with modification)"),(0,s.kt)("p",null,"The process and objective of diffusion model is similar to ",(0,s.kt)("a",{parentName:"p",href:"/deep-learning/variational-autoencoder"},(0,s.kt)("strong",{parentName:"a"},"variational autoencoder (VAE)")),". In VAE, the encoder takes the input data and maps it to a lower-dimensional representation called the ",(0,s.kt)("strong",{parentName:"p"},"latent variables"),". This latent variables serves as a compressed representation that captures the essential information and underlying structure present in the input data. Latent variables will then be modeled in a probability distribution with some mean and variance, this is now called a ",(0,s.kt)("strong",{parentName:"p"},"latent space"),". The decoder sample from the latent space distribution, to generate new data samples. The objective is to approximate the true data distribution from the sampled distribution."),(0,s.kt)("p",null,'The similar objective can be applied to diffusion model, "Given transformed data, how to untransform it?". The primary aim of a diffusion model is to enhance the inference process, particularly by focusing on the reverse process that involves computing the preceding state of the Markov chain.'),(0,s.kt)("p",null,"The training objective can be summarized with the following formula (","[similar to loss in VAE]",") :"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Training objective formula",src:t(68867).Z,width:"795",height:"57"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://youtu.be/fbLgFrlTnGU?si=D6pH6EyDnxSz0j1P&t=458"},"https://youtu.be/fbLgFrlTnGU?si=D6pH6EyDnxSz0j1P&t=458")," (with modification)"),(0,s.kt)("p",null,"The ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"log"),(0,s.kt)("mo",{parentName:"mrow"},"\u2061"),(0,s.kt)("msub",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msub"},"p"),(0,s.kt)("mi",{parentName:"msub"},"\u03b8")),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mi",{parentName:"mrow"},"x"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\log p_{\\theta}(x)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mop"},"lo",(0,s.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3361em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.02778em"}},"\u03b8"))))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,s.kt)("span",{parentName:"span"})))))),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.kt)("span",{parentName:"span",className:"mclose"},")")))))," represent the likelihood of the original data, it must be greater or equal to the first term subtracted by second term. We represent the original data as a likelihood because our goal is to reconstruct it. By maximizing the likelihood, we aim to ensure that the reconstructed data closely resembles the original data."),(0,s.kt)("p",null,"The first term is the ",(0,s.kt)("strong",{parentName:"p"},"reconstruction term"),", which is the comparison of generated data and the original data. The second term is the ",(0,s.kt)("strong",{parentName:"p"},"KL divergence")," measures the difference of probability distribution between the target distribution (input data) and the learned distribution (generated distribuion)."),(0,s.kt)("h4",{id:"summary"},"Summary"),(0,s.kt)("p",null,"In summary, diffusion model starts with the forward process where we add Gaussian distribution noise to the image. After a bunch of step, we obtained a distribution approximately close to Gaussian distribution. In the reverse process, the model aims to remove the noise by inferring the previous distribution based on the current distribution, which is where the model learns. This process is often described as sampling because it entails generating samples from an approximated distribution obtained at the current step."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Diffusion process summary",src:t(5665).Z,width:"968",height:"279"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://scholar.harvard.edu/binxuw/classes/machine-learning-scratch/materials/foundation-diffusion-generative-models"},"https://scholar.harvard.edu/binxuw/classes/machine-learning-scratch/materials/foundation-diffusion-generative-models")),(0,s.kt)("p",null,"After training the model, to generate new data using a trained diffusion model, we start with a random noise sample and then perform the reverse diffusion steps."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"The process of generating image from a random noise, after model training",src:t(50106).Z,width:"608",height:"608"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://tree.rocks/make-diffusion-model-from-scratch-easy-way-to-implement-quick-diffusion-model-e60d18fd0f2e"},"https://tree.rocks/make-diffusion-model-from-scratch-easy-way-to-implement-quick-diffusion-model-e60d18fd0f2e")),(0,s.kt)("h3",{id:"denoising-diffusion-implicit-models-ddim"},"Denoising Diffusion Implicit Models (DDIM)"),(0,s.kt)("p",null,"The type of denoising diffusion model previously we talked about uses the probabilistic Markov chain as the framework, which can be slow during the sampling process in the reverse diffusion (there is some technique to skip the diffusion in forward process). Furthermore, DDPM require alot of forward diffusion step, which also increase the step in reverse process."),(0,s.kt)("p",null,"DDIM is a non-Markovian diffusion model, it removed the use of Markov chain. In Markov chain, during the reverse process, we assume that previous step only depends on current step (e.g. ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("msub",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msub"},"x"),(0,s.kt)("mn",{parentName:"msub"},"1"))),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x_1")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.5806em",verticalAlign:"-0.15em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,s.kt)("span",{parentName:"span"}))))))))))," depends on ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("msub",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msub"},"x"),(0,s.kt)("mn",{parentName:"msub"},"2"))),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x_2")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.5806em",verticalAlign:"-0.15em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,s.kt)("span",{parentName:"span"}))))))))))," = ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"q"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("msub",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msub"},"x"),(0,s.kt)("mn",{parentName:"msub"},"2")),(0,s.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,s.kt)("msub",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msub"},"x"),(0,s.kt)("mn",{parentName:"msub"},"1")),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"q(x_2|x_1)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"q"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,s.kt)("span",{parentName:"span"})))))),(0,s.kt)("span",{parentName:"span",className:"mord"},"\u2223"),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,s.kt)("span",{parentName:"span"})))))),(0,s.kt)("span",{parentName:"span",className:"mclose"},")"))))),")."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"DDIM without Markov chain",src:t(44560).Z,width:"924",height:"161"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://betterprogramming.pub/diffusion-models-ddpms-ddims-and-classifier-free-guidance-e07b297b2869"},"https://betterprogramming.pub/diffusion-models-ddpms-ddims-and-classifier-free-guidance-e07b297b2869")," (with modification)"),(0,s.kt)("p",null,"DDIM does not rely on a strict sequential dependence on previous steps. The elimination of the Markov chain allows for the consideration of multiple states beyond just the previous one in the reverse diffusion process. This transformation turns the process into an optimization problem, as the inclusion of more states introduces complex dependencies and variations in the data."),(0,s.kt)("p",null,"The goal is to find an optimal ",(0,s.kt)("strong",{parentName:"p"},"latent code"),", latent code is nothing but a set of parameters that captures the information required to generate a denoised or clean sample from a corrupted input. We adjust the parameters by minimizing the reconstruction loss between the generated sample and the corrupted input."),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"DDPM can be seen as a special case of DDIM, where we only consider the previous state for current state.",(0,s.kt)("br",{parentName:"p"}),"\n",'The term "implicit" in DDIM means that we do not explicitly try to denoise the image, instead we just find the best parameters that minimize the lost.')),(0,s.kt)("h3",{id:"conditional--unconditional-generation"},"Conditional & Unconditional Generation"),(0,s.kt)("p",null,"Diffusion model can also be integrated with a conditional prompt. The conditional prompt serves as a guide or constraint during the generation process, allowing for more controlled and targeted generation of data. The conditional prompt can be in the form of text, images, or any other type of input."),(0,s.kt)("h4",{id:"unconditional"},"Unconditional"),(0,s.kt)("p",null,"In the unconditional generation, we do not include any additional constraint. The model will start with a random noise sample and applies the reverse process to progressively reduce the noise and generate new data samples. The resulting data will be similar to the training data."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Unconditional generation",src:t(79064).Z,width:"628",height:"335"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://betterprogramming.pub/beginners-guide-to-unconditional-image-generation-using-diffusers-c703e675bda8"},"https://betterprogramming.pub/beginners-guide-to-unconditional-image-generation-using-diffusers-c703e675bda8")),(0,s.kt)("h4",{id:"conditional"},"Conditional"),(0,s.kt)("p",null,"In the conditional generation, the model is trained to learn the distribution of the training data given certain input conditions. During the generation process, the model takes the input conditions into account and adjusts the reverse process accordingly to generate samples that satisfy the given conditions."),(0,s.kt)("p",null,"The target data in reverse process which is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("msub",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msub"},"p"),(0,s.kt)("mi",{parentName:"msub"},"\u03b8")),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("msub",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msub"},"x"),(0,s.kt)("mn",{parentName:"msub"},"0")),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"p_{\\theta}(x_{0})")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3361em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.02778em"}},"\u03b8"))))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,s.kt)("span",{parentName:"span"})))))),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},"0"))))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,s.kt)("span",{parentName:"span"})))))),(0,s.kt)("span",{parentName:"span",className:"mclose"},")")))))," becomes ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("msub",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msub"},"p"),(0,s.kt)("mi",{parentName:"msub"},"\u03b8")),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("msub",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msub"},"x"),(0,s.kt)("mn",{parentName:"msub"},"0")),(0,s.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,s.kt)("mi",{parentName:"mrow"},"y"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"p_{\\theta}(x_{0}|y)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3361em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.02778em"}},"\u03b8"))))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,s.kt)("span",{parentName:"span"})))))),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},"0"))))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,s.kt)("span",{parentName:"span"})))))),(0,s.kt)("span",{parentName:"span",className:"mord"},"\u2223"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"y"),(0,s.kt)("span",{parentName:"span",className:"mclose"},")"))))),". The reverse step also takes the additional condition. The conditional generation can actually simplify the generation process by constraining the range of possible outputs."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Reverse step network",src:t(8430).Z,width:"251",height:"96"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://youtu.be/fbLgFrlTnGU?si=luVZ1O9GCWV8_2PH&t=714"},"https://youtu.be/fbLgFrlTnGU?si=luVZ1O9GCWV8_2PH&t=714")),(0,s.kt)("h2",{id:"score-based-diffusion-model-sbdm"},"Score-Based Diffusion Model (SBDM)"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Score-Based Diffusion Model (SBDM)")," is also known as ",(0,s.kt)("strong",{parentName:"p"},"Noise Conditional Score Network (NCSN)")," or ",(0,s.kt)("strong",{parentName:"p"},"Score-Matching with Langevin Dynamics (SMLD)"),". SBDM introduces the concept of ",(0,s.kt)("strong",{parentName:"p"},"score"),", mathematically, it is the gradient of the log-likelihood of the data distribution."),(0,s.kt)("h3",{id:"score-function"},"Score Function"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Score function",src:t(38439).Z,width:"284",height:"45"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://youtu.be/fbLgFrlTnGU?si=lEL8BBYdL0f1cetc&t=907"},"https://youtu.be/fbLgFrlTnGU?si=lEL8BBYdL0f1cetc&t=907")),(0,s.kt)("p",null,"A gradient with respect to some variables tells us the direction and magnitude of the steepest ascent or descent of a function at a particular point. Specifically in the context of SBDM, the gradient measures the direction in which the noise should be adjusted to move towards denoising or generating the desired output. It act as a guide for diffusion process by providing information on how to update the noise, but it does not provide a direct measure of similarity or dissimilarity."),(0,s.kt)("p",null,"The integration of score-based guidance with diffusion model fall between each diffusion step, score or gradient of the log-likelihood of the data distribution will be estimated with respect to the noise process. After that, the noise is updated in the direction of the estimated score."),(0,s.kt)("h2",{id:"continuous-diffusion-model"},"Continuous Diffusion Model"),(0,s.kt)("p",null,"Continuous diffusion model is a type of diffusion model that model the noise distribution of the data in a continuous manner. Instead of modeling how the noise distribution changes over discrete time step, SBDM instead treat the distribution as a continous process that evolves over a continuous time."),(0,s.kt)("p",null,"The diffusion process is modeled using ",(0,s.kt)("strong",{parentName:"p"},"stochastic differential equations (SDEs)"),". SDEs are mathematical equation that describe how a system transitions from one state to another, which is affected by deterministic and random factor."),(0,s.kt)("p",null,"The score-based diffusion model can be combined together with SDE-based modeling. The SDE-based deterministic and random factor terms can be incorporated into the score-based model to guide the denoising and transformation steps of the diffusion process."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Continous diffusion model using SDE",src:t(62846).Z,width:"639",height:"276"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://theaisummer.com/diffusion-models/#score-based-generative-modeling-through-stochastic-differential-equations-sde"},"https://theaisummer.com/diffusion-models/#score-based-generative-modeling-through-stochastic-differential-equations-sde")),(0,s.kt)("h3",{id:"sampler"},"Sampler"),(0,s.kt)("p",null,"Continous diffusion model uses SDE to model the system, in order to know the system state over time and sample from it to actually generates data, the SDE needs to be solved."),(0,s.kt)("p",null,"While solving an SDE, we do not find the exact analytical solution, we instead approximate the solution (also called numerical integration). Some of the methods are Euler\u2013Maruyama method, Heun's method, and linear multistep methods, these are also called ",(0,s.kt)("strong",{parentName:"p"},"sampler"),"."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Sampler that gradually reduce noises",src:t(5847).Z,width:"512",height:"512"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://stable-diffusion-art.com/samplers/"},"https://stable-diffusion-art.com/samplers/")," (sampler that gradually reduce the noise)"),(0,s.kt)("h4",{id:"ancestral-sampler"},"Ancestral Sampler"),(0,s.kt)("p",null,"There is another type of sampler called ",(0,s.kt)("strong",{parentName:"p"},"ancestral sampler"),", these sampler introduce randomness to the sampling process. At each sampling step, they add noise to the image to introduce variations in the generated images. This makes the image produced may not reach a consistent and reproducible state, the image can turn differently at each step."),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"center"},"Ancestral sampler"),(0,s.kt)("th",{parentName:"tr",align:"center"},"Normal sampler"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"center"},(0,s.kt)("img",{alt:"Ancestral sampler",src:t(56681).Z,width:"512",height:"512"})),(0,s.kt)("td",{parentName:"tr",align:"center"},(0,s.kt)("img",{alt:"Normal sampler",src:t(54127).Z,width:"512",height:"512"}))))),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://stable-diffusion-art.com/samplers/"},"https://stable-diffusion-art.com/samplers/")),(0,s.kt)("h2",{id:"latent-diffusion-model-ldm"},"Latent Diffusion Model (LDM)"),(0,s.kt)("p",null,"In diffusion model, we are approximating what an unnoised image will look like from a random noised image. In other word, we are approximating the probability distribution of a target image from a simple base distribution. This makes diffusion model is often called a general method to model a probability distribution."),(0,s.kt)("p",null,"An encoder-decoder pair is a type of network that consist of two component. The encoder, serve as the one that takes input and transform it into ",(0,s.kt)("strong",{parentName:"p"},"latent variables")," or lower-dimensional representation of the input data. The other component, decoder, will take the output of encoder and do the reverse process. An example of encoder-decoder pair are ",(0,s.kt)("a",{parentName:"p",href:"/deep-learning/autoencoder"},"autoencoder")," and ",(0,s.kt)("a",{parentName:"p",href:"/deep-learning/variational-autoencoder"},"Variational autoencoder (VAE)"),", which model the latent variables in probability distribution, called ",(0,s.kt)("strong",{parentName:"p"},"latent space"),"."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Latent diffusion model")," or ",(0,s.kt)("strong",{parentName:"p"},"LDM")," is a type of diffusion model combined with an encoder-decoder pair (typically a VAE). The idea of using diffusion model with an encoder-decoder pair is because the encoder outputs a probability distribution which we can use as the input for diffusion model."),(0,s.kt)("p",null,"Instead of forward diffusing a raw image and then do the reverse process, LDM instead takes the input from encoder and model the probability distribution. To actually generate image, we can sample from the output of the diffusion model and use the decoder to decode it back to image. By using latent space as the input, we can reduce the dimensionality of the input for diffusion process, which will save alot of computation resources."),(0,s.kt)("p",null,"LDM can also be integrated with additional condition such as text, image, or any other meaningful representation. This integration can leverage technique like ",(0,s.kt)("a",{parentName:"p",href:"/deep-learning/transformers/transformers-architecture"},"cross-attention"),", which is also used in the transformers architecture. First, the encoder encodes the data into the latent space, followed by the forward diffusion process. The conditional input, typically the encoded representation of the original input, is concatenated together with the output of forward diffusion process. Subsequently, the cross-attention mechanism is incorporated to guide the reverse diffusion or denoising process. Once the reverse diffusion is completed, we can sample the output and fed it into the decoder."),(0,s.kt)("h3",{id:"stable-diffusion"},"Stable Diffusion"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Stable Diffusion")," is a deep learning model based on ",(0,s.kt)("a",{parentName:"p",href:"/deep-learning/diffusion-model"},"diffusion model"),", specifically, it's an open source implementation of ",(0,s.kt)("a",{parentName:"p",href:"/deep-learning/diffusion-model#latent-diffusion-model-ldm"},(0,s.kt)("strong",{parentName:"a"},"latent diffusion model (LDM)")),". It is typically used to generate image conditioned on text or image, inpainting, outpainting, super-resolution, and etc."),(0,s.kt)("h4",{id:"architecture"},"Architecture"),(0,s.kt)("p",null,"Stable diffusion is based on Latent Diffusion Model (LDM), which uses ",(0,s.kt)("a",{parentName:"p",href:"/deep-learning/variational-autoencoder"},"variational autoencoder (VAE)")," as both the encoder and decoder. The diffusion process takes place within the latent space generated by the encoder."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"LDM or stable diffusion architecture",src:t(76777).Z,width:"725",height:"357"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://towardsdatascience.com/stable-diffusion-best-open-source-version-of-dall-e-2-ebcdf1cb64bc"},"https://towardsdatascience.com/stable-diffusion-best-open-source-version-of-dall-e-2-ebcdf1cb64bc")," (stable diffusion or LDM architecture)"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Image Encoding")," : An image is provided as the input, which is passed through the encoder to transform it into a representation in the latent space. Transforming it into latent space allows for smaller dimension which can significantly reduce the computational resources.")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Diffusion Process")," : Diffusion process which consist of forward diffusion that adds noise gradually and the reverse diffusion process which removes noise gradually. The reverse diffusion process is implemented using a neural network, specifically a denoising ",(0,s.kt)("a",{parentName:"p",href:"/deep-learning/u-net"},"U-Net"),"."),(0,s.kt)("p",{parentName:"li"},"The U-Net predicts what is the denoised image in the previous time step, given a noised image in the current time step. However, rather than directly predicting the denoised image, the U-Net predicts the noise present in the input image. Subsequently, this predicted noise is subtracted from the noisy input image to obtain the actual denoised image."),(0,s.kt)("p",{parentName:"li"},"To ensure a gradual reduction of noise, the predicted noise is multiplied by a fraction (",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow",mathvariant:"script"},"E")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{E}")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6833em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.08944em"}},"E"))))),") before subtracting it from the input image. This gradual process enhances stability and reliability while also accommodating the injection of conditional information, such as a text prompt."),(0,s.kt)("p",{parentName:"li"},(0,s.kt)("img",{alt:"Forward diffusion and reverse diffusion using U-Net",src:t(38933).Z,width:"1264",height:"412"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://medium.com/@steinsfu/diffusion-model-clearly-explained-cd331bd41166"},"https://medium.com/@steinsfu/diffusion-model-clearly-explained-cd331bd41166"),", ",(0,s.kt)("a",{parentName:"p",href:"https://youtu.be/J87hffSMB60?si=_iCGv-rnh_sXt_dL&t=352"},"https://youtu.be/J87hffSMB60?si=_iCGv-rnh_sXt_dL&t=352")," (with modification)")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Conditioning")," : The model also takes a conditional input such as text, it will be encoded or converted into lower-dimensional representation, this can be done using ",(0,s.kt)("a",{parentName:"p",href:"/deep-learning/transformers/transformers-architecture#encoder"},"transformers encoders")," or ",(0,s.kt)("a",{parentName:"p",href:"#contrastive-language-image-pre-training-clip"},"CLIP text encoder"),"."),(0,s.kt)("p",{parentName:"li"},"The integration with conditional input is incorporated in two ways :"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"The encoded conditioning will be concatenated with the output of forward diffusion which is used for the input of reverse diffusion process."),(0,s.kt)("li",{parentName:"ul"},"We will also utilize the cross-attention mechanism during the reverse diffusion process in U-Net. Inside the attention mechanism, the encoded conditioning act as the query vector.")),(0,s.kt)("p",{parentName:"li"},(0,s.kt)("img",{alt:"Conditioning process in the stable diffusion architecture",src:t(94553).Z,width:"583",height:"285"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://towardsdatascience.com/stable-diffusion-best-open-source-version-of-dall-e-2-ebcdf1cb64bc"},"https://towardsdatascience.com/stable-diffusion-best-open-source-version-of-dall-e-2-ebcdf1cb64bc")," (with modification)")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Output & Decoder Generation")," : Once the reverse process is completed and a refined latent space representation is obtained, it is fed into a decoder that performs an upscaling operation on the image. However, the resulting upscaled image may not have the highest resolution since the input is typically a low-resolution image to reduce computational costs. To address this, another diffusion model specialized for super-resolution tasks can be used."),(0,s.kt)("p",{parentName:"li"},(0,s.kt)("img",{alt:"The output of stable diffusion with additional super-resolution",src:t(20113).Z,width:"627",height:"283"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://youtu.be/J87hffSMB60?si=Y01BDAdH9hNa-dqQ&t=486"},"https://youtu.be/J87hffSMB60?si=Y01BDAdH9hNa-dqQ&t=486")))),(0,s.kt)("p",null,"After completing the training process, in the actual image generation, we have the option to generate new images by inputting only text, or we can choose to input both text and an image simultaneously, which will modify the input image based on the text we provide."),(0,s.kt)("h2",{id:"contrastive-language-image-pre-training-clip"},"Contrastive Language-Image Pre-Training (CLIP)"),(0,s.kt)("p",null,"CLIP is a model that combines vision and language understanding, it is a model that learns the similarity between image and text. CLIP takes an input image with its corresponding text description, they will be encoded. In other words, the higher-dimensional data will be converted into a lower-dimensional representation. The place where all the encoded input is combined is called the ",(0,s.kt)("strong",{parentName:"p"},"embedding space"),"."),(0,s.kt)("p",null,"During training, CLIP will learn how to map each image and text into the shared embedding space. The objective is to group the pairs of encoded representation (image and text) together, while pushing the dissimilar pairs apart."),(0,s.kt)("p",null,"The loss function in CLIP consists of two main components: the ",(0,s.kt)("strong",{parentName:"p"},"image-text similarity loss")," and the ",(0,s.kt)("strong",{parentName:"p"},"contrastive loss"),". Both of the loss is calculated in the embedding space, the similarity metrics such as cosine similarity can be used. Similarity loss is maximized to encourage the maximum similarity score between correct pair of image and text. On the other hand, the contrastive loss is minimized to encourage a minimum similarity score between mismatched pairs of image and text."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Joint embedding space",src:t(17226).Z,width:"531",height:"265"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://blog.dataiku.com/leveraging-joint-text-image-models-to-search-and-classify-images"},"https://blog.dataiku.com/leveraging-joint-text-image-models-to-search-and-classify-images")),(0,s.kt)("p",null,"The encoding process, involves the use of image and text encoder. We can choose variety of model for text and image encoding, for example, we can use ",(0,s.kt)("a",{parentName:"p",href:"/deep-learning/transformers/transformers-architecture#encoder"},"transformers encoder")," for text encoding and ",(0,s.kt)("a",{parentName:"p",href:"/deep-learning/cnn"},"CNN")," (without its classifier) for image encoding."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"CLIP",src:t(64798).Z,width:"1090",height:"394"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://towardsdatascience.com/simple-implementation-of-openai-clip-model-a-tutorial-ace6ff01d9f2?gi=de7f9822c57a"},"https://towardsdatascience.com/simple-implementation-of-openai-clip-model-a-tutorial-ace6ff01d9f2?gi=de7f9822c57a")),(0,s.kt)("p",null,"After training, CLIP can be used for variety of tasks including image classification, image retrieval, text-to-image generation."),(0,s.kt)("p",null,"For example in an image classification tasks, an image is fed into the encoder, the encoder encodes the image and generates the encoded representation. In the embedding space, the model will find which label is the most similar with the encoded representation of the image. The highest similarity is considered the predicted class label for the image."),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"CLIP objective is used in text-to-image models model like ",(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/DALL-E"},"DALL-E"),".")))}d.isMDXComponent=!0},56681:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/ancestral-sampler-7a2b65e1513263ee78614e60f7cafaf7.gif"},81777:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/approach-identity-matrix-2336ab708059a75b31a755e0dad9c4f5.png"},64798:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/clip-3b88f43c06e497a38332e6d74c2131c9.png"},94553:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/conditioning-d69618aaa8f5b75166cfbae6fc31ae58.png"},62846:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/continous-sde-3417be96666dc01780ef8757df1a7e00.png"},44560:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/ddim-270de147713f25c4160c0427e93dbd96.png"},38933:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/diffusion-process-29754ac9266f3203420340ab9762dfc9.png"},5665:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/diffusion-summary-ce581a3d73b6962da4914a730053f3b6.png"},80186:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/forward-process-notation-f53c42c883304c68a3667a76fc7b8573.png"},90543:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/gaussian-distribution-noise-a0d40f8ab3d16bcd3d56e322cff74168.png"},43061:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/gaussian-distribution-9569cf4b790dadd74f4101bcfe2bae0b.png"},50106:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/generation-process-268c9bb8f2a23fbea3ce8844804fbaf9.gif"},17226:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/joint-embedding-space-3be368c34ec2bd51145600e5b2bf1b9b.png"},54127:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/normal-sampler-f39c18a18adc1d2b71984ec059492c60.gif"},98540:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/objective-57e94625624526004f3b851095df306f.png"},20113:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/output-c6ffe3f4277bc5f7893ca2ec2de8deea.png"},8960:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/reverse-process-implementation-c4884f9c757dba8b0d036e36237361c9.png"},73497:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/reverse-process-notation-fa196f341c9afbfd2b8202827e0b3ec0.png"},8430:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/reverse-step-network-c1bb16987ba49e214988fa131a44268a.png"},5847:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/sampler-02eb7fd903abc65e796354f63ca620eb.gif"},38439:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/score-function-f623c8ae9a665225f7ac00e05f949146.png"},76777:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/stable-diffusion-architecture-d8858e95aa717952f8c7e30455abe2df.png"},68867:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/training-formula-17beda6f8e60e6a73cc78b5ecc67d695.png"},79064:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/unconditional-generation-58bbcbb30fb288cd4bde16f7a76b2511.png"}}]);