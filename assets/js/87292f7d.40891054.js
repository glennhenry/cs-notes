"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[817],{97e3:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var t=s(85893),i=s(11151);const r={slug:"/computer-organization-and-architecture/assembly-language",id:"assembly-language",title:"Assembly Language",description:"Assembly Language"},a=void 0,o={id:"computer-organization-and-architecture/assembly-language/assembly-language",title:"Assembly Language",description:"Assembly Language",source:"@site/docs/computer-organization-and-architecture/08-assembly-language/assembly-language.md",sourceDirName:"computer-organization-and-architecture/08-assembly-language",slug:"/computer-organization-and-architecture/assembly-language",permalink:"/cs-notes/computer-organization-and-architecture/assembly-language",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/computer-organization-and-architecture/08-assembly-language/assembly-language.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1708339409,formattedLastUpdatedAt:"Feb 19, 2024",frontMatter:{slug:"/computer-organization-and-architecture/assembly-language",id:"assembly-language",title:"Assembly Language",description:"Assembly Language"},sidebar:"sidebar",previous:{title:"Input/Output",permalink:"/cs-notes/computer-organization-and-architecture/input-output"},next:{title:"Von Neumann",permalink:"/cs-notes/computer-organization-and-architecture/von-neumann"}},l={},c=[{value:"Translatation to Machine Code",id:"translatation-to-machine-code",level:3},{value:"Instruction",id:"instruction",level:3},{value:"Syntax &amp; Instructions",id:"syntax--instructions",level:3},{value:"Example",id:"example",level:4}];function d(e){const n={a:"a",br:"br",code:"code",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Main Source :"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Assembly_language",children:"Assembly language - Wikipedia"})})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"https://youtu.be/4gwYkEK0gOk?si=faihHjHQNrGx28NV",children:"Assembly Language in 100 Seconds - Fireship"})})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Assembly Language (asm)"})," is a low-level programming language that is between the machine code (binary instructions understood by the computer's hardware) and high-level programming languages (which is readable by humans). asm is a human-readable representation of machine code instructions, programmers can see the code that interacts directly with the computer's hardware."]}),"\n",(0,t.jsx)(n.p,{children:"Due to the direct interaction with the hardware, asm is specific to a particular computer architecture or processor family. Different processors have their own assembly languages, tailored to their instruction sets, registers, and addressing modes. Therefore, code written in assembly language is not portable across different hardware platforms without modification."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.img,{alt:"ASM",src:s(14827).Z+"",width:"682",height:"387"}),(0,t.jsx)(n.br,{}),"\n","Source : ",(0,t.jsx)(n.a,{href:"https://www.investopedia.com/terms/a/assembly-language.asp",children:"https://www.investopedia.com/terms/a/assembly-language.asp"})]}),"\n",(0,t.jsx)(n.h3,{id:"translatation-to-machine-code",children:"Translatation to Machine Code"}),"\n",(0,t.jsx)(n.p,{children:"Assembly language uses mnemonic instructions, which are short and easy to remember symbol that represent a single instruction in the machine."}),"\n",(0,t.jsxs)(n.p,{children:["Once assembly language is written, it needs to be translated into machine code, this process is known as ",(0,t.jsx)(n.strong,{children:"assembly"})," or ",(0,t.jsx)(n.strong,{children:"assembling"}),". An assembler is used to convert the mnemonic instructions and symbolic names into the binary instructions understood by the target processor. The assembler looks up on the instruction table how the mnemonic instructions map to the binary codes. It will also perform other necesarry steps, such as, calculating memory addresses, combining the instruction with the operands, etc."]}),"\n",(0,t.jsxs)(n.p,{children:["Assembly language also provide a way for programmers to define instruction that are not executed by the processor but provide instructions to the assembler, they are called ",(0,t.jsx)(n.strong,{children:"directives"}),". They help programmer to organize and control the assembly code. Also, in some cases, assembly programs may require multiple source files or external libraries that need to be linked together. This process is called ",(0,t.jsx)(n.strong,{children:"linking"}),", it is necesarry to resolve references to symbols and ensures that all required components are properly integrated."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.img,{alt:"Translation or assembly process",src:s(32815).Z+"",width:"591",height:"504"}),(0,t.jsx)(n.br,{}),"\n","Source : ",(0,t.jsx)(n.a,{href:"https://users.ece.utexas.edu/~valvano/assmbly/index.html",children:"https://users.ece.utexas.edu/~valvano/assmbly/index.html"})]}),"\n",(0,t.jsx)(n.h3,{id:"instruction",children:"Instruction"}),"\n",(0,t.jsx)(n.p,{children:"The commons types of instruction in assembly language :"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Movement Instructions"})," : These instructions move or copy data between registers, memory, and I/O devices."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Arithmetic and Logic Instructions"})," : These instructions perform arithmetic operations such as addition, subtraction, and multiplication; and logical operations such as bitwise AND, OR, NOT, and XOR on data."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Control Flow Instructions"})," : These instructions control the flow of execution within a program. Examples include changing program flow with or without a condition, or jumping to specific part of program after a function finishes its execution."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Input/Output Instructions"})," : These instructions facilitate communication between the processor and I/O devices."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stack and Memory Management Instructions"})," : These instructions manipulate the stack (adding or removing values) and manage memory operations such as allocating and deallocating memory."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"syntax--instructions",children:"Syntax & Instructions"}),"\n",(0,t.jsx)(n.p,{children:"Assembly code is typically written line by line, with each line representing a single instruction. Assembly code is divided into several section, there are section for code, which contains the actual logic of the program, section to declare variable and constants, and defining linker."}),"\n",(0,t.jsx)(n.p,{children:"There are many instruction keyword in asm :"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Instructions"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"MOV (Move)"})," : Copies the value from one location to another. It is used to transfer data between registers, memory locations, and immediate values."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ADD (Addition)"})," : Performs addition between two values and stores the result."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SUB (Subtraction)"})," : Performs subtraction between two values and stores the result."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"MUL (Multiplication)"})," : Performs multiplication between two values and stores the result."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"DIV (Division)"})," : Performs division between two values and stores the quotient."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"INC (Increment)"})," : Increments the value of a register or memory location by 1."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"DEC (Decrement)"})," : Decrements the value of a register or memory location by 1."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Bitwise Operations"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"AND (Bitwise AND)"})," : Performs a bitwise AND operation between two values."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"OR (Bitwise OR)"})," : Performs a bitwise OR operation between two values."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"XOR (Bitwise XOR)"})," : Performs a bitwise XOR operation between two values."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Registers"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"AX, BX, CX, DX, EBX (general-purpose registers)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"AL (accumulator low)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"EAX (extended accumulator)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"SP (stack pointer)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"BP (base pointer)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"SI (source index)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"DI (destination index)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"IP (instruction pointer)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"FLAGS (flags register)"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Control Flow"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CMP (Compare)"})," : Compares two values and sets the flags based on the result."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"JMP (Jump)"})," : Transfers program control to a specified location in the code."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"JZ (Jump if Zero)"})," : Jumps to a specified location if the zero flag is set."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"JNZ (Jump if Not Zero)"})," : Jumps to a specified location if the zero flag is not - set."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"JE (Jump if Equal)"})," : Jumps to a specified location if the equal flag is set."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"JNE (Jump if Not Equal)"})," : Jumps to a specified location if the equal flag is not - set."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CALL (Call)"})," : Calls a subroutine or function at a specified location."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"RET (Return)"})," : Returns from a subroutine to the calling code."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Stack Operations"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"PUSH (Push)"})," : Pushes a value onto the top of the stack."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"POP (Pop)"})," : Removes a value from the top of the stack."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Directives"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"DB (define byte)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"DW (define word)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"DD (define doubleword)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"DQ (define quadword)"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Data Types"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"BYTE"})," : A single byte of data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"WORD"})," : 16-bit value or two bytes of data."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"DWORD"})," : 32-bit value or four bytes of data."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"QWORD"})," : 64-bit value or eight bytes of data."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,t.jsx)(n.p,{children:"Example of asm code for adding two number"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-assembly",children:"section .data\n    num1 db 5     ; Define a variable called num1, which is a byte and has the value of 5\n    num2 db 3     ; Define a variable called num2, which is a byte and has the value of 3\n\nsection .text\n    global _start\n_start:\n    ; Load the first number into a register\n    mov al, [num1]\n\n    ; Add the second number to the first number\n    add al, [num2]\n\n    ; Store the result in another variable\n    mov [result], al\n\n    ; Exit the program\n    mov eax, 1       ; System call number for exit\n    xor ebx, ebx     ; Exit status code (0 for success)\n    int 0x80         ; Perform the system call\n\nsection .data\n    result db 0      ; Variable to store the result\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The syntax is typically ",(0,t.jsx)(n.code,{children:"<instruction> <operand1> <operand2>"}),", where operand can be a register, which is specified by its name, or immediate value."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"section .data"})," is a section directive to define and initialize data such as variables, constants, and strings. The ",(0,t.jsx)(n.code,{children:"section .text"})," is the section for program's executable instructions. ",(0,t.jsx)(n.code,{children:"_start"})," is a label that marks the entry point of the program."]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},14827:(e,n,s)=>{s.d(n,{Z:()=>t});const t=s.p+"assets/images/asm-ad8702d820278bb34093ec5aeeb249b0.png"},32815:(e,n,s)=>{s.d(n,{Z:()=>t});const t=s.p+"assets/images/translation-b9489e54ff617de1e2201593a4cc07ac.png"},11151:(e,n,s)=>{s.d(n,{Z:()=>o,a:()=>a});var t=s(67294);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);