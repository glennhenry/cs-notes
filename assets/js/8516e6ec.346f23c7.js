"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[1673],{90754:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var s=n(85893),i=n(11151);const r={slug:"/software-engineering/software-process",id:"software-process",title:"Software Process",description:"Software Process"},a=void 0,o={id:"software-engineering/software-process/software-process",title:"Software Process",description:"Software Process",source:"@site/docs/software-engineering/01-software-process/software-process.md",sourceDirName:"software-engineering/01-software-process",slug:"/software-engineering/software-process",permalink:"/cs-notes/software-engineering/software-process",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/software-engineering/01-software-process/software-process.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1709979564,formattedLastUpdatedAt:"Mar 9, 2024",frontMatter:{slug:"/software-engineering/software-process",id:"software-process",title:"Software Process",description:"Software Process"},sidebar:"sidebar",previous:{title:"Software Engineering",permalink:"/cs-notes/software-engineering"},next:{title:"Software Principles",permalink:"/cs-notes/software-engineering/software-principles"}},l={},c=[{value:"Prototyping",id:"prototyping",level:3},{value:"Software Methodologies",id:"software-methodologies",level:3},{value:"Agile",id:"agile",level:4},{value:"Waterfall",id:"waterfall",level:4},{value:"Spiral",id:"spiral",level:4},{value:"Software Planning",id:"software-planning",level:3}];function d(e){const t={a:"a",br:"br",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Main Source :"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Software_development_process",children:"Software development process - Wikipedia"})})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Agile_software_development",children:"Agile software development - Wikipedia"})})}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Software process"})," is a series of activities or tasks that is followed to create a software. The general process includes :"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Gathering information on the requirement of the software."}),"\n",(0,s.jsx)(t.li,{children:"Design the architecture, component, and interface. Architecture represents the overall design of software, component design involve designing how will a component operate, and interface design specify how each component interact with each other."}),"\n",(0,s.jsx)(t.li,{children:"Implement the architecture by writing the actual code, following specific coding standards."}),"\n",(0,s.jsx)(t.li,{children:"Testing and verifying that software runs correctly. Broadly speaking, testing can be categorized into three types : individual component testing, system testing where all components are tested together, and a final test to determine if the software meets the specified requirements."}),"\n",(0,s.jsx)(t.li,{children:"Installing, setting up, and configuring the software on targeted hardware."}),"\n",(0,s.jsx)(t.li,{children:"Update the software by introducing new feature or fixing bug based on user feedbacks."}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"prototyping",children:"Prototyping"}),"\n",(0,s.jsx)(t.p,{children:"A prototype is an early sample of a product, specifically designed to test or obtain feedback. Prototyping a software means developing a functioning model of a software system to demonstrate the system's potential functionality."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Few examples of an app with prototyped user interface",src:n(24855).Z+"",width:"638",height:"349"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://smartlogic.io/blog/startup-advice-dont-waste-money-on-an-expensive-prototype/",children:"https://smartlogic.io/blog/startup-advice-dont-waste-money-on-an-expensive-prototype/"})]}),"\n",(0,s.jsx)(t.p,{children:"For example, when making an app, the first priority might be on ensuring the primary functionality of the application to functions properly. In a social media app, we can develop basic user interface or use fake data and profile pictures rather than investing significant effort in creating a visually appealing user interface. The primary focus of such a prototype is to demonstrate the core features and interactions of the app rather than the aesthetics."}),"\n",(0,s.jsx)(t.p,{children:"Prototyping can be beneficial in software development process, as it can save time and effort in gathering and curating real user data for the prototype."}),"\n",(0,s.jsx)(t.h3,{id:"software-methodologies",children:"Software Methodologies"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Software Methodologies"})," are specific approaches or frameworks that defines software process."]}),"\n",(0,s.jsx)(t.h4,{id:"agile",children:"Agile"}),"\n",(0,s.jsx)(t.p,{children:"Agile is a group or framework of iterative approach to software development that emphasizes collaboration, adaptability, and continuous improvement."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Agile development",src:n(33314).Z+"",width:"258",height:"257"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://medium.com/@temitopeolanipekun12/what-is-agile-methodology-713c9e29361a",children:"https://medium.com/@temitopeolanipekun12/what-is-agile-methodology-713c9e29361a"})]}),"\n",(0,s.jsxs)(t.p,{children:["Agile projects are divided into small, time-boxed iterations called ",(0,s.jsx)(t.strong,{children:"sprints"}),". Each sprint typically lasts from one to four weeks and results in a potentially shippable increment of the software. This iterative approach allows for frequent feedback and the ability to adapt and adjust based on changing requirements."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Planning"})," : Define the overall project goals, scope, and initial requirements. In agile, we can list the functionality requirement of a product based on their priority. This is called ",(0,s.jsx)(t.strong,{children:"product backlogs"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Design"})," : Design decisions are made during each sprint or iteration throughout development, rather than developing all design elements upfront. This allows for flexibility and responsiveness to changes and feedback."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Development"})," : The agile team select a set of user stories from the product backlog and develop the corresponding functionality."]}),"\n",(0,s.jsxs)(t.p,{children:["A ",(0,s.jsx)(t.strong,{children:"user story"}),' is a way to describe how should a software function in the perspective of user. For example, a user story for an e-commerce website could be : "As a customer, I want to be able to add items to my shopping cart, so that I can easily keep track of the products I want to purchase."',(0,s.jsx)(t.br,{}),"\n","This is not an actual feedback from user, but rather a simple and concise way to describe the desired functionality or behavior of the software system."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Testing"})," : ",(0,s.jsx)(t.a,{href:"/software-engineering/software-testing",children:"Software testing"})," is performed in each sprint or iteration, this is called ",(0,s.jsx)(t.strong,{children:"continuous testing"}),". User stories in agile are typically accompanied by acceptance criteria. ",(0,s.jsx)(t.strong,{children:"Acceptance testing"})," is a type of testing to determine whether a software system meets the specified acceptance criteria."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Release"})," : Agile promotes frequent and incremental releases. At the end of each sprint, a potentially shippable product increment is produced."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Feedback"})," : Feedback is collected from stakeholders, users, and customers during various stages of the process, including sprint reviews and demonstrations. Feedback is used to validate assumptions, refine requirements, and guide future iterations."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"There are several examples of agile development :"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Scrum"})," : Scrum is the implementation of agile methodology that focuses on incremental changes. It involves previously talked elements like product backlog, sprint, and ",(0,s.jsx)(t.strong,{children:"daily scrum"}),". Daily scrum is a short daily meeting where the development team synchronizes and plans their work. It is an opportunity to discuss progress, identify obstacles or blockers, and plan for the day's activities."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Extreme Programming (XP)"})," : XP is an agile methodology that emphasizes close collaboration between the development team and the customer or product owner. It promotes frequent and small releases of software. One common practice in XP is ",(0,s.jsx)(t.strong,{children:"pair programming"}),", in which two developers working together on the same codebase, with one actively writing code and the other reviewing and providing immediate feedback. This promotes knowledge sharing and reduces defects."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"XP diagram",src:n(64002).Z+"",width:"289",height:"286"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Extreme_programming",children:"https://en.wikipedia.org/wiki/Extreme_programming"})]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Lean"})," : Lean is a principles and practices derived from Lean manufacturing, which focus on maximizing customer value while minimizing waste. Customer value is the perceived worth or benefit that a customer receives from a product. In software, maximizing customer value could be prioritizing features and functionalities that provide the most value to the end-users."]}),"\n",(0,s.jsx)(t.p,{children:"On the other hand, waste refers to any activity or process that does not add value to the software product. These can be unnecessary documentation, waiting time, defects, and overproduction of features that occurs during software engineering process."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Kanban"}),' : Kanban is an agile methodology that helps to manage the development of software by visualizing it in a Kanban board. Kanban board represent a workflow of progress of work items. The board consists of columns that represent different stages of the development process, such as "To Do," "In Progress," "Testing," and "Done." Work items, which represent the actual work represented by cards or sticky notes, are moved across the board as they progress through the workflow.']}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Kanban board",src:n(86314).Z+"",width:"983",height:"474"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://www.geeksforgeeks.org/kanban-agile-methodology/",children:"https://www.geeksforgeeks.org/kanban-agile-methodology/"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h4,{id:"waterfall",children:"Waterfall"}),"\n",(0,s.jsx)(t.p,{children:'Waterfall model is a sequential development approach, where each phase of the project is completed before moving on to the next one. The methodology is called "waterfall" because progress flows steadily downwards, similar to a waterfall.'}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Waterfall methodology diagram",src:n(86116).Z+"",width:"462",height:"347"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://business.adobe.com/blog/basics/waterfall",children:"https://business.adobe.com/blog/basics/waterfall"})]}),"\n",(0,s.jsx)(t.p,{children:"It starts from identifying what the requirements are, designing the system, implementing the system in code, verify and test the software, and deploy as well as maintain the software."}),"\n",(0,s.jsx)(t.h4,{id:"spiral",children:"Spiral"}),"\n",(0,s.jsx)(t.p,{children:"Spiral is an iterative software development methodology that combines elements of both waterfall and iterative approaches. A complete iteration of the software development process is represented as a cycle of the spiral."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Spiral model",src:n(65029).Z+"",width:"692",height:"555"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Software_development_process#/media/File:Spiral_model_(Boehm,_1988).svg",children:"https://en.wikipedia.org/wiki/Software_development_process#/media/File:Spiral_model_(Boehm,_1988).svg"})]}),"\n",(0,s.jsx)(t.p,{children:"A cycle is divided into four phases :"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Planning"})," : This phase involves gathering requirements, defining the project objectives, and constraints."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Risk Analysis"})," : In this phase, risks are assessed and analyzed. The identified risks are evaluated based on their potential impact on the project and the likelihood of occurrence. Strategies and mitigation plans are developed to address the identified risks."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Development"})," : Focuses on the actual development and implementation of the software. It includes activities such as designing the system architecture, developing the software components, and thorough testing to ensure quality and functionality."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Evaluation"})," : The evaluation phase involves reviewing and assessing the progress made. Based on this evaluation, decisions are made regarding the next steps, such as making adjustments."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"software-planning",children:"Software Planning"}),"\n",(0,s.jsx)(t.p,{children:"Making a software project can be overwhelming if we don't have the plan. It is easy to be distracted by the amount of work we have to do. Here are some tips to plan and build a program :"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"/software-engineering/system-design",children:"System Design"})," : System design is the process of designing architecture and all related component to build a software system. It is a very good practice to always sketch the system first, at least get a high-level view on how the system will look like."]}),"\n",(0,s.jsx)(t.p,{children:"A system design involves :"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Requirements Gathering"})," : To know what should we build, we need to know what our requirements are. Requirement can be categorized into two, functional and non-functional. Functional requirements are the specific features and functionalities that the software should provide. Non-functional requirements, on the other hand, specify the qualities or characteristics of the software, such as performance, security, and usability."]}),"\n",(0,s.jsx)(t.p,{children:"The functional requirements for a streaming platform include enabling users to broadcast videos to the server and allowing other users to receive the broadcasts to watch them. The non-functional requirement would be designing the app to be scalable with thousands of traffic around the world. The app should be able to handle such workload and keep functioning."}),"\n",(0,s.jsx)(t.p,{children:"In this step we may also choose our tech stack, including what programming languages, library, framework, or cloud services that suit our needs."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"High-level Design"})," : After knowing what is required to build the software, we can start designing the system in high-level. This involves making a design that outlines the architecture and structure of the software. We could make ",(0,s.jsx)(t.a,{href:"/software-engineering/diagrams",children:"various diagram"})," that represent how each component interact or determining how should we store the data."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"More Detailed Design"})," : Then, we can create a more detailed design that provides a deeper understanding of the internal components, modules, and implementation details of the software application. We can imagine how would the component works or what algorithm it would use."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Core Design"})," : Core design focuses on designing the central and critical components of the software system. In the case of creating a video streaming app, we can focus on designing how users can broadcast their videos, how the server receives them, and how it simultaneously sends the content to all viewers. We can ignore other non-essential components such as user authentication."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Scale"})," : After everything is evaluated, we can now focus on how to scale and maintain the system. We should identify which component would most likely be causing performance bottlenecks or limiting the system's scalability. Let's say our streaming app is targeting the international market, which mean anyone around the world would use it. We can choose to distribute server instances, so that users can have low-latency access to the streaming content, regardless of their geographical location."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Start Development"})," : Begin the actual development by following the design."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Incremental & MVP"})," : It is a good practice to build the software incrementally, meaning that we develop the software in small increments, each providing a valuable and functional piece of the system. We start breaking down the system into smaller component to help us manage the development process."]}),"\n",(0,s.jsx)(t.p,{children:"We should identify the MVP (Minimum Viable Product), which represents the smallest set of features that provides value. We don't need to be bothered by advanced authentication system, recommendation algorithms, or social features. Perhaps we don't need to integrate Google or Facebook authentication, we can use a simple username and password for the time being."}),"\n",(0,s.jsx)(t.p,{children:"In the case of video streaming :"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"The initial step would be establishing a connection between the client app and the server by sending a basic text message."}),"\n",(0,s.jsx)(t.li,{children:"The next step would be to enhance it to transmit an actual video."}),"\n",(0,s.jsx)(t.li,{children:"Progress would continue gradually, allow multiple clients to connect to the server and send text messages concurrently. The server should be capable of broadcasting messages to all connected clients concurrently."}),"\n",(0,s.jsx)(t.li,{children:"The text message would be upgraded to a real-time video stream, ensure that all clients receive the stream correctly."}),"\n",(0,s.jsx)(t.li,{children:"Create a video player capable of running the stream."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Testing"})," : Write ",(0,s.jsx)(t.a,{href:"/software-engineering/software-testing#automated",children:"automated tests"})," to verify the software and to prevent functionality from becoming incorrect when code is modified."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Keep Going"})," : After creating the minimum viable product and testing it, we should identify any problems or areas for improvement. We can create a list of TODOs that may include bug fixes, new features, corrections, etc. We can prioritize each task on the To-do list and determine the next steps accordingly. If the bug significantly affect the app, we can fix them. If working on a new feature, we can start again the process from step 1 by creating the high-level design of the new feature, developing it incrementally, and targeting the MVP, and so on going iteratively."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},33314:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/agile-b2f2fc89384eea60e2a1dec0f317f956.png"},86314:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/kanban-89e505efc3cf53283fd531199172dbbc.png"},24855:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/prototyping-5b0c812d1b714bd5a85cf612c2fa307a.png"},65029:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/spiral-a4ecf9e06be8b924daa194b6cf1f925c.png"},86116:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/waterfall-2f8e744c9dfad736c2a171642ca14e3a.png"},64002:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/xp-5e88cf4bd0d04feb6a5d7fa391660c16.png"},11151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>a});var s=n(67294);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);