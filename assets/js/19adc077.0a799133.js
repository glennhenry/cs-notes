"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[3717],{87217:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>h});var n=t(85893),s=t(11151);const r={slug:"/computer-and-programming-fundamentals/bitwise-operation",id:"bitwise-operation",title:"Bitwise Operation",description:"Bitwise Operation"},a=void 0,o={id:"computer-and-programming-fundamentals/bitwise-operation/bitwise-operation",title:"Bitwise Operation",description:"Bitwise Operation",source:"@site/docs/computer-and-programming-fundamentals/03-bitwise-operation/bitwise-operation.md",sourceDirName:"computer-and-programming-fundamentals/03-bitwise-operation",slug:"/computer-and-programming-fundamentals/bitwise-operation",permalink:"/cs-notes/computer-and-programming-fundamentals/bitwise-operation",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/computer-and-programming-fundamentals/03-bitwise-operation/bitwise-operation.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1710413100,formattedLastUpdatedAt:"Mar 14, 2024",frontMatter:{slug:"/computer-and-programming-fundamentals/bitwise-operation",id:"bitwise-operation",title:"Bitwise Operation",description:"Bitwise Operation"},sidebar:"sidebar",previous:{title:"Binary Representation",permalink:"/cs-notes/computer-and-programming-fundamentals/binary-representation"},next:{title:"Floating Number",permalink:"/cs-notes/computer-and-programming-fundamentals/floating-number"}},l={},h=[{value:"Bit Shifting",id:"bit-shifting",level:3},{value:"Shift Left",id:"shift-left",level:4},{value:"Shift Right",id:"shift-right",level:4},{value:"Logical Operation",id:"logical-operation",level:3},{value:"NOT",id:"not",level:4},{value:"OR",id:"or",level:4},{value:"XOR",id:"xor",level:4},{value:"AND",id:"and",level:4},{value:"Bit Masking",id:"bit-masking",level:3}];function d(e){const i={a:"a",annotation:"annotation",br:"br",code:"code",h3:"h3",h4:"h4",img:"img",li:"li",math:"math",mn:"mn",mrow:"mrow",msup:"msup",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"Main Source :"})}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.strong,{children:(0,n.jsx)(i.a,{href:"https://youtu.be/BKzB6gdRyIM?si=9lZZJs0hlw6x-q5s",children:"Left Shift and Right Shift Bitwise Operator in C Programming - edu-corner.in"})})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.strong,{children:(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Bitwise_operation",children:"Bitwise operation - Wikipedia"})})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.strong,{children:(0,n.jsx)(i.a,{href:"https://youtu.be/Ew2QnDeTCCE?si=3AtK6cdBQIv3yGgi",children:"What are Bit Masks, and how do I use them? (examples in C) - Jacob Sorber"})})}),"\n"]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"Bitwise Operations"})," are operations performed on individual bits within binary representations of numbers. While bitwise operations manipulate individual bits at the lowest level, these operations provide a deeper control for our algorithm, and it can be more efficient for certain tasks compared to higher-level operations."]}),"\n",(0,n.jsx)(i.h3,{id:"bit-shifting",children:"Bit Shifting"}),"\n",(0,n.jsxs)(i.p,{children:["In binary representation, each binary digits (0 or 1) represent a positional value, starting from ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsxs)(i.msup,{children:[(0,n.jsx)(i.mn,{children:"2"}),(0,n.jsx)(i.mn,{children:"0"})]})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"2^0"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.8141em"}}),(0,n.jsxs)(i.span,{className:"mord",children:[(0,n.jsx)(i.span,{className:"mord",children:"2"}),(0,n.jsx)(i.span,{className:"msupsub",children:(0,n.jsx)(i.span,{className:"vlist-t",children:(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.8141em"},children:(0,n.jsxs)(i.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(i.span,{className:"mord mtight",children:"0"})})]})})})})})]})]})})]})," from the rightmost, the power will be increased by 1 as we go to the left."]}),"\n",(0,n.jsx)(i.p,{children:"Bit shifting is the process of moving a binary digit either to left (shift left) or to the right (shift right)."}),"\n",(0,n.jsx)(i.h4,{id:"shift-left",children:"Shift Left"}),"\n",(0,n.jsxs)(i.p,{children:["The shift left operator (often denoted as ",(0,n.jsx)(i.code,{children:"<<"}),"), shift a binary digit to left. While shifting a digit to the left, we will discard the leftmost value and add a 0 to the rightmost value. If we calculate our binary representation again after shifting it to the left once, our binary representation will be multiplied by 2. This occurs because each binary digit holds a positional value, and shifting them to the left increases their power by 1."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.img,{alt:"Shift left operator",src:t(94500).Z+"",width:"532",height:"278"}),(0,n.jsx)(i.br,{}),"\n","Source : ",(0,n.jsx)(i.a,{href:"https://youtu.be/BKzB6gdRyIM?si=QxyxFt9htR3Q2OQT",children:"https://youtu.be/BKzB6gdRyIM?si=QxyxFt9htR3Q2OQT"})]}),"\n",(0,n.jsx)(i.h4,{id:"shift-right",children:"Shift Right"}),"\n",(0,n.jsxs)(i.p,{children:["The shift right operator (often denoted as ",(0,n.jsx)(i.code,{children:">>"}),"), shift a binary digit to the right. It is the opposite of shift left, it will discard the rightmost value and change the leftmost value to a 0. Also, instead of being multiplied by 2, it will be divided by 2, because the power of two decrease as we go to the right."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.img,{alt:"Shift right operator",src:t(44482).Z+"",width:"528",height:"276"}),(0,n.jsx)(i.br,{}),"\n","Source : ",(0,n.jsx)(i.a,{href:"https://youtu.be/BKzB6gdRyIM?si=XtRX1QwknUl8yhxM&t=205",children:"https://youtu.be/BKzB6gdRyIM?si=XtRX1QwknUl8yhxM&t=205"})]}),"\n",(0,n.jsx)(i.p,{children:"Bit shifting can be beneficial for multiplying or dividing number by 2, we can turn the decimal number into binary representation and then do the bit shifting operation. This can be more efficient especially on systems that can perform bitwise operations quickly."}),"\n",(0,n.jsx)(i.h3,{id:"logical-operation",children:"Logical Operation"}),"\n",(0,n.jsx)(i.p,{children:'Logical operations on binary digits are logical operations performed at bit level of binary values. In binary representation, a binary digit of 1 represent a "true" value and a binary digit of 0 represent a "false" value. By logical operations, it means we are evaluating the logical relationship between boolean values and produce another boolean result.'}),"\n",(0,n.jsx)(i.h4,{id:"not",children:"NOT"}),"\n",(0,n.jsxs)(i.p,{children:["A NOT (often denoted as ",(0,n.jsx)(i.code,{children:"~"}),"), perform a logical negation on each bit of binary value. It flips the logical state of a binary, which itself is a boolean value, changing true to false and false to true, or 1 to 0 and 0 to 1."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"~10000010 (binary)\n---------------\n 01111101 (binary)\n"})}),"\n",(0,n.jsx)(i.h4,{id:"or",children:"OR"}),"\n",(0,n.jsxs)(i.p,{children:["An OR (often denoted as ",(0,n.jsx)(i.code,{children:"|"}),"), will take two binary values and produce another binary where each bit will be set to 1 if either or both of the corresponding bits in the operands are 1 and the result bit is set to 0 only if both corresponding bits are 0."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"10101010 (binary)\n|\n11001100 (binary)\n----------------\n11101110 (binary)\n"})}),"\n",(0,n.jsx)(i.h4,{id:"xor",children:"XOR"}),"\n",(0,n.jsxs)(i.p,{children:["A XOR (often denoted as ",(0,n.jsx)(i.code,{children:"^"}),"), is similar to OR, however, it is a stricter OR operation. The result of the operation between bit will be 1 if ",(0,n.jsx)(i.strong,{children:"both"})," of the bit in the operands are 1 and will produce 0 otherwise."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"10101010 (binary)\n^\n11001100 (binary)\n----------------\n01100110 (binary)\n"})}),"\n",(0,n.jsx)(i.h4,{id:"and",children:"AND"}),"\n",(0,n.jsxs)(i.p,{children:["An AND (often denoted as ",(0,n.jsx)(i.code,{children:"&"}),"), takes two binary values and produce a binary digit of 1 if both of the bit are 1, otherwise produce 0."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"10101010 (binary)\n&\n11001100 (binary)\n----------------\n10001000 (binary)\n"})}),"\n",(0,n.jsx)(i.h3,{id:"bit-masking",children:"Bit Masking"}),"\n",(0,n.jsx)(i.p,{children:"Bit masking is the process of selectively manipulate or extract specific bits within a binary value using various bitwise operations."}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsxs)(i.p,{children:["Extracting specific bits : Consider a binary values, we want to extract first four digits from the right. We will then choose the appropriate ",(0,n.jsx)(i.strong,{children:"binary mask"}),", which is the binary values pattern used to manipulate the target binary."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"Value:   10101010\nMask:    00001111\n------------------- AND\nResult:  00001010\n"})}),"\n",(0,n.jsxs)(i.p,{children:["Given a binary values ",(0,n.jsx)(i.code,{children:"10101010"}),", to extract the first four binary digits from the right, we choose the mask ",(0,n.jsx)(i.code,{children:"00001111"})," and do a bitwise AND operation."]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Setting specific bits : We can perform a bitwise OR operation with a mask that consist of 1 to set the binary values to 1 and use binary digit of 0 to keep other bits unchanged."}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"Value:   10101010\nMask:    00001111\n------------------- OR\nResult:  10101111\n"})}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Clear specific bits : By performing a bitwise AND operation between a binary value and a mask with specific bits set to 0, the result will have the corresponding bits in the value set to 0, while preserving the other bits."}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"Value:   10101010\nMask:    11110000\n------------------- AND\nResult:  10100000\n"})}),"\n"]}),"\n"]})]})}function c(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},94500:(e,i,t)=>{t.d(i,{Z:()=>n});const n=t.p+"assets/images/shift-left-0d9c7d347a9a7c067056938afdf56c84.png"},44482:(e,i,t)=>{t.d(i,{Z:()=>n});const n=t.p+"assets/images/shift-right-82e13eac09489114fa109d3261e72a28.png"},11151:(e,i,t)=>{t.d(i,{Z:()=>o,a:()=>a});var n=t(67294);const s={},r=n.createContext(s);function a(e){const i=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),n.createElement(r.Provider,{value:i},e.children)}}}]);