"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[5702],{27991:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/trie-7002d7ad664787ae972a2aaeae72a033.png"},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var r=n(96540);const s={},a=r.createContext(s);function i(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:t},e.children)}},62143:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/autocomplete-0b16183bfa26d7aa8bb76b1fa2f49995.png"},87248:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"data-structures-and-algorithms/trie/trie","title":"Trie","description":"Trie","source":"@site/docs/data-structures-and-algorithms/11-trie/trie.mdx","sourceDirName":"data-structures-and-algorithms/11-trie","slug":"/data-structures-and-algorithms/trie","permalink":"/cs-notes/data-structures-and-algorithms/trie","draft":false,"unlisted":false,"editUrl":"https://github.com/glennhenry/cs-notes/tree/main/docs/data-structures-and-algorithms/11-trie/trie.mdx","tags":[],"version":"current","lastUpdatedBy":"glennhenry","lastUpdatedAt":1723455088000,"frontMatter":{"slug":"/data-structures-and-algorithms/trie","id":"trie","title":"Trie","description":"Trie"},"sidebar":"sidebar","previous":{"title":"Graph","permalink":"/cs-notes/data-structures-and-algorithms/graph"},"next":{"title":"Sorting","permalink":"/cs-notes/data-structures-and-algorithms/sorting"}}');var s=n(74848),a=n(28453);const i=n.p+"assets/medias/trie-traversal-878dd711bb1b44f77ca97bacae979665.mp4",o={slug:"/data-structures-and-algorithms/trie",id:"trie",title:"Trie",description:"Trie"},l=void 0,c={},h=[{value:"Trie Implementation",id:"trie-implementation",level:3}];function d(e){const t={a:"a",admonition:"admonition",annotation:"annotation",br:"br",h3:"h3",img:"img",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",ol:"ol",p:"p",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Main Source:"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Trie",children:"Trie \u2014 Wikipedia"})})}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Trie"}),", also known as ",(0,s.jsx)(t.strong,{children:"prefix tree"}),", is a type of ",(0,s.jsx)(t.a,{href:"/data-structures-and-algorithms/tree",children:"tree"})," data structure, which primarily used for efficient retrieval and storage of strings or sequences of characters."]}),"\n",(0,s.jsx)(t.p,{children:"Just like a typical tree, trie consist a set of node where each node represents a single character or a partial string. The root node represents an empty string, and each path from the root to a leaf node represents a complete string. The edges of the trie are labeled with characters, indicating the next character in the string. By traversing from the root to any path in a trie, the characters encountered along the path form a string."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Trie data structure",src:n(27991).A+"",width:"433",height:"414"}),(0,s.jsx)(t.br,{}),"\n","Source: ",(0,s.jsx)(t.a,{href:"https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/800px-Trie_example.svg.png",children:"https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/800px-Trie_example.svg.png"})]}),"\n",(0,s.jsx)(t.p,{children:'For example, in the trie image above, if we traverse to the left ("t"), right ("e"), and left ("a"), sequentially from the root, we will form the string "tea".'}),"\n",(0,s.jsxs)(t.p,{children:["One of the main advantages of a trie is its ability to perform prefix matching efficiently and able to store common prefix among strings. Search or matching a given string involves traversing from the root following the character given in the string. All operation including search, insertion, and deletion, all happens in ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsxs)(t.mrow,{children:[(0,s.jsx)(t.mi,{children:"O"}),(0,s.jsx)(t.mo,{stretchy:"false",children:"("}),(0,s.jsx)(t.mi,{children:"n"}),(0,s.jsx)(t.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"O(n)"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,s.jsx)(t.span,{className:"mopen",children:"("}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"n"}),(0,s.jsx)(t.span,{className:"mclose",children:")"})]})})]})," time complexity, where ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"n"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"n"})]})})]})," is the length of the string we are looking to match, insert, or delete."]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["What is a common prefix?",(0,s.jsx)(t.br,{}),"\n",'A prefix is just a part of a string that comes before the rest of the characters. Consider the words "cat," "car," and "dog." We can say "cat" and "car" has common prefix, because both starts with string "ca" in the beginning.']})}),"\n",(0,s.jsx)(t.p,{children:"Trie allows for quick lookup and retrieval of all strings that have a given prefix. This property makes tries useful in applications such as autocomplete, spell checking, and searching for words with a common prefix."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Application of trie data structure in auto-complete system",src:n(62143).A+"",width:"438",height:"345"}),(0,s.jsx)(t.br,{}),"\n","Source: ",(0,s.jsx)(t.a,{href:"https://youtu.be/lPgaClbZ90o?si=-WsR_bJBG6JQLgaE",children:"https://youtu.be/lPgaClbZ90o?si=-WsR_bJBG6JQLgaE"})]}),"\n",(0,s.jsx)(t.h3,{id:"trie-implementation",children:"Trie Implementation"}),"\n",(0,s.jsx)(t.p,{children:"We can implement trie with a tree data structure, which can be implemented using linked list under the hood."}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Each node will represent either a character or a partial string, except the root node, containing an empty string."}),"\n",(0,s.jsx)(t.li,{children:"The root node should have reference to its child, which can vary depending on the use case. If we only store character, we would only need a maximum 26 children nodes, assuming we are storing the unique alphabets."}),"\n",(0,s.jsx)(t.li,{children:'We will also include a flag or boolean value in each node to indicate if that node represents the end of a complete string or not. For example, when we insert string "tea", we don\'t want to treat "te" as the complete word, so we will set the flag to false in the "t" and "e" node, while setting the flag to true in "a" node.'}),"\n"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Searching"}),": Traverse the trie from the root node, following the path dictated by the characters of the target string. If at any point a character doesn't exist, it indicates that the string is not present in the trie. If we found all the prefix of the string, we will also check if it is a complete string."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Insertion"}),": Similar to search, we will traverse from the root node, when a character exist, we will continue going down there. When a character doesn't exist, we will make a new node for it."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Deletion"}),": Traverse the trie from the root node, once the string is found, we will simply mark the last node as not a complete string. We will not remove the node, to ensure we don't accidentally remove other prefix."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Here is an trie traversal illustration for matching strings."}),"\n",(0,s.jsx)("video",{width:"695",height:"392",controls:!0,children:(0,s.jsx)("source",{src:i})})]})}function m(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);