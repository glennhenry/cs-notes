"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[6179],{84337:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var o=n(85893),t=n(11151);const r={slug:"/compilers-and-programming-languages/compiler-optimization",id:"compiler-optimization",title:"Compiler Optimization",description:"Compiler Optimization"},l=void 0,s={id:"compilers-and-programming-languages/compiler-optimization/compiler-optimization",title:"Compiler Optimization",description:"Compiler Optimization",source:"@site/docs/compilers-and-programming-languages/15-compiler-optimization/compiler-optimization.md",sourceDirName:"compilers-and-programming-languages/15-compiler-optimization",slug:"/compilers-and-programming-languages/compiler-optimization",permalink:"/cs-notes/compilers-and-programming-languages/compiler-optimization",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/compilers-and-programming-languages/15-compiler-optimization/compiler-optimization.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1715422084e3,frontMatter:{slug:"/compilers-and-programming-languages/compiler-optimization",id:"compiler-optimization",title:"Compiler Optimization",description:"Compiler Optimization"},sidebar:"sidebar",previous:{title:"Code Generation",permalink:"/cs-notes/compilers-and-programming-languages/code-generation"},next:{title:"Functional Languages",permalink:"/cs-notes/compilers-and-programming-languages/functional-languages"}},a={},c=[{value:"Constant Folding",id:"constant-folding",level:3},{value:"Strength Reduction",id:"strength-reduction",level:3},{value:"Loop Unrolling",id:"loop-unrolling",level:3},{value:"Code Hoisting",id:"code-hoisting",level:3},{value:"Function Inlining",id:"function-inlining",level:3},{value:"Dead Code Elimination",id:"dead-code-elimination",level:3},{value:"Peephole Optimization",id:"peephole-optimization",level:3},{value:"Instruction Selection",id:"instruction-selection",level:3},{value:"Register Allocation",id:"register-allocation",level:3}];function d(e){const i={a:"a",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.p,{children:(0,o.jsx)(i.strong,{children:"Main Source :"})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:(0,o.jsx)(i.strong,{children:"Book 1 chapter 12."})}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"Many optimization techniques can be applied to the assembly code (or intermediate representation, if the optimization happens during it). Some optimization happens within local block, global, or even the whole program."}),"\n",(0,o.jsx)(i.p,{children:"Some type of optimization :"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Simplification"})," : This includes removing redundancy and removing unnecessary computations."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Control flow"})," : Targets control flow structure (e.g., loops and conditionals), such as reducing the number of branching to reduce ",(0,o.jsx)(i.a,{href:"/computer-organization-and-architecture/cpu-design#pipelining",children:"pipelining stall"}),"."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Memory and registers"})," : Efficient and correct allocation of registers and memory to reduce their usage and improve speed. For example, we can store frequently used variables in registers instead of the memory to increase access speed."]}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"constant-folding",children:"Constant Folding"}),"\n",(0,o.jsxs)(i.p,{children:["Constant folding simplify expressions (or part of them) that involve constants, which is known during compile-time. For example, the ",(0,o.jsx)(i.a,{href:"/compilers-and-programming-languages/intermediate-representation#optimization",children:"second calculation in a day"})," effectively demonstrate this concept."]}),"\n",(0,o.jsx)(i.p,{children:"During compilation, expressions are checked to determine whether they contain constants or not. Only if all the operands of the expression are known are they calculated. For example, arithmetic operation typically takes two operands."}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"int result = 10 * 10 + 100 - 10\n\n// is optimized to:\nint result = 190\n"})}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"int result = 10 * 10 + x\n\n// is optimized to:\nint result = 100 + x\n"})}),"\n",(0,o.jsx)(i.h3,{id:"strength-reduction",children:"Strength Reduction"}),"\n",(0,o.jsx)(i.p,{children:"Strength reduction replaces an expression to equivalent but less expensive operation."}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"x * 8"})," is optimized to ",(0,o.jsx)(i.code,{children:"x << 3"}),", as ",(0,o.jsx)(i.a,{href:"/computer-and-programming-fundamentals/bitwise-operation#bit-shifting",children:"bit shifting"})," can be faster than multiplication. This is similar to division."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"x ^ 2"})," (exponentiation) is optimized to ",(0,o.jsx)(i.code,{children:"x * x"}),", as exponentiation may use techniques like Taylor series, which may be more expensive than simple multiplication."]}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"loop-unrolling",children:"Loop Unrolling"}),"\n",(0,o.jsxs)(i.p,{children:["In branching, CPU can try to make an educated guess about the outcome of a branch instruction before it is actually executed. This will avoid ",(0,o.jsx)(i.a,{href:"/computer-organization-and-architecture/cpu-design#pipelining",children:"pipeline stalls"}),", which further improves performance."]}),"\n",(0,o.jsx)(i.p,{children:"Loop typically involve branch and jump instruction. These instructions introduce control flow changes, which may result in branch mispredictions. This happens when the CPU fails to make a correct guess. It would need to discard the speculatively executed instructions and fetch the correct instructions at the cost of extra time."}),"\n",(0,o.jsxs)(i.p,{children:["Loop unrolling modifies the structure of a loop by replicating loop iterations and combining them into a larger loop. This will make the loop repeat less, but does more work on each iteration. This will reduce the number of branching, which can increase ",(0,o.jsx)(i.a,{href:"/computer-organization-and-architecture/cpu-design#superscalar",children:"instruction-level parallelism"}),", the ability to execute multiple instruction simultaneously."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"// Original loop\nfor (int i = 0; i < 4; i++) {\n    print(arr[i])\n}\n\n// Unrolled loop\nfor (int i = 0; i < 4; i += 2) {\n    print(arr[i])\n    print(arr[i + 1])\n}\n"})}),"\n",(0,o.jsxs)(i.p,{children:["The first loop will call ",(0,o.jsx)(i.code,{children:"arr[0]"}),", ",(0,o.jsx)(i.code,{children:"arr[1]"}),", ",(0,o.jsx)(i.code,{children:"arr[2]"}),", and ",(0,o.jsx)(i.code,{children:"arr[3]"}),", with each being called in a different iteration. Notice that the second loop increments ",(0,o.jsx)(i.code,{children:"i"})," by 2 instead. This change causes the second loop to call ",(0,o.jsx)(i.code,{children:"arr[0]"})," and ",(0,o.jsx)(i.code,{children:"arr[1]"}),", and then ",(0,o.jsx)(i.code,{children:"arr[2]"})," and ",(0,o.jsx)(i.code,{children:"arr[3]"})," in just two iterations. It's worth noting that loop unrolling may result in a different kind of loop structure, depending on the loop."]}),"\n",(0,o.jsxs)(i.p,{children:["The number of iterations within the unrolled loop is called the ",(0,o.jsx)(i.strong,{children:"unrolling factor"}),". It should be adjusted based on the scenario, as too much unrolling can also increase code size."]}),"\n",(0,o.jsx)(i.h3,{id:"code-hoisting",children:"Code Hoisting"}),"\n",(0,o.jsx)(i.h3,{id:"function-inlining",children:"Function Inlining"}),"\n",(0,o.jsx)(i.h3,{id:"dead-code-elimination",children:"Dead Code Elimination"}),"\n",(0,o.jsx)(i.h3,{id:"peephole-optimization",children:"Peephole Optimization"}),"\n",(0,o.jsx)(i.h3,{id:"instruction-selection",children:"Instruction Selection"}),"\n",(0,o.jsx)(i.h3,{id:"register-allocation",children:"Register Allocation"})]})}function p(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},11151:(e,i,n)=>{n.d(i,{Z:()=>s,a:()=>l});var o=n(67294);const t={},r=o.createContext(t);function l(e){const i=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function s(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),o.createElement(r.Provider,{value:i},e.children)}}}]);