"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[249],{4086:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var s=i(85893),n=i(11151);const r={slug:"/operating-system/file-system",id:"file-system",title:"File System",description:"File System"},a=void 0,o={id:"operating-system/file-system/file-system",title:"File System",description:"File System",source:"@site/docs/operating-system/11-file-system/file-system.md",sourceDirName:"operating-system/11-file-system",slug:"/operating-system/file-system",permalink:"/cs-notes/operating-system/file-system",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/operating-system/11-file-system/file-system.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1706948201,formattedLastUpdatedAt:"Feb 3, 2024",frontMatter:{slug:"/operating-system/file-system",id:"file-system",title:"File System",description:"File System"},sidebar:"sidebar",previous:{title:"Disk Management",permalink:"/cs-notes/operating-system/disk-management"},next:{title:"Device Management",permalink:"/cs-notes/operating-system/device-management"}},l={},c=[{value:"File",id:"file",level:3},{value:"File Attributes",id:"file-attributes",level:4},{value:"File Operation",id:"file-operation",level:4},{value:"File Security",id:"file-security",level:4},{value:"File Organization",id:"file-organization",level:3},{value:"Directory",id:"directory",level:4},{value:"Directory Levels",id:"directory-levels",level:4},{value:"Pathnames",id:"pathnames",level:4},{value:"Representation",id:"representation",level:4},{value:"File System Implementation",id:"file-system-implementation",level:3},{value:"File System Structure",id:"file-system-structure",level:4},{value:"File Control Block",id:"file-control-block",level:4},{value:"Partition &amp; Mounting",id:"partition--mounting",level:4},{value:"Directory Implementation",id:"directory-implementation",level:4},{value:"Allocation Methods",id:"allocation-methods",level:4},{value:"Free-Space Management",id:"free-space-management",level:4},{value:"File System Example",id:"file-system-example",level:3},{value:"FAT",id:"fat",level:4},{value:"NTFS",id:"ntfs",level:4},{value:"ext",id:"ext",level:4},{value:"ext2",id:"ext2",level:5},{value:"ext3",id:"ext3",level:5},{value:"ext4",id:"ext4",level:5}];function h(e){const t={a:"a",admonition:"admonition",br:"br",code:"code",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,n.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Main Source :"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.strong,{children:"[Chapter 11 File-System Interface - Abraham Silberschatz-Operating System Concepts (9th,2012_12)]"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.strong,{children:"[Chapter 12 File-System Implementation - Abraham Silberschatz-Operating System Concepts (9th,2012_12)]"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/File_system",children:"File system - Wikipedia"})})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"https://www.scaler.com/topics/directory-structure-in-os/",children:"Directory structure in OS - SCALER Topics"})})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/File_Allocation_Table",children:"File Allocation Table - Wikipedia"})})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system",children:"Design of the FAT file system - Wikipedia"})})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/NTFS",children:"NTFS - Wikipedia"})})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Extended_file_system",children:"Extended file system - Wikipedia"})})}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"File System"})," is a logical construct, a method, or structure used by an operating system to organize and store data on the storage."]}),"\n",(0,s.jsx)(t.p,{children:"At the lowest level, disk stores data in binary 0s and 1s, grouped together into sectors and blocks. Having file system provide a more convenient way to access data, it serves as an abstraction layer between the physical storage medium and the operating system when doing file operation."}),"\n",(0,s.jsx)(t.h3,{id:"file",children:"File"}),"\n",(0,s.jsxs)(t.p,{children:["File is a named collection of related data that is stored on a storage medium. File contains information, depending on the file format, it can either be binary data (machine-readable) or plain text data (human-readable), which is encoded in specific encoding format such as ",(0,s.jsx)(t.a,{href:"/computer-and-programming-fundamentals/data-representation#ascii",children:"ASCII"})," or ",(0,s.jsx)(t.a,{href:"/computer-and-programming-fundamentals/data-representation#utf",children:"UTF-8"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Internally, a file is typically represented as a sequence of bytes or characters. File have specific format that explain how the file is structured. For example, image file format such as ",(0,s.jsx)(t.a,{href:"/digital-media-processing/png",children:"PNG"})," structure it's contents such that, computer know how to interpret it meaningfully. It may contain information about the file or the actual file information; in the case of images, it is the pixel data."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"File content",src:i(1050).Z+"",width:"1156",height:"371"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://twitter.com/likev/status/1395285523460083714",children:"PNG file"}),", ",(0,s.jsx)(t.a,{href:"https://www.techtarget.com/whatis/definition/ASCII-American-Standard-Code-for-Information-Interchange",children:"TXT file"})]}),"\n",(0,s.jsx)(t.p,{children:"The specific format or type of files is typically associated within the name as its extension. They are letters or symbols that appear after the dot in a file name (e.g., .txt for a text file, .jpg for an image file)."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Type of files",src:i(47280).Z+"",width:"397",height:"425"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/11_FileSystemInterface.html",children:"https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/11_FileSystemInterface.html"})]}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsxs)(t.p,{children:["More about the ",(0,s.jsx)(t.a,{href:"/digital-media-processing",children:"structure of specific file format"})]})}),"\n",(0,s.jsx)(t.h4,{id:"file-attributes",children:"File Attributes"}),"\n",(0,s.jsx)(t.p,{children:"The file system keep track of the data information, file has many attributes :"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Name"})," : Every file has a unique name, which is human-readable, that identifies it within the file system. The name is used to reference and locate the file."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Size"})," : The size of a file refers to the amount of storage space it occupies on the storage medium, usually measured in bytes, kilobytes, megabytes, or larger units."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Type/Format"})," : Examples include text files (e.g., .txt), image files (e.g., .jpg, .png), audio files (e.g., .mp3), video files (e.g., .mp4), and many more."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Location"})," : The location of a file refers to its physical position or address on the storage medium."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Metadata"})," : Other information about the file, such as creation and modification timestamps, file permissions, file owner, file attributes, and other relevant details."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Protection"})," : Security related information, such as, who is allowed to read or write, is it visible, is it read-only, etc."]}),"\n"]}),"\n",(0,s.jsx)(t.h4,{id:"file-operation",children:"File Operation"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Create"})," : Create a new file entry along with information associated with the file, this requires allocating space for the file, and a directory to store the file."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Write"})," : The write operation is used to modify the contents of a file or append new data to it. Through ",(0,s.jsx)(t.a,{href:"/operating-system/system-call",children:"system call"}),", we will specify the target file, starting position, and the data to be written. The OS translates the logical file address to a physical disk location and writes the data to the appropriate sectors or blocks on the storage medium."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Read"})," : The read operation retrieves data from a file and transfers it into memory. It involves specifying the file to read, the starting position, and the number of bytes to read. The OS translates the logical file address to a physical disk location, retrieves the requested data, and transfers it to the requesting process or buffer."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Reposition / Seek"})," : The seek operation is used to reposition the current read/write position within a file. It involves specifying an offset from a reference point (e.g., the beginning, current position, or end of the file) and a direction (forward or backward). The OS updates the file's read/write pointer accordingly, allowing subsequent read or write operations to occur at the desired location."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Delete"})," : The delete operation removes a file from the file system. It involves locating the file's metadata, freeing the associated disk space, and updating directory entries or file system structures to reflect the deletion."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Truncate"})," : Truncating a file adjusts its size by removing or discarding a portion of its contents, based on the specified target size. The OS updates file metadata and frees disk space as needed. Truncation can both shrink and expand a file, making discarded data inaccessible."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Open"})," : Establishes a connection or handle to a file, enabling subsequent operations on it. It involves specifying the file's name or identifier, access mode (e.g., read-only, write-only, or read-write), and other optional parameters. The OS verifies access permissions, allocates necessary resources (e.g., file descriptors), and prepares the file for subsequent operations."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Close"})," : The close operation terminates the connection or handle to an open file. It involves releasing any resources associated with the file, such as file descriptors or locks."]}),"\n"]}),"\n",(0,s.jsxs)(t.admonition,{type:"tip",children:[(0,s.jsx)(t.p,{children:"Terminology :"}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"File pointer"})," is reference or indicator that points to a specific location within a file, in which next read or write operation will occur. File pointer for read operation is called ",(0,s.jsx)(t.strong,{children:"read-pointer"})," and for write operation, it is called ",(0,s.jsx)(t.strong,{children:"write-pointer"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"File descriptors"})," are unique identifiers or numerical representations that represent access to a file, socket, or other I/O resources."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"File locks"})," are mechanism to restrict access to a file or a portion of a file to a single process or thread, to prevent concurrent access. There are two types of locks, ",(0,s.jsx)(t.strong,{children:"shared lock"}),", which allows multiple processes to read concurrently, or ",(0,s.jsx)(t.strong,{children:"exclusive lock"}),", which grants exclusive access to a process for writing to the file."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"File-open count"})," is a number of times a file has been opened by different processes or within the same process. It helps keeping track of how many processes currently have the file open."]}),"\n"]})]}),"\n",(0,s.jsx)(t.h4,{id:"file-security",children:"File Security"}),"\n",(0,s.jsxs)(t.p,{children:["To ensure only authorized processes have access to files, the OS provide a mechanism called ",(0,s.jsx)(t.strong,{children:"access control"}),". The OS maintains metadata about each file, including ownership and permissions. These permissions specify which processes are allowed to perform certain operations on the file, such as read, write, execute, append, delete, or list. Read, write, execute, and list are descriptive, append means writing new information at the end of the file, and list, list the name and attributes of the file."]}),"\n",(0,s.jsx)(t.p,{children:"In a multi-user environment where multiple users operate the same computer, meaning they may share access to files, this is where file security becomes even more critical. The operating system provides features to handle file sharing and control how files may be accessed by different users, not just processes."}),"\n",(0,s.jsxs)(t.p,{children:["In ",(0,s.jsx)(t.a,{href:"/operating-system/unix",children:"Unix OS"}),", each file is assigned a 9-bit binary protection code, which consists of three 3-bit fields representing the ",(0,s.jsx)(t.strong,{children:"owner"}),", the ",(0,s.jsx)(t.strong,{children:"owner's group"}),", and everyone else (also called ",(0,s.jsx)(t.strong,{children:"universe"}),"). These fields determine the level of access granted to different users or groups for a particular file."]}),"\n",(0,s.jsx)(t.p,{children:"The three permission bits for each field are :"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Read (r)"})," : View the contents of the file."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Write (w)"})," : Modify or delete the file."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Execute (x)"})," : Grants the user or group the ability to execute the file, in the case of executable files or scripts, or to access the contents of a directory."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:'For example, a file with the permission code "rwxr-x--x" means that the owner has read, write, and execute permissions, the owner\'s group has read and execute permissions, and others have only execute permission.'}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"File security",src:i(89697).Z+"",width:"499",height:"431"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://www.researchgate.net/figure/File-system-protection-algorithm_fig3_260525066",children:"https://www.researchgate.net/figure/File-system-protection-algorithm_fig3_260525066"})]}),"\n",(0,s.jsx)(t.h3,{id:"file-organization",children:"File Organization"}),"\n",(0,s.jsx)(t.h4,{id:"directory",children:"Directory"}),"\n",(0,s.jsxs)(t.p,{children:["Within the file system on a disk, files are organized in ",(0,s.jsx)(t.strong,{children:"directories"})," or ",(0,s.jsx)(t.strong,{children:"folders"}),". A directory is a way of grouping files together, it is a container that holds related files and provides a hierarchical structure for organizing and managing these files. A directory itself does not represent a physical entity on the disk but rather serves as a logical container or organizational unit for files and subdirectories."]}),"\n",(0,s.jsxs)(t.p,{children:["Directories create a hierarchy within the file system, forming a tree-like structure. At the top of the hierarchy is the ",(0,s.jsx)(t.strong,{children:"root directory"}),", which serves as the starting point for navigating the file system. ",(0,s.jsx)(t.strong,{children:"Subdirectories"})," can be created within the root directory, and further subdirectories can be created within those, forming a nested structure."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Directory structure",src:i(36424).Z+"",width:"542",height:"411"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://informationtechnologyja.wordpress.com/2020/10/19/information-technology-grade-9-lesson-2-tree-directory-structure/",children:"https://informationtechnologyja.wordpress.com/2020/10/19/information-technology-grade-9-lesson-2-tree-directory-structure/"})]}),"\n",(0,s.jsx)(t.h4,{id:"directory-levels",children:"Directory Levels"}),"\n",(0,s.jsx)(t.p,{children:"Directory can be categorized based on their organizational structure and the depth of their hierarchy :"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Single-Level Directory"})," : All files are stored in a single directory without any subdirectories. While it's simple, it can be confusing to manage and locate specific files as the number of files increases."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Two-Level Directory"})," : Files are organized into multiple directories, with each directory having a unique name. Each file is associated with the name of the directory it belongs to, along with its own individual name."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Tree-Structured Directory"})," : This is the most commonly used directory. This directory structure its file in hierarchical tree-like structure. The top-level directory is the root directory, and from there, subdirectories can be created, each containing files or additional subdirectories."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Directory levels",src:i(89103).Z+"",width:"990",height:"511"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://www.scaler.com/topics/directory-structure-in-os/",children:"https://www.scaler.com/topics/directory-structure-in-os/"})]}),"\n",(0,s.jsx)(t.h4,{id:"pathnames",children:"Pathnames"}),"\n",(0,s.jsxs)(t.p,{children:["Files within the file system are identified by their ",(0,s.jsx)(t.strong,{children:"pathnames"}),', which specify their location within the directory hierarchy. A pathname typically includes the names of directories traversed from the root directory to the specific file, separated by slashes ("/") in Unix-like systems or backslashes ("") in Windows systems.']}),"\n",(0,s.jsxs)(t.p,{children:["For example, in Unix, a document file could be inside the Documents directory : ",(0,s.jsx)(t.code,{children:"/home/user/Documents/file.txt"}),", where the root directory is just ",(0,s.jsx)(t.code,{children:"/"}),". In Windows system, ",(0,s.jsx)(t.code,{children:"C:\\Users\\user\\Documents\\file.txt"}),", where the root directory is ",(0,s.jsx)(t.code,{children:"C:\\"}),", the ",(0,s.jsx)(t.code,{children:"C"})," is a drive letter which identify different disk partition in the storage."]}),"\n",(0,s.jsx)(t.p,{children:"There are three types of pathnames :"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Absolute"})," : An absolute pathnames from the root to the file or directory. For example, in Unix-like systems, an absolute pathname could be ",(0,s.jsx)(t.code,{children:"/home/user/Documents/file.txt"}),", where ",(0,s.jsx)(t.code,{children:"/home/user/"})," represents the path to the ",(0,s.jsx)(t.code,{children:"Documents"})," directory, and ",(0,s.jsx)(t.code,{children:"file.txt"})," is the file name."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Relative"})," : Location of a file or directory relative to the current working directory. For example, if the current working directory is ",(0,s.jsx)(t.code,{children:"/home/user/"}),", a relative pathname could be ",(0,s.jsx)(t.code,{children:"Documents/file.txt"}),' to refer to the file within the "Documents" directory.']}),"\n",(0,s.jsxs)(t.p,{children:['In the context of file system, the single dot "." and double dot ".." has a special meaning. The single dot represents the current directory, it is used to refer to the current working directory in relative pathnames. For example, if the current working directory is ',(0,s.jsx)(t.code,{children:"/home/user/"}),", the pathname ",(0,s.jsx)(t.code,{children:"./file.txt"})," refers to the file ",(0,s.jsx)(t.code,{children:"file.txt"})," in the current directory."]}),"\n",(0,s.jsxs)(t.p,{children:["The double dot represents the parent directory, it is used to refer to the directory one level up in the directory hierarchy. For example, if the current working directory is ",(0,s.jsx)(t.code,{children:"/home/user/Documents/"}),", the pathname ",(0,s.jsx)(t.code,{children:"../file.txt"})," refers to the file ",(0,s.jsx)(t.code,{children:"file.txt"})," in the parent directory of ",(0,s.jsx)(t.code,{children:"Documents"}),", which is ",(0,s.jsx)(t.code,{children:"/home/user/"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Canonical"}),' : Absolute pathname that has been simplified or normalized to its simplest form. It eliminates any unnecessary or redundant elements such as "." (current directory) and ".." (parent directory) references. For example, ',(0,s.jsx)(t.code,{children:"/home/user/Documents/../file.txt"})," accesses the ",(0,s.jsx)(t.code,{children:"file.txt"})," in the parent of ",(0,s.jsx)(t.code,{children:"Documents"})," directory, this can be simplified to ",(0,s.jsx)(t.code,{children:"/home/user/file.txt"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h4,{id:"representation",children:"Representation"}),"\n",(0,s.jsx)(t.p,{children:"Other than tree, there are other data structure can be used to represent directories. One of them is graph, using graph allows directories to have multiple parents, whereas trees enforce a strict hierarchical structure with a single parent for each directory. This can be useful when a directory needs to be logically linked or shared between multiple locations within the file system."}),"\n",(0,s.jsx)(t.p,{children:"Multiple parents allow directory to have links, which are references or pointers to other files or directories."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Hard / Physical Links"})," : A hard link is a direct reference to a file or directory. When a hard link is created, it points to the same underlying data as the original file or directory. Changes made to the file through any of its hard links are reflected in all other hard links. Hard links can only be created for files within the same file system since they reference the underlying data blocks directly. While hard links can be used to create multiple references to a file, they cannot create cyclic dependencies or loops within a graph structure."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Soft / Symbolic Links"})," : On the other hand, soft link acts as a pointer or reference to another file or directory. Unlike hard links, soft links are separate files that contain a path to the target file or directory. When accessing a soft link, the file system resolves the link and redirects the request to the target file or directory. Changes made to the target file or directory are reflected in the soft link, but modifying the soft link itself does not affect the target. Soft links make it possible to create loops or cycles within a graph-like structure."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Links",src:i(3339).Z+"",width:"419",height:"245"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://www.scaler.com/topics/hard-link-and-soft-link-in-linux/",children:"https://www.scaler.com/topics/hard-link-and-soft-link-in-linux/"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The two types of graph for directory representation :"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"/data-structures-and-algorithms/graph#acyclic",children:"Acyclic Graph"})})," : This directory structure uses a ",(0,s.jsx)(t.strong,{children:"directed acyclic graphs (DAGs)"})," to represent directories and their relationships. Directories can have multiple parents, and symbolic links can be used to create additional directory references. However, it is important to maintain acyclicity, meaning there should be no cyclic dependencies or loops in the graph."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Acyclic graph",src:i(63892).Z+"",width:"332",height:"271"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/11_FileSystemInterface.html",children:"https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/11_FileSystemInterface.html"})]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"/data-structures-and-algorithms/graph",children:"General Graph"})})," : In a general graph directory structure, directories are represented using a general graph data structure, which may have cycles and arbitrary relationships. Managing and navigating a general graph directory structure may require additional algorithms or mechanisms to handle cycles and resolve conflicts."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"General graph",src:i(38571).Z+"",width:"410",height:"249"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/11_FileSystemInterface.html",children:"https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/11_FileSystemInterface.html"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"/data-structures-and-algorithms/tree",children:"Tree"})," is a special case of graph where the properties are undirected and acyclic. It contains no cycles or loops and connected, meaning there is a path between any two vertices."]})}),"\n",(0,s.jsx)(t.h3,{id:"file-system-implementation",children:"File System Implementation"}),"\n",(0,s.jsx)(t.h4,{id:"file-system-structure",children:"File System Structure"}),"\n",(0,s.jsx)(t.p,{children:"File system is designed with multiple levels, forming a layered structure."}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"At the lowest level, the physical properties of the storage devices, such as disks, are dealt with. This level accesses data directly from the disk in the level of blocks. It is possible to access to any block of information on the disk directly."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"The hardware is controlled by I/O control, through device drivers and interrupt handlers. It manages the flow of data between the application programs and the storage devices, also handles error detection and recovery in case of I/O failures."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"A basic file system is implemented above the hardware. It is a logical file system on the physical storage devices that handles the low-level operations required to read and write data from and to the physical block of storage devices."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["The file-organization module is responsible for managing how files are stored and organized. This includes determining allocated space (",(0,s.jsx)(t.a,{href:"#free-space-management",children:"free-space management"}),"), location of file, and translation between physical blocks and logical blocks."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["The logical file system is the highest-level in the system. It is the level where a standardized and abstracted interface exist for applications to access and manipulate files without needing to know the details of the underlying physical storage devices. File organization is abstracted using ",(0,s.jsx)(t.a,{href:"#directory",children:"directory"}),", file is also included with a ",(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"#file-control-block",children:"File Control Block (FCB)"})}),", which is a data structure used to maintain information about individual files, such as ownership, permissions, and location of the file contents."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"File system structure",src:i(53657).Z+"",width:"154",height:"299"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/12_FileSystemImplementation.html",children:"https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/12_FileSystemImplementation.html"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["More about disk in ",(0,s.jsx)(t.a,{href:"/operating-system/disk-management",children:"disk management"}),"."]}),"\n",(0,s.jsx)(t.h4,{id:"file-control-block",children:"File Control Block"}),"\n",(0,s.jsx)(t.p,{children:"FCB holds important metadata about the file, such as its name, location, size, permissions, creation and modification timestamps, and other attributes. It acts as a reference point for the operating system to track and manipulate the file throughout its lifecycle."}),"\n",(0,s.jsx)(t.p,{children:"When a file is created, the file system allocates a new FCB to represent it. The FCB is then updated with the necessary information, such as the file name and its associated data blocks. This FCB is then stored in the appropriate directory structure, allowing the operating system to locate and access the file."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"File control block",src:i(99388).Z+"",width:"741",height:"364"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/12_FileSystemImplementation.html",children:"https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/12_FileSystemImplementation.html"})]}),"\n",(0,s.jsxs)(t.p,{children:["The OS keep track a data structure called ",(0,s.jsx)(t.strong,{children:"open-file table"}),", to manage open files by processes or applications. Within a specific process, an ",(0,s.jsx)(t.strong,{children:"open-file table per-process"})," is used. On the other hand, the OS also keep track the ",(0,s.jsx)(t.strong,{children:"system-wide open-file table"}),", which maintains a global view of all open files and is accessible by all processes in the system."]}),"\n",(0,s.jsxs)(t.p,{children:["When an application opens a file, the operating system scans the system-wide open-file table to determine if the file is already being used. If the file is indeed in use, the operating system creates a new entry in the per-process open-file table that references the existing entry in the system-wide open-file table. This approach helps minimize the overhead of opening a new file. After that, the process is assigned a ",(0,s.jsx)(t.strong,{children:"file descriptor"})," or ",(0,s.jsx)(t.strong,{children:"file handle"}),", which serves as a reference to the opened file."]}),"\n",(0,s.jsx)(t.p,{children:"If the file is not already open, the directory structure is searched, and the FCB associated with the file is copied into the system-wide open-file table. This table not only stores the FCB but also keeps track of the number of processes that have the file open, so that it know when to close the file."}),"\n",(0,s.jsx)(t.p,{children:"After the process receive the file descriptor, either from the existing system-wide open-file or from per-process, the process can now perform file operation through it."}),"\n",(0,s.jsx)(t.h4,{id:"partition--mounting",children:"Partition & Mounting"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Partition"})," is the process of logically separating section of a physical disk drive. When a disk is partitioned, it is divided into multiple sections that can be treated as independent units. Each partition is typically formatted with a file system and can be used to store data and host a file system. Partition help to create boundaries so that the system doesn't overwrite important data when the disk is full."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Mounting"})," is the process of making a file system accessible and associating it with a specific directory (called ",(0,s.jsx)(t.strong,{children:"mount point"}),"). When a file system is mounted, the directory specified as the mount point becomes the entry point for accessing the files and directories within that file system."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, in Windows, mounting a drive is assigning a drive letter. Each storage device or partition is assigned a drive letter (such as ",(0,s.jsx)(t.code,{children:"C:"}),", ",(0,s.jsx)(t.code,{children:"D:"}),", ",(0,s.jsx)(t.code,{children:"E:"}),") to represent it. If a file system is mounted at drive letter ",(0,s.jsx)(t.code,{children:"C:"}),", users can access files within that file system by specifying the drive letter followed by the file path."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Disk partition in Windows",src:i(71030).Z+"",width:"693",height:"586"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://www.minitool.com/partition-disk/volume-vs-partition.html",children:"https://www.minitool.com/partition-disk/volume-vs-partition.html"})]}),"\n",(0,s.jsx)(t.h4,{id:"directory-implementation",children:"Directory Implementation"}),"\n",(0,s.jsxs)(t.p,{children:["Two common approaches are using a ",(0,s.jsx)(t.a,{href:"/data-structures-and-algorithms/linked-list",children:"linear list"})," and a ",(0,s.jsx)(t.a,{href:"/data-structures-and-algorithms/hash-table",children:"hash table"}),"."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Linear List"})," : The directory entries are stored in a sequential list. Each entry contains the file name and a pointer to the corresponding file data. This method is simple to program, but it may result in slower searching, especially for large directories."]}),"\n",(0,s.jsx)(t.p,{children:"To find a specific file, the directory must be searched from the beginning until the desired entry is found. Similar to other operation where traversal is needed. This linear search can be time-consuming, especially if the directory is long. One way to improve is to use a sorted list, it can decrease the average search time by allowing a binary search. Additionally, a sorted list enables producing a sorted directory listing without a separate sorting step."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Hash Table"})," : In this approach, a linear list is still used to store the directory entries, but a hash data structure is employed as well. The hash table takes a value computed from the file name and returns a pointer to the corresponding entry in the linear list. This allows for faster directory search by greatly reducing the search time."]}),"\n",(0,s.jsxs)(t.p,{children:["When a file name needs to be looked up, it is hashed to generate a value within a given range. This value is then used to directly access the corresponding entry in the linear list, avoiding the need for sequential searching. However, ",(0,s.jsx)(t.a,{href:"/data-structures-and-algorithms/hash-table#collision",children:"collisions"})," may occur when two file names hash to the same location, requiring collision resolution techniques, such as using a linked list within each hash entry."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Hash table directory",src:i(86819).Z+"",width:"620",height:"298"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://www.javatpoint.com/os-directory-implementation",children:"https://www.javatpoint.com/os-directory-implementation"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h4,{id:"allocation-methods",children:"Allocation Methods"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Allocation Methods"})," are the methods of allocating space on a storage device to store files in a file system. It involves managing the storage resources and organizing the physical locations where files are stored on the storage medium."]}),"\n",(0,s.jsxs)(t.p,{children:["See ",(0,s.jsx)(t.a,{href:"/operating-system/disk-management#storage-allocation",children:"storage allocation"}),"."]}),"\n",(0,s.jsx)(t.h4,{id:"free-space-management",children:"Free-Space Management"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Free-space Management"})," is the process of tracking and managing available space on a storage device. It involves keeping a record of which areas or blocks of the storage medium are free or allocated to files."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Allocation"})," : When a new file needs to be created, the system identifies and allocates a suitable portion of the storage medium to store the file. The system finds contiguous or non-contiguous set of free blocks that can accommodate the file's size."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Deallocation"})," : When a file is deleted or no longer needed, the system marks the previously allocated blocks as free, making them available for future allocations."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["See ",(0,s.jsx)(t.a,{href:"/operating-system/disk-management#free-space-management",children:"free-space management"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"file-system-example",children:"File System Example"}),"\n",(0,s.jsx)(t.h4,{id:"fat",children:"FAT"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"File Allocation Table (FAT)"})," is a file system used in the old Windows version. FAT has three versions, FAT12, FAT16, and FAT32, where each newer version accommodate larger storage capacities and file sizes."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Structure"})," :"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["The FAT file system organizes data on a storage device into ",(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"/operating-system/disk-management#disk-structure",children:"clusters"})}),", which are contiguous fixed-size units of allocation on the disk."]}),"\n",(0,s.jsxs)(t.li,{children:["The file system consists of four regions : ",(0,s.jsx)(t.strong,{children:"reserved sectors"}),", ",(0,s.jsx)(t.strong,{children:"FAT region"}),", ",(0,s.jsx)(t.strong,{children:"root directory region"}),", and ",(0,s.jsx)(t.strong,{children:"data region"}),"."]}),"\n",(0,s.jsx)(t.li,{children:"Reserved sectors is a portion of the file system that is reserved for the system file, it includes the boot sector, which contains information for booting the system."}),"\n",(0,s.jsx)(t.li,{children:"The FAT is the main component, it is a table that keeps track of the allocation status of each disk block."}),"\n",(0,s.jsx)(t.li,{children:"Root directory stores information about the files and directories located in the root directory."}),"\n",(0,s.jsx)(t.li,{children:"Data region holds the actual data of files and directories, they are divided into cluster which are linked together through the entries in the FAT."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"File Allocation Table"})," :"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"FAT is a table that keeps track of which clusters are allocated to files and directories."}),"\n",(0,s.jsxs)(t.li,{children:["Each entry in the table represents a cluster and contains information about the status of the cluster (such as whether it is free, allocated, or marked as bad). Entries are chained together forming a ",(0,s.jsx)(t.a,{href:"/data-structures-and-algorithms/linked-list",children:"linked list"}),"."]}),"\n",(0,s.jsx)(t.li,{children:"An entry of FAT depends on the version, FAT12 uses 12 bits, FAT16 uses 16 bits, and so on."}),"\n",(0,s.jsxs)(t.li,{children:["For example, an entry in FAT32 can be ",(0,s.jsx)(t.code,{children:"0x00000000"}),", this represents a free cluster, a ",(0,s.jsx)(t.code,{children:"0x0FFFFFFF"})," indicates an end-of-file marker or a special purpose value."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Directory Structure"})," :"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["The file system keep track of ",(0,s.jsx)(t.strong,{children:"directory table"}),", which is a centralized index that contains information about the files stored on the disk. It provides the necessary details to locate and access specific files. The directory table consists of a collection of directory entries, each representing a file or a subdirectory."]}),"\n",(0,s.jsx)(t.li,{children:"Each directory entry contains metadata about a file or a subdirectory, such as the file name, extension, attributes, creation/modification dates, and the starting of the cluster of the file's data."}),"\n",(0,s.jsx)(t.li,{children:"The root directory is located in a fixed position on the storage device, and subsequent directories are stored as separate entries within their parent directories."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"FAT directory entries",src:i(7159).Z+"",width:"521",height:"410"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://codes.pratikkataria.com/file-systems/",children:"top"}),", ",(0,s.jsx)(t.a,{href:"https://networkencyclopedia.com/file-allocation-table-fat/",children:"bottom"})]}),"\n",(0,s.jsx)(t.p,{children:"In the image above, FILE1 starts from the cluster 0002, it continues to cluster 0003 until the cluster 0004, where end of file mark is reached."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Limitations"})," :"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The FAT file system has certain limitations, such as the maximum file size and the maximum number of files supported, which depend on the FAT version and cluster size being used. For example, the original FAT16 file system had limitations on file size (up to 2 GB) and the number of files in the root directory (up to 512 entries)."}),"\n",(0,s.jsxs)(t.li,{children:["In FAT12 and FAT16, the file name is limited to 8 characters for the base name and 3 characters for the extension, to adapt with the limited resource of early days of computing. For example, ",(0,s.jsx)(t.code,{children:"myfile.txt"})," is a valid file name, but ",(0,s.jsx)(t.code,{children:"thisismyverylongfilename.txt"})," would be truncated to ",(0,s.jsx)(t.code,{children:"thisismy.txt"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"To summarize, the FAT file system divides the disk into clusters and uses the FAT table to track the status of each cluster. Clusters store file data and are organized in a chain, the length of which varies depending on the file size. Files are grouped into directories, and information about directories and their entries is stored in the directory table. Each directory entry contains metadata and the starting cluster of the associated data. When reading a file, the system traverses the cluster chain until it reaches a specific end-of-file marker."}),"\n",(0,s.jsx)(t.h4,{id:"ntfs",children:"NTFS"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"New Technology File System (NTFS)"})," is a file system for the newer Windows version. NTFS is a successor of FAT, it introduces support for long file names, advanced file and folder permissions, encryption, compression, and fault tolerance mechanisms."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Access control",src:i(78024).Z+"",width:"409",height:"486"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/NTFS#/media/File:NTPermissions.png",children:"https://en.wikipedia.org/wiki/NTFS#/media/File:NTPermissions.png"})]}),"\n",(0,s.jsx)(t.p,{children:"The image above is the access control lists in Windows 7. Permissions can be assigned to file or directory. They are assigned to a parent folder are automatically inherited by its subfolders and files, reducing the need of assigning permission individually to each file or directory."}),"\n",(0,s.jsxs)(t.p,{children:["NTFS consists three important components ",(0,s.jsx)(t.strong,{children:"partition boot sector (PBS)"}),", ",(0,s.jsx)(t.strong,{children:"master file table (MFT)"}),", and ",(0,s.jsx)(t.strong,{children:"metafiles"}),". The fundamental data structure in NTFS is the MFT. MFT keeps track of the file's metadata and the address of file's blocks, eliminating the need for a separate table like in FAT. If a file is extremely large, it may require multiple MFT records to contain the list of its blocks."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"PBS"})," : Located at the first sector of a disk partition. It contains essential information for the system to ",(0,s.jsx)(t.a,{href:"/operating-system/booting",children:"boot"}),", such as the boot code that initiates the system's startup process, magic number that identifies NTFS file system, and the partition table that identifies the partition structure on the disk. In NTFS, the PBS includes the bootstrap code that loads the operating system's bootloader, which is responsible for starting the operating system."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"NTFS PBS",src:i(50559).Z+"",width:"647",height:"471"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://twitter.com/jaredcatkinson/status/590333209495244801",children:"https://twitter.com/jaredcatkinson/status/590333209495244801"})]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"MFT"})," : MFT is the centralized database that stores metadata about files and directories on an NTFS volume. MFT is a linear sequence of fixed-size 1-KB records, where each entry is file or directory on the volume. It contains information such as file names, timestamps, file attributes, security descriptors, and data allocation. The MFT is used file system operations, it enables quick access to file metadata and efficient management of file data."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"MFT",src:i(78526).Z+"",width:"594",height:"382"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://andreafortuna.org/2017/07/18/how-to-extract-data-and-timeline-from-master-file-table-on-ntfs-filesystem/",children:"https://andreafortuna.org/2017/07/18/how-to-extract-data-and-timeline-from-master-file-table-on-ntfs-filesystem/"})]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Metafiles"})," : NTFS has several special system files that help structure and organize the file system. Some example :"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"$MFT"})," : The Master File Table itself is a meta file that serves as a database of file and directory metadata, as mentioned earlier."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"$MFTMirr"})," : The MFT Mirror is a backup copy of the first few critical records of the MFT."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"$LogFile"})," : The Log File is used for transaction logging in NTFS. It records changes made to the file system before they are committed, allowing for system recovery when unexpected events such as power failures occurs."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"$Bitmap"})," : The Bitmap file keeps track of the allocation status of clusters on the disk, indicating which clusters are free and which are in use."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"$Volume"})," : The Volume file stores information about the NTFS volume itself, including its label, version, serial number, and other volume-specific details."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h4,{id:"ext",children:"ext"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Extended file system (ext)"})," is a file system for ",(0,s.jsx)(t.a,{href:"/operating-system/linux-kernel",children:"Linux kernel"}),", it consists of four versions, ext1, ext2, ext3, and the newest ext4. All of them are designed to be backward compatible of each other."]}),"\n",(0,s.jsx)(t.h5,{id:"ext2",children:"ext2"}),"\n",(0,s.jsx)(t.p,{children:"Starting from the ext2 :"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Disk Layout"})," : ext2 organizes data on the disk into fixed-size blocks. The default block size is 4 KB, although larger block sizes can be used. The file system divides the disk into block groups, each containing a fixed number of blocks. Each block group has its own metadata to track file system structures and data within that group."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Inodes"})," : ",(0,s.jsx)(t.strong,{children:"Inode (index node)"})," is a data structure in Unix-like system for describing file-system object, such as file or directory. An inode contains metadata about the file, including file permissions, ownership information, timestamps, and pointers to the data blocks that store the file's content. Inodes are arranged in a table structure."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Inode pointer structure",src:i(25915).Z+"",width:"592",height:"440"}),(0,s.jsx)(t.br,{}),"\n","The inode can contain pointer to the file's content (direct data blocks), or a pointer to another block that contains pointer to the actual content (indirect data blocks).",(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Inode_pointer_structure",children:"https://en.wikipedia.org/wiki/Inode_pointer_structure"})]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Directory"})," : Directories in ext2 are organized as special files. A directory file contains a list of entries, where each entry represents a file or a subdirectory within that directory. Each entry consists of a name and an inode number that points to the corresponding inode."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Directory entry in ext",src:i(27157).Z+"",width:"544",height:"344"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://premaseem.wordpress.com/2016/02/14/what-is-inode-in-linux-unit/",children:"https://premaseem.wordpress.com/2016/02/14/what-is-inode-in-linux-unit/"})]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Block Allocation"})," : ext2 uses a block allocation bitmap to track the allocation status of data blocks. The bitmap keeps track of free blocks and allocated blocks within the file system. When a new file is created or an existing file is extended, ext2 searches for free blocks using the allocation bitmap and assigns them to the file. When a file is deleted in ext2, its inode and data blocks are marked as free in the allocation bitmap, making them available for reuse."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h5,{id:"ext3",children:"ext3"}),"\n",(0,s.jsxs)(t.p,{children:["ext3 brought several improvements over ext2, such as the ",(0,s.jsx)(t.strong,{children:"journaling system"}),". The journaling system logs changes to the file system before committing them to the main file system structures. This journaling feature ensures that the file system can recover after a crash or an unexpected system shutdown."]}),"\n",(0,s.jsx)(t.p,{children:"There are three levels of journaling :"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Journal (lowest risk)"})," : In data journaling, both metadata and file data modifications are logged in the journal before being committed to the file system. Can suffer from performance overhead due to the increased number of disk writes required."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Ordered (medium risk)"})," : Only metadata are logged in the journal, after it is logged, file content is modified after."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Writeback (highest risk)"})," : This level is similar to ordered, but logging metadata and writing the file content is done asynchronously. This means that there is a possibility that file content writing is completed first, and a system crash occurs before the metadata is written."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Journaling system",src:i(44541).Z+"",width:"427",height:"199"}),(0,s.jsx)(t.br,{}),"\n","Source : ",(0,s.jsx)(t.a,{href:"https://foxutech.com/journaling-filesystem/",children:"https://foxutech.com/journaling-filesystem/"})]}),"\n",(0,s.jsx)(t.h5,{id:"ext4",children:"ext4"}),"\n",(0,s.jsx)(t.p,{children:"ext4 supports larger file systems and file sizes compared to ext3. ext4 allows storage capacities up to 1 exabyte (1 billion gigabytes) and individual file sizes of up to 16 terabytes. ext4 does not limit the number of subdirectories in a single directory, in contrast, ext3 a directory can have at most 32,000 subdirectories."}),"\n",(0,s.jsxs)(t.p,{children:["ext4 enhances the allocation algorithms, it introduces ",(0,s.jsx)(t.strong,{children:"multiblock allocation"}),", which allows for allocation of multiple blocks at once. In contrast, ext3 calls block allocator, once for each block."]}),"\n",(0,s.jsxs)(t.p,{children:["ext4 implements ",(0,s.jsx)(t.strong,{children:"delayed allocation"}),", also known as ",(0,s.jsx)(t.strong,{children:"allocate-on-flush"}),". This technique improves write performance by delaying the allocation and writing of data blocks until they are actually needed. This technique allow writing larger amount of data at once, reducing unnecessary disk I/O operations."]})]})}function d(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},63892:(e,t,i)=>{i.d(t,{Z:()=>s});const s=i.p+"assets/images/acyclic-graph-2190ebe3c249ae7d880fab20e6f9e986.png"},7159:(e,t,i)=>{i.d(t,{Z:()=>s});const s=i.p+"assets/images/directory-entries-65cb79df0af3e54030f0caf2e33fc1f1.png"},89103:(e,t,i)=>{i.d(t,{Z:()=>s});const s=i.p+"assets/images/directory-levels-edb0cf36ba9e44ed0c0350f0a5dd9544.png"},36424:(e,t,i)=>{i.d(t,{Z:()=>s});const s=i.p+"assets/images/directory-28cd0285f1ddba700e52d95d80ca149f.png"},71030:(e,t,i)=>{i.d(t,{Z:()=>s});const s=i.p+"assets/images/disk-partition-8f62e80fb1803a553a86eb95c8738371.png"},27157:(e,t,i)=>{i.d(t,{Z:()=>s});const s=i.p+"assets/images/ext-directory-entry-79f31db3e8324db006f5984a3433cb9a.png"},1050:(e,t,i)=>{i.d(t,{Z:()=>s});const s=i.p+"assets/images/file-content-79a88ccb0d9c967887c7e5661fdd4be6.png"},99388:(e,t,i)=>{i.d(t,{Z:()=>s});const s=i.p+"assets/images/file-control-block-2a5c8ae1e1d24045a7e407884f424f62.png"},89697:(e,t,i)=>{i.d(t,{Z:()=>s});const s=i.p+"assets/images/file-security-7e3bce75c4de146108a3b0bfbb231350.png"},53657:(e,t,i)=>{i.d(t,{Z:()=>s});const s=i.p+"assets/images/file-system-structure-8d40ff83f35500881b5b340661dfdf3e.png"},47280:(e,t,i)=>{i.d(t,{Z:()=>s});const s=i.p+"assets/images/file-types-61b83a993b37652cd54bfc47c2185ae3.png"},38571:(e,t,i)=>{i.d(t,{Z:()=>s});const s=i.p+"assets/images/general-graph-9e9893b042918a33174af9c8dadfaf00.png"},86819:(e,t,i)=>{i.d(t,{Z:()=>s});const s=i.p+"assets/images/hash-table-directory-bb23f62f00385048ec321b39887459ea.png"},25915:(e,t,i)=>{i.d(t,{Z:()=>s});const s=i.p+"assets/images/inode-c5595815feed62f18ffc558e4e42198e.png"},44541:(e,t,i)=>{i.d(t,{Z:()=>s});const s=i.p+"assets/images/journaling-1e8a57d3c6b4c662d909a4c85a45ce3e.png"},3339:(e,t,i)=>{i.d(t,{Z:()=>s});const s=i.p+"assets/images/links-5a7706398e722b143dbb260e9e1a12b5.png"},78526:(e,t,i)=>{i.d(t,{Z:()=>s});const s=i.p+"assets/images/mft-f5f99b7915fb2389907e7d5799cac8b2.png"},78024:(e,t,i)=>{i.d(t,{Z:()=>s});const s=i.p+"assets/images/ntfs-access-control-4a36286270b6d3cc81a9b6c8d7db00a4.png"},50559:(e,t,i)=>{i.d(t,{Z:()=>s});const s=i.p+"assets/images/ntfs-pbs-ae618db4be69440d1eb6ab57c78c85ef.png"},11151:(e,t,i)=>{i.d(t,{Z:()=>o,a:()=>a});var s=i(67294);const n={},r=s.createContext(n);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);