"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[731],{28790:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>d,contentTitle:()=>n,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var s=t(85893),i=t(11151);const a={slug:"/data-structures-and-algorithms/traversal",id:"traversal",title:"Traversal",description:"Traversal"},n=void 0,o={id:"data-structures-and-algorithms/traversal/traversal",title:"Traversal",description:"Traversal",source:"@site/docs/data-structures-and-algorithms/16-traversal/traversal.md",sourceDirName:"data-structures-and-algorithms/16-traversal",slug:"/data-structures-and-algorithms/traversal",permalink:"/cs-notes/data-structures-and-algorithms/traversal",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/data-structures-and-algorithms/16-traversal/traversal.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1710489965,formattedLastUpdatedAt:"Mar 15, 2024",frontMatter:{slug:"/data-structures-and-algorithms/traversal",id:"traversal",title:"Traversal",description:"Traversal"},sidebar:"sidebar",previous:{title:"Divide And Conquer",permalink:"/cs-notes/data-structures-and-algorithms/divide-and-conquer"},next:{title:"Backtracking",permalink:"/cs-notes/data-structures-and-algorithms/backtracking"}},d={},l=[{value:"Graph Traversal",id:"graph-traversal",level:3},{value:"Depth-First Search (DFS)",id:"depth-first-search-dfs",level:4},{value:"Breadth-First Search (BFS)",id:"breadth-first-search-bfs",level:4},{value:"Tree Traversal",id:"tree-traversal",level:3},{value:"Inorder Traversal",id:"inorder-traversal",level:4},{value:"Preorder Traversal",id:"preorder-traversal",level:4},{value:"Postorder Traversal",id:"postorder-traversal",level:4}];function h(e){const r={a:"a",admonition:"admonition",br:"br",code:"code",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Main Source :"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Graph_traversal",children:"Graph traversal - Wikipedia"})})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Tree_traversal",children:"Tree traversal - Wikipedia"})})}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Traversal"})," refers to the process of visiting and accessing each element or node in a data structure, such as linked list, tree, or graph. The purpose of traversal is to perform some operation on each element or node, such as reading its value, modifying it, or performing other specific task."]}),"\n",(0,s.jsxs)(r.p,{children:["For a ",(0,s.jsx)(r.a,{href:"/data-structures-and-algorithms/linked-list",children:"singly linked list"}),", traversal involves starting at the head node and following the links from one node to the next until the end of the list is reached. This is typically done using a loop or ",(0,s.jsx)(r.a,{href:"/data-structures-and-algorithms/recursion#linked-list-traversal",children:"recursion"}),"."]}),"\n",(0,s.jsx)(r.h3,{id:"graph-traversal",children:"Graph Traversal"}),"\n",(0,s.jsxs)(r.p,{children:["Graph traversal refers to the process of exploring nodes or vertices in a ",(0,s.jsx)(r.a,{href:"/data-structures-and-algorithms/graph",children:"graph data structure"}),". There are two commonly used methods for graph traversal: ",(0,s.jsx)(r.strong,{children:"depth-first search (DFS)"})," and ",(0,s.jsx)(r.strong,{children:"breadth-first search (BFS)"}),"."]}),"\n",(0,s.jsx)(r.h4,{id:"depth-first-search-dfs",children:"Depth-First Search (DFS)"}),"\n",(0,s.jsx)(r.p,{children:"DFS is a graph traversal algorithm that explores vertices as deeply as possible. It starts at a given vertex, visits one of its neighbors, and continues to explore that neighbor's neighbors until it reaches a dead end. After reaching dead end, it will come back to the previous vertex and continue to visit that vertex neighbor until it reaches a dead end again."}),"\n",(0,s.jsx)(r.p,{children:"Here is the pseudocode :"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"DFS(graph, vertex, visited):\n    visited add vertex                              // mark as visited\n    process(vertex)                                 // process it as needed\n\n    for neighbor in the neighbors of graph(vertex): // visit each of the neighbor\n        if neighbor is not in visited:              // only visit the unvisited\n            DFS(graph, neighbor, visited)           // recursive call\n"})}),"\n",(0,s.jsxs)(r.p,{children:["In DFS, we will visit a vertex as deep as possible, each vertex have a neighbor, and that neighbor will have another vertex. After reaching dead end, we will continue exploring the neighbors of the previous vertex. This behavior aligns closely with ",(0,s.jsx)(r.a,{href:"/data-structures-and-algorithms/stack",children:"stack"})," and ",(0,s.jsx)(r.a,{href:"/data-structures-and-algorithms/recursion",children:"recursion"}),", therefore we can use recursion and take advantage of its ",(0,s.jsx)(r.a,{href:"/data-structures-and-algorithms/recursion#call-stack",children:"call stack"})," to implement DFS."]}),"\n",(0,s.jsxs)(r.p,{children:["It is possible that the graph we are traversing consists of a loop (",(0,s.jsx)(r.a,{href:"/data-structures-and-algorithms/graph#cyclic",children:"cyclic graph"}),"). If we keep traversing it mindlessly, we may never finish our recursion function, which will result in stack overflow error. To mitigate this, we will have another data structure called ",(0,s.jsx)(r.code,{children:"visited"}),", which will keep track the visited vertex. We will only traverse to unvisited vertex. The data structure of ",(0,s.jsx)(r.code,{children:"visited"})," can be a ",(0,s.jsx)(r.a,{href:"/data-structures-and-algorithms/set",children:"set"})," data structure, to ensure fast retrieval of element and to store only unique element."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.img,{alt:"DFS GIF",src:t(49177).Z+"",width:"500",height:"500"}),(0,s.jsx)(r.br,{}),"\n","Source : ",(0,s.jsx)(r.a,{href:"https://en.m.wikipedia.org/wiki/File:Depth-First-Search.gif",children:"https://en.m.wikipedia.org/wiki/File:Depth-First-Search.gif"})]}),"\n",(0,s.jsx)(r.h4,{id:"breadth-first-search-bfs",children:"Breadth-First Search (BFS)"}),"\n",(0,s.jsxs)(r.p,{children:["BFS, also called ",(0,s.jsx)(r.strong,{children:"level-order search"}),", is a graph traversal algorithm that explores all vertices of a graph at the same level before moving to the next level. It starts at a given vertex and explores all its neighboring vertices before moving on to their neighbors."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"BFS(graph, start):\n    visited = set()                // Keep track of visited vertices\n    queue = Queue()                // Initialize an empty queue\n    queue.enqueue(start)           // Enqueue the starting vertex\n\n    while queue is not empty:\n        vertex = queue.dequeue()   // Dequeue a vertex from the front of the queue\n\n        if vertex is not in visited:\n            visited.add(vertex)    // Mark the vertex as visited\n            process(vertex)        // Process the vertex as needed\n\n            // Enqueue unvisited neighbors\n            for neighbor in graph.adjacentVertices(vertex):\n                if neighbor is not in visited:\n                    queue.enqueue(neighbor)\n"})}),"\n",(0,s.jsxs)(r.p,{children:["BFS doesn't use recursion to traverse, it instead uses a ",(0,s.jsx)(r.a,{href:"/data-structures-and-algorithms/queue",children:"queue data structure"})," to keep track all the neighbors in the current level."]}),"\n",(0,s.jsx)(r.p,{children:"The algorithm starts by enqueuing the starting vertex into the queue and marking it as visited. It then enters a loop where it repeatedly dequeues a vertex from the front of the queue, marks it as visited, process it depending on the task, and enqueues its unvisited neighbors. This process continues until the queue becomes empty, indicating that all vertices have been visited."}),"\n",(0,s.jsx)(r.admonition,{type:"tip",children:(0,s.jsx)(r.p,{children:'The queue act like a "to-do list" to keep track all the node for us to visit later.'})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.img,{alt:"BFS GIF",src:t(58301).Z+"",width:"500",height:"500"}),(0,s.jsx)(r.br,{}),"\n","Source : ",(0,s.jsx)(r.a,{href:"https://commons.wikimedia.org/wiki/File:Breadth-First-Search-Algorithm.gif",children:"https://commons.wikimedia.org/wiki/File:Breadth-First-Search-Algorithm.gif"})]}),"\n",(0,s.jsx)(r.h3,{id:"tree-traversal",children:"Tree Traversal"}),"\n",(0,s.jsxs)(r.p,{children:["As we know, a ",(0,s.jsx)(r.a,{href:"/data-structures-and-algorithms/tree",children:"tree"})," data structure is a special case of graph where it is undirected and acyclic. We can also use DFS and BFS to traverse a tree (the previous GIF is literally a graph organized tree structure)."]}),"\n",(0,s.jsx)(r.p,{children:"Both BFS and DFS are a general graph traversal algorithm that can be applied on arbitrary graph and tree. Depending on the structure, the algorithm should be similar."}),"\n",(0,s.jsxs)(r.p,{children:["In tree traversal using DFS, there are specific orders of visiting and processing the nodes in a tree, which are ",(0,s.jsx)(r.strong,{children:"inorder"}),", ",(0,s.jsx)(r.strong,{children:"preorder"}),", and ",(0,s.jsx)(r.strong,{children:"postorder"}),". Let's assume we are traversing a binary tree."]}),"\n",(0,s.jsx)(r.h4,{id:"inorder-traversal",children:"Inorder Traversal"}),"\n",(0,s.jsx)(r.p,{children:"In inorder traversal of a binary tree, we will visit the left subtree, then the current node, and finally the right subtree. By visiting the left subtree, it means we are going to visit all the child in the left subtree in recursive manner (DFS)."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"function DFS(node):\n    if node is not null:\n        DFS(node.left)\n        visit(node)\n        DFS(node.right)\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.img,{alt:"Inorder traversal",src:t(81263).Z+"",width:"513",height:"398"}),(0,s.jsx)(r.br,{}),"\n","Source : ",(0,s.jsx)(r.a,{href:"https://commons.wikimedia.org/wiki/File:Inorder-traversal.gif",children:"https://commons.wikimedia.org/wiki/File:Inorder-traversal.gif"})," (red means all the child has been visited)"]}),"\n",(0,s.jsx)(r.h4,{id:"preorder-traversal",children:"Preorder Traversal"}),"\n",(0,s.jsx)(r.p,{children:"In preorder traversal, we visit the current node first, then the left subtree, and finally the right subtree."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"function DFS(node):\n    if node is not null:\n        visit(node)\n        DFS(node.left)\n        DFS(node.right)\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.img,{alt:"Preorder traversal",src:t(30794).Z+"",width:"513",height:"398"}),(0,s.jsx)(r.br,{}),"\n","Source : ",(0,s.jsx)(r.a,{href:"https://commons.wikimedia.org/wiki/File:Preorder-traversal.gif",children:"https://commons.wikimedia.org/wiki/File:Preorder-traversal.gif"})]}),"\n",(0,s.jsx)(r.h4,{id:"postorder-traversal",children:"Postorder Traversal"}),"\n",(0,s.jsx)(r.p,{children:"In postorder traversal, we visit the left subtree first, then the right subtree, and finally the current node."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"function DFS(node):\n    if node is not null:\n        DFS(node.left)\n        DFS(node.right)\n        visit(node)\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.img,{alt:"Postorder traversal",src:t(31865).Z+"",width:"513",height:"398"}),(0,s.jsx)(r.br,{}),"\n","Source : ",(0,s.jsx)(r.a,{href:"https://commons.wikimedia.org/wiki/File:Postorder-traversal.gif",children:"https://commons.wikimedia.org/wiki/File:Postorder-traversal.gif"})]}),"\n",(0,s.jsx)(r.p,{children:"Depending on the task, the order of visiting nodes matters. For example, inorder traversal can be used to visits the nodes in ascending order in the case of a binary search tree."})]})}function c(e={}){const{wrapper:r}={...(0,i.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},58301:(e,r,t)=>{t.d(r,{Z:()=>s});const s=t.p+"assets/images/bfs-ce715ca92ed78b502139df8c80d5d367.gif"},49177:(e,r,t)=>{t.d(r,{Z:()=>s});const s=t.p+"assets/images/dfs-a03c07b1db991d16679cd679b0bd14d1.gif"},81263:(e,r,t)=>{t.d(r,{Z:()=>s});const s=t.p+"assets/images/inorder-67ab9c3d185e3dcc68fb3302fa2bf696.gif"},31865:(e,r,t)=>{t.d(r,{Z:()=>s});const s=t.p+"assets/images/postorder-d984967b311feb9e6ea8dd7bdacb17eb.gif"},30794:(e,r,t)=>{t.d(r,{Z:()=>s});const s=t.p+"assets/images/preorder-983a64986ac858cb2c2951a4682d8d79.gif"},11151:(e,r,t)=>{t.d(r,{Z:()=>o,a:()=>n});var s=t(67294);const i={},a=s.createContext(i);function n(e){const r=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:n(e.components),s.createElement(a.Provider,{value:r},e.children)}}}]);