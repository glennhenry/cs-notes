"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[271],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>d});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=n.createContext({}),l=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=l(a),m=r,d=u["".concat(c,".").concat(m)]||u[m]||h[m]||i;return a?n.createElement(d,s(s({ref:t},p),{},{components:a})):n.createElement(d,s({ref:t},p))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=m;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o[u]="string"==typeof e?e:r,s[1]=o;for(var l=2;l<i;l++)s[l]=a[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},22943:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var n=a(87462),r=(a(67294),a(3905));const i={slug:"/computer-and-programming-fundamentals/concurrency-and-parallelism",id:"concurrency-and-parallelism",title:"Concurrency & Parallelism",description:"Concurrency & Parallelism"},s=void 0,o={unversionedId:"computer-and-programming-fundamentals/concurrency-and-parallelism/concurrency-and-parallelism",id:"computer-and-programming-fundamentals/concurrency-and-parallelism/concurrency-and-parallelism",title:"Concurrency & Parallelism",description:"Concurrency & Parallelism",source:"@site/docs/computer-and-programming-fundamentals/14-concurrency-and-parallelism/concurrency-and-parallelism.md",sourceDirName:"computer-and-programming-fundamentals/14-concurrency-and-parallelism",slug:"/computer-and-programming-fundamentals/concurrency-and-parallelism",permalink:"/cs-notes/computer-and-programming-fundamentals/concurrency-and-parallelism",draft:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/computer-and-programming-fundamentals/14-concurrency-and-parallelism/concurrency-and-parallelism.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1699702544,formattedLastUpdatedAt:"Nov 11, 2023",frontMatter:{slug:"/computer-and-programming-fundamentals/concurrency-and-parallelism",id:"concurrency-and-parallelism",title:"Concurrency & Parallelism",description:"Concurrency & Parallelism"},sidebar:"sidebar",previous:{title:"Query Language",permalink:"/cs-notes/computer-and-programming-fundamentals/query-language"},next:{title:"Compilation",permalink:"/cs-notes/computer-and-programming-fundamentals/compilation"}},c={},l=[{value:"Concurrency",id:"concurrency",level:3},{value:"Process &amp; Thread",id:"process--thread",level:3},{value:"Process",id:"process",level:4},{value:"Thread",id:"thread",level:4},{value:"Process vs Thread",id:"process-vs-thread",level:4},{value:"Concurrent &amp; Asynchronous Programming",id:"concurrent--asynchronous-programming",level:3},{value:"Multithreading, Multiprocessing, Multitasking",id:"multithreading-multiprocessing-multitasking",level:4},{value:"Multithreading",id:"multithreading",level:5},{value:"Multiprocessing",id:"multiprocessing",level:5},{value:"Multitasking",id:"multitasking",level:5},{value:"Summary",id:"summary",level:5},{value:"Coroutine",id:"coroutine",level:4},{value:"Callbacks",id:"callbacks",level:4},{value:"Future, Promise, Async Await",id:"future-promise-async-await",level:4},{value:"Reactive Programming",id:"reactive-programming",level:3},{value:"Stream, Channel",id:"stream-channel",level:4},{value:"Observable, Consumer, Subscribe",id:"observable-consumer-subscribe",level:4},{value:"Terminology",id:"terminology",level:3},{value:"Race Condition",id:"race-condition",level:4},{value:"Thread Lock",id:"thread-lock",level:4},{value:"Thread Safe",id:"thread-safe",level:4},{value:"Deadlock",id:"deadlock",level:4},{value:"Thread Pool",id:"thread-pool",level:4}],p={toc:l},u="wrapper";function h(e){let{components:t,...i}=e;return(0,r.kt)(u,(0,n.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Main Source :")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("a",{parentName:"strong",href:"https://en.wikipedia.org/wiki/Process_(computing)"},"Process (computing) - Wikipedia"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("a",{parentName:"strong",href:"https://en.wikipedia.org/wiki/Thread_(computing)"},"Thread (computing) - Wikipedia"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("a",{parentName:"strong",href:"https://en.wikipedia.org/wiki/Multiprocessing"},"Multiprocessing - Wikipedia"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("a",{parentName:"strong",href:"https://elizarov.medium.com/blocking-threads-suspending-coroutines-d33e11bf4761"},"Blocking threads, suspending coroutines by Roman Elizarov - Medium"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("a",{parentName:"strong",href:"https://kotlinlang.org/docs/async-programming.html"},"Asynchronous programming techniques - Kotlin Docs"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("a",{parentName:"strong",href:"https://stackoverflow.com/questions/34510/what-is-a-race-condition"},"What is a race condition? - stackoverflow"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("a",{parentName:"strong",href:"https://www.google.com"},"Some simple Google search")))),(0,r.kt)("h3",{id:"concurrency"},"Concurrency"),(0,r.kt)("p",null,"Computer executes tasks one by one sequentially, often times some tasks require a lot of time to finish. For example, in a web application like e-commerce, our browser will need to load some data from the server to display it to us. If the server takes a long time to process the request or the network connection is slow, it can result in a noticeable delay before the data is available to the browser. Imagine if there are more tasks than just requesting data to server, such as processing and transforming the data. If computer can only execute one task at a time, then it may take a long time."),(0,r.kt)("p",null,"Many techniques can be employed to mitigate this issue. ",(0,r.kt)("strong",{parentName:"p"},"Concurrency")," is the ability of a system to handle multiple tasks or processes simultaneously. Instead of waiting all the data to be received and then process it one by one, we can download the data and process it simultaneously."),(0,r.kt)("p",null,"Another example is a mobile app that loads data from the phone's storage. The app is supposed to display loading animation in the screen, without the ability of processing multiple task simultaneously, the screen may freeze because the system is focusing on retrieving data from the storage and can't update the animation."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Concurrency illustration, multiple system doing a single task simultaneously",src:a(85593).Z,width:"976",height:"293"})),(0,r.kt)("h3",{id:"process--thread"},"Process & Thread"),(0,r.kt)("h4",{id:"process"},"Process"),(0,r.kt)("p",null,"A ",(0,r.kt)("strong",{parentName:"p"},"process")," is an instance of a running program. A process encapsulates the running program's code, data, and resources required to execute a program. Each process has its own memory space and system resources. Process is managed by the ",(0,r.kt)("a",{parentName:"p",href:"/computer-and-programming-fundamentals/operating-system"},"operating system"),", and is independent with each other process, they are executed in its own isolated memory space."),(0,r.kt)("p",null,"Process has its own memory space and system resource, they are not directly accessible or affected by another process. In order to communicate with other processes, a mechanism called ",(0,r.kt)("strong",{parentName:"p"},"Inter-Process Communication (IPC)")," is employed."),(0,r.kt)("p",null,"Operating system will keep track the state of each process, a process will run through several states :"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Created")," : When a process is created or initialized, the process is being set up by the operating system, allocating resources such as memory and initializing data structures."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Waiting")," : A process in the waiting state is prepared but is waiting to be executed by the operating system scheduler."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Running")," : When a process is selected by the scheduler and is executing on the CPU, it is in the running state. In this state, the process is actively using the CPU to execute its instructions. Only one process can be in the running state at a given time on a single CPU core."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Blocked")," : If a process is unable to proceed further and must wait for an event or resource, it enters the blocked state. For example, if a process is waiting for user input such as selecting file, it will be blocked and temporarily suspended until the required event occurs."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Terminated")," : When a process finishes its execution or is explicitly terminated by the operating system or a user, it enters the terminated state. In this state, the process is no longer active, and its resources are released by the operating system.")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Computer workflow of executing a program",src:a(31320).Z,width:"911",height:"517"}),(0,r.kt)("br",{parentName:"p"}),"\n","Source : ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Process_%28computing%29#/media/File:Concepts-_Program_vs._Process_vs._Thread.jpg"},"https://en.wikipedia.org/wiki/Process_%28computing%29#/media/File:Concepts-_Program_vs._Process_vs._Thread.jpg")),(0,r.kt)("h4",{id:"thread"},"Thread"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Thread"),", on the other hand, is a basic unit of execution within a process. A thread is a single sequence of instruction that can be executed by the CPU. Thread exists inside a process, they share the same memory space and resources of the process that created them."),(0,r.kt)("p",null,"A single process can have multiple thread to execute multiple task, the technique is called ",(0,r.kt)("a",{parentName:"p",href:"/computer-and-programming-fundamentals/concurrency-and-parallelism#multithreading--multiprocessing"},"multithreading"),". In a process where multiple thread exist, they can work together to complete a task as they share the same memory space."),(0,r.kt)("h4",{id:"process-vs-thread"},"Process vs Thread"),(0,r.kt)("p",null,"The obvious difference between them is that a process is the running program, while a thread is the one that executes tasks within that program. The process owns memory and system resource, while thread do not have their own and access the one owned by the process. Each process has at least one thread, called the ",(0,r.kt)("strong",{parentName:"p"},"main thread"),", which starts executing the program from its entry point."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Process vs Thread",src:a(82493).Z,width:"322",height:"204"}),(0,r.kt)("br",{parentName:"p"}),"\n","Source myself, inspired by : ",(0,r.kt)("a",{parentName:"p",href:"https://www.java67.com/2012/12/what-is-difference-between-thread-vs-process-java.html"},"https://www.java67.com/2012/12/what-is-difference-between-thread-vs-process-java.html")),(0,r.kt)("h3",{id:"concurrent--asynchronous-programming"},"Concurrent & Asynchronous Programming"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Concurrent Programming")," is a programming paradigm that involves executing multiple tasks or processes concurrently. It aims to make efficient use of system resources by allowing tasks to overlap in execution."),(0,r.kt)("p",null,"In traditional programming, a task is executed sequentially and the program waits for each task to finish before moving on to the next one, this is called ",(0,r.kt)("strong",{parentName:"p"},"synchronous programming"),". On the other hand, ",(0,r.kt)("strong",{parentName:"p"},"asynchronous programming")," is a programming paradigm where the program continue doing other task instead of just waiting for a specific task to complete."),(0,r.kt)("p",null,"There are many techniques to achieve concurrency and asynchronous."),(0,r.kt)("h4",{id:"multithreading-multiprocessing-multitasking"},"Multithreading, Multiprocessing, Multitasking"),(0,r.kt)("h5",{id:"multithreading"},"Multithreading"),(0,r.kt)("p",null,"A process can have multiple threads, ",(0,r.kt)("strong",{parentName:"p"},"multithreading")," refers to the ability of a program or process to execute multiple threads concurrently within a single process. It allows for the concurrent execution of multiple tasks within the same program, to improve performance and resource utilization."),(0,r.kt)("p",null,"Threads within the same process share the same memory space. This means they can access and modify shared data and resources, enabling communication and coordination between threads. This make it possible for thread to substitute for each other and continue each other task."),(0,r.kt)("p",null,"Threads are used in the case where multiple tasks need to be performed, such as the mobile application scenario earlier. One thread may request data to a server, another thread processes the data on the fly, and another thread updates the screen to display animation."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Multithreading",src:a(17230).Z,width:"680",height:"207"}),(0,r.kt)("br",{parentName:"p"}),"\n","Source : ",(0,r.kt)("a",{parentName:"p",href:"https://www3.ntu.edu.sg/home/ehchua/programming/java/j5e_multithreading.html"},"https://www3.ntu.edu.sg/home/ehchua/programming/java/j5e_multithreading.html")),(0,r.kt)("h5",{id:"multiprocessing"},"Multiprocessing"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Multiprocessing")," is a technique that takes advantages of computer with multiple CPU or processor to execute tasks simultaneously. Unlike multithreading, which involves multiple threads within a single process, multiprocessing utilizes multiple processes that can run independently and concurrently."),(0,r.kt)("p",null,"In multiprocessing, each process will have different memory and system resource. They are also not able to access each other resource directly, to be able to execute a single task with multiple process, they will need a proper coordination through the ",(0,r.kt)("strong",{parentName:"p"},"IPC")," mechanism."),(0,r.kt)("p",null,"Multiprocessing can be beneficial for computer that has multiple cores, it can significantly improve performance. However, it can be heavier and tend to consume more power. On the other hand, creating and managing threads in multithreading is generally faster and more lightweight compared to creating separate processes. Thread can also coordinate and communicate with each other easily because they share the same memory."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Multiprocessing",src:a(8003).Z,width:"427",height:"327"}),(0,r.kt)("br",{parentName:"p"}),"\n","Source : ",(0,r.kt)("a",{parentName:"p",href:"https://www.shiksha.com/online-courses/articles/difference-between-multiprocessing-and-multiprogramming/"},"https://www.shiksha.com/online-courses/articles/difference-between-multiprocessing-and-multiprogramming/")),(0,r.kt)("h5",{id:"multitasking"},"Multitasking"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Multitasking")," refers to the ability of an operating system to execute multiple processes concurrently. The operating system gives each process CPU processing time. The CPU switches rapidly between tasks, each task will have small-time execution. This switching occurs so quickly that it creates the perception of simultaneous execution."),(0,r.kt)("p",null,"For example, in our desktop, we can run multiple application at the same time. This is actually an illusion, the operating system rapidly switches between these processes, giving each one a small portion of CPU time to make it appear simultaneously."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Multitasking",src:a(61955).Z,width:"1600",height:"900"}),(0,r.kt)("br",{parentName:"p"}),"\n","Source : ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Computer_multitasking#/media/File:Desktop-Linux-Mint.png"},"https://en.wikipedia.org/wiki/Computer_multitasking#/media/File:Desktop-Linux-Mint.png")),(0,r.kt)("h5",{id:"summary"},"Summary"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Multithreading")," : The use of multiple thread within a single process."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Multiprocessing")," : The use of multiple CPU cores to create multiple process."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Multitasking")," : The concurrent execution of multiple process.")),(0,r.kt)("p",null,"All of them are technique to concurrently execute task."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Comparison of multithreading, multiprocessing, and multitasking",src:a(61058).Z,width:"985",height:"668"}),(0,r.kt)("br",{parentName:"p"}),"\n","Source : ",(0,r.kt)("a",{parentName:"p",href:"https://www.javatpoint.com/process-vs-thread"},"Single vs Multi-threaded"),", ",(0,r.kt)("a",{parentName:"p",href:"https://www.linkedin.com/pulse/demystifying-multithreading-multiprocessing-python-somasundaram"},"Multiprocessing vs Multithreading"),", ",(0,r.kt)("a",{parentName:"p",href:"https://subscription.packtpub.com/book/programming/9781787121706/2/ch02lvl1sec13/defining-multithreading"},"Multiprocessing vs Multitasking vs Multithreading")),(0,r.kt)("h4",{id:"coroutine"},"Coroutine"),(0,r.kt)("p",null,"In a long operation such as waiting for I/O event or doing computation intensive task, the specific thread which executes the task will be ",(0,r.kt)("strong",{parentName:"p"},"blocked"),". When a thread is blocked, it means the thread is unable to proceed with its execution and is waiting for a particular operation to complete. When a thread is blocked by an I/O operation, it does not consume CPU resources because it is not actively executing instructions. In contrast, when a thread is doing a long computation, it utilizes CPU resources as it performs calculations and executes instructions."),(0,r.kt)("p",null,"Thread shouldn't be blocked, one reason is because they are expensive, they require memory to store its own stack space to store execution-related information and the operating system needs to manage them, which result in additional computation. Another reason is in a scenario where application is included with UI (user interface). UI should be responsible to react at user interaction (e.g., updating screen when user click on something). However, because the thread is currently blocked, it can't respond to UI event which will result in a poor user experience."),(0,r.kt)("p",null,"One way to mitigate this thread blocking is ",(0,r.kt)("strong",{parentName:"p"},"coroutine"),". ",(0,r.kt)("strong",{parentName:"p"},"Coroutine")," is a unit of execution that can be ",(0,r.kt)("strong",{parentName:"p"},"cooperatively scheduled"),", meaning it can be paused and resumed at specific points in its execution. We call a piece of code that can be paused and resumed later on ",(0,r.kt)("strong",{parentName:"p"},"suspendable"),"."),(0,r.kt)("p",null,"When a piece of code can be suspended, it means that it can yield control to other tasks without blocking the thread it is running on. Instead of the thread waiting for specific task to complete, coroutine allows it to perform another task without waiting. When the task is complete, the thread will continue its previous task."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Coroutine illustration",src:a(20889).Z,width:"659",height:"202"}),(0,r.kt)("br",{parentName:"p"}),"\n","Source : ",(0,r.kt)("a",{parentName:"p",href:"https://blog.adacore.com/coroutines-in-ada-a-clean-but-heavy-implementation"},"https://blog.adacore.com/coroutines-in-ada-a-clean-but-heavy-implementation")),(0,r.kt)("p",null,"Coroutine differs with multithreading, multiple thread can work together in parallel, they can execute code simultaneously. Having multiple thread can be resource intensive (e.g., require its memory and switching between them can be intensive). On the other hand, coroutine doesn't require a lot of thread to work, coroutine take turns executing their code, allowing for efficient multitasking within a smaller number of threads. In summary, coroutine can be thought as the lightweight version of thread."),(0,r.kt)("h4",{id:"callbacks"},"Callbacks"),(0,r.kt)("p",null,"A callback is a function passed as argument to another function. The purpose of passing function is to allow the receiving function to invoke the provided function at a specific point in its execution or in response to a certain event or condition."),(0,r.kt)("p",null,"For example, consider a scenario where we need to load data from server and then process it after. We have function A that loads data from a server and function B that processes the data. Function A will complete its execution when all the data is loaded, however, we don't know when it will complete. We can pass function B to function A, in the body of function A, we can include a code that invoke function B. The point where function B is invoked is when function A finishes. By using callbacks, we can ensure that the operations execute in the correct order and at the appropriate time."),(0,r.kt)("p",null,"Here is an example in the Python programming language."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def load_data(on_data_loaded):\n    data = load_data_from_server()  # Simulate long computation to load data\n    on_data_loaded(data)  # Call the provided function and pass the loaded data\n\n\ndef process_data(data):\n    # Process the loaded data...\n\n# When data is loaded, we want to process the data\nload_data(on_data_loaded = process_data)\n")),(0,r.kt)("h4",{id:"future-promise-async-await"},"Future, Promise, Async Await"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Future")," and ",(0,r.kt)("strong",{parentName:"p"},"Promise")," are both abstractions that represent the eventual result of an asynchronous operation. An operation regardless of the amount of time it takes to complete and whether they are success or not, they must eventually have a result. A future or promise is an object that represent the result."),(0,r.kt)("p",null,"Future or promise typically have some set of methods to handle the result, it may include method that indicates when the operation is finished, a method that is responsible to handle success operation, where we can use the result for our use case, or method to handle error operation."),(0,r.kt)("p",null,"Here is an example in Kotlin programming language (not a real code) :"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"// load data must complete at one point, represent by Future object\nfun loadData(): Future<String> {\n    // load data...\n}\n\nfun main() {\n    val futureString = loadData()\n    // When loadData is completed, we will pass callback that will be executed\n    // in the event of a successful data load or an error.\n    futureString.onDone(\n        onSuccess = { data ->\n            // Handle success scenario\n        },\n        onError = { error ->\n            // Handle error scenario\n        }\n    )\n}\n")),(0,r.kt)("h3",{id:"reactive-programming"},"Reactive Programming"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Reactive Programming")," is a programming paradigm that focuses on asynchronous data streams and the propagation of changes. Reactive programming is used in the scenario where data or events occurs over time and we need to react over it."),(0,r.kt)("p",null,"There is another term called ",(0,r.kt)("strong",{parentName:"p"},"event-driven programming"),", which is a programming paradigm that focuses on designing software systems around the concept of events such as user actions and sensor inputs."),(0,r.kt)("h4",{id:"stream-channel"},"Stream, Channel"),(0,r.kt)("p",null,"Stream and channel are commonly encountered concepts in the reactive programming. A stream refers to asynchronous sequences of data items or events. On the other hand, channel is communication mechanism which data can flow between different components of a system."),(0,r.kt)("p",null,"For example, in a mobile application with sensor, the sensor is considered as a data source that capable of outputting a sequence of sensor information. We can represent it as a stream and process the data to use it in the app. In the application itself, we can use channel as a way to communicate between component in the application. When the UI detect user's interaction, send the interaction information to channel and then another component may check the channel periodically for event."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Stream and channel",src:a(63543).Z,width:"1013",height:"745"})),(0,r.kt)("h4",{id:"observable-consumer-subscribe"},"Observable, Consumer, Subscribe"),(0,r.kt)("p",null,"These three concepts are related to each other. Something is called ",(0,r.kt)("strong",{parentName:"p"},"observable")," if it is capable of being a source of events or data (e.g., a data stream). The component that have an intention to receive data emitted by that stream is called the ",(0,r.kt)("strong",{parentName:"p"},"observer"),", also known as ",(0,r.kt)("strong",{parentName:"p"},"consumer"),". ",(0,r.kt)("strong",{parentName:"p"},"Subscribe"),' is the action of establishing a connection between an observable and a consumer. When a component "subscribe" to an observable, it will be notified whenever an event occurs.'),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Subscriber and observer",src:a(10439).Z,width:"637",height:"569"})),(0,r.kt)("h3",{id:"terminology"},"Terminology"),(0,r.kt)("h4",{id:"race-condition"},"Race Condition"),(0,r.kt)("p",null,"A race condition happens when multiple threads try to use the same data at the same time, and the final outcome of the program depends on the order in which the threads are executed. For example, imagine two threads, thread 1 and thread 2, they will access some number and increment it. If thread 1 starts first and thread 2 starts very quickly afterward, there is a chance that thread 2 might access the number before thread 1 has finished modifying it. This can lead to unexpected and incorrect results because thread 2 should ideally wait for thread 1 to finish modifying the number before accessing it."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Race condition illustration",src:a(22783).Z,width:"819",height:"378"})),(0,r.kt)("h4",{id:"thread-lock"},"Thread Lock"),(0,r.kt)("p",null,"Thread lock, also known as mutual exclusion (mutex), is a synchronization mechanism used prevent race condition. It simply ensures that only one thread can access the resource at a time."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Thread lock",src:a(44146).Z,width:"477",height:"406"})),(0,r.kt)("h4",{id:"thread-safe"},"Thread Safe"),(0,r.kt)("p",null,"Thread safe refers to the property of a program or data structure that can be safely accessed and manipulated by multiple threads concurrently, without causing race conditions or other synchronization issues."),(0,r.kt)("h4",{id:"deadlock"},"Deadlock"),(0,r.kt)("p",null,"Deadlock is a situation where two or more threads are unable to proceed because each is waiting for the other to take a specific action. Deadlock can occur when attempting to prevent race conditions through synchronization mechanisms, but those mechanisms are implemented incorrectly."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Deadlock GIF",src:a(81996).Z,width:"380",height:"257"}),(0,r.kt)("br",{parentName:"p"}),"\n","Source : ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Deadlock"},"https://en.wikipedia.org/wiki/Deadlock")),(0,r.kt)("h4",{id:"thread-pool"},"Thread Pool"),(0,r.kt)("p",null,"Thread pool is a collection of pre-initialized threads. Instead of creating a new thread for each task, a thread pool maintains a pool of reusable threads, reducing the overhead of creating and destroying threads."))}h.isMDXComponent=!0},85593:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/concurrency-406bf7416e4db282858ec3ec2ec53471.png"},20889:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/coroutine-2e78927259e0476a4d3fb682909e13c1.png"},81996:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/deadlock-cae19d8db430f8355244b5ae6e57977f.gif"},8003:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/multiprocessing-530c52905781b2b706725b5363dfb07b.png"},61955:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/multitasking-5a1149a47ace131820436bfc16b3de99.png"},61058:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/multithreading-multiprocessing-multitasking-b3d4aeb28ca23788278b1cd228effca0.png"},17230:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/multithreading-5d093fec420c92db6dcdac7c57888552.png"},82493:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/process-vs-thread-b1baca853eba74e0823c82f3f237b54c.png"},31320:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/process-73661450704182c00ea1e0296941437e.png"},22783:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/race-condition-2409cdf955c3ea05e59fee5de1c766ae.png"},63543:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/stream-channel-c3c80a73e3be164e28c6eaa29ea8f18c.png"},10439:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/subscriber-observer-227194040076790204e6234e9b121c26.png"},44146:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/thread-lock-2d530ae42054b129aa2f303833319afe.png"}}]);