"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[4257],{7562:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});var o=n(85893),i=n(11151);const s={slug:"/data-structures-and-algorithms/greedy",id:"greedy",title:"Greedy",description:"Greedy"},a=void 0,r={id:"data-structures-and-algorithms/greedy/greedy",title:"Greedy",description:"Greedy",source:"@site/docs/data-structures-and-algorithms/18-greedy/greedy.md",sourceDirName:"data-structures-and-algorithms/18-greedy",slug:"/data-structures-and-algorithms/greedy",permalink:"/cs-notes/data-structures-and-algorithms/greedy",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/data-structures-and-algorithms/18-greedy/greedy.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1709047097,formattedLastUpdatedAt:"Feb 27, 2024",frontMatter:{slug:"/data-structures-and-algorithms/greedy",id:"greedy",title:"Greedy",description:"Greedy"},sidebar:"sidebar",previous:{title:"Backtracking",permalink:"/cs-notes/data-structures-and-algorithms/backtracking"},next:{title:"Dynamic Programming",permalink:"/cs-notes/data-structures-and-algorithms/dynamic-programming"}},c={},d=[{value:"Coin Change",id:"coin-change",level:3}];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Main Source :"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.strong,{children:(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Greedy_algorithm",children:"Greedy algorithm - Wikipedia"})})}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Greedy algorithm"}),' is a problem-solving approach that involve selecting the currently optimal solution at each step. It is a simple and intuitive algorithm that "greedily" selects the best available option without considering the complete solution or future consequences.']}),"\n",(0,o.jsxs)(t.p,{children:["Greedy strategy is typically used in a problem where we must maximize or minimize certain objective with respect to some constraint. In some problem, getting the most optimal solution is impossible or takes a lot of time. It is true that greedy approach can't guarantee us the most optimal solution, however, by selecting the currently optimal solution without the need for complex computational or ",(0,o.jsx)(t.a,{href:"/data-structures-and-algorithms/backtracking",children:"backtracking"}),", we may achieve a good enough solution with reasonable amount of time."]}),"\n",(0,o.jsx)(t.h3,{id:"coin-change",children:"Coin Change"}),"\n",(0,o.jsx)(t.p,{children:"One of a simple problem that can be solved using a greedy approach is the coin change problem. The problem wants us to find the minimum number of coins needed to make a specific amount of money."}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"Given a set of coin and a target amount of change to make, the goal is to determine the minimum number of coins needed to make exactly that amount."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"For example, if we have a set of coin of: 1 cent, 5 cents, 10 cents, 25 cents, and the target is 79, we may use 3 x 25 cents and 4 x 1 cents, resulting in 7 coins."}),"\n",(0,o.jsx)(t.p,{children:"Here is the pseudocode for it :"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"function coinChange(coins, amount):\n    sort coins in descending order\n\n    currentAmount = 0\n    numCoins = 0\n\n    for each coin in coins\n        while currentAmount + coin <= amount:\n            currentAmount += coin\n            numCoins += 1\n\n    return numCoins\n"})}),"\n",(0,o.jsx)(t.p,{children:"The greedy approach always select the largest worth of coin available (as long as it doesn't exceed the amount) and use that coin to make the change. While this approach seems to be working all the time, there are some case where this solution doesn't give us the most optimal solution."}),"\n",(0,o.jsx)(t.p,{children:"In the case of having a coin set of [1, 6, 10] and a target amount of 12, the greedy solution would choose the largest coin, which is 10, and then add 2 coins of 1 cent, resulting in a total of 3 coins. However, it's worth noting that by using two 6-cent coins, we can achieve the target amount of 12 with only 2 coins."})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>a});var o=n(67294);const i={},s=o.createContext(i);function a(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);