"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[7689],{11491:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/compilation-process-a70643221a88384ec06e8db9478646ba.png"},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(96540);const r={},i=a.createContext(r);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:n},e.children)}},29355:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/compiler-operation-7b9123c6044c0a5cea1065bed4a0ecf3.png"},77805:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"computer-and-programming-fundamentals/compilation/compilation","title":"Compilation","description":"Compilation","source":"@site/docs/computer-and-programming-fundamentals/17-compilation/compilation.md","sourceDirName":"computer-and-programming-fundamentals/17-compilation","slug":"/computer-and-programming-fundamentals/compilation","permalink":"/cs-notes/computer-and-programming-fundamentals/compilation","draft":false,"unlisted":false,"editUrl":"https://github.com/glennhenry/cs-notes/tree/main/docs/computer-and-programming-fundamentals/17-compilation/compilation.md","tags":[],"version":"current","lastUpdatedBy":"glennhenry","lastUpdatedAt":1723455088000,"frontMatter":{"slug":"/computer-and-programming-fundamentals/compilation","id":"compilation","title":"Compilation","description":"Compilation"},"sidebar":"sidebar","previous":{"title":"Caching","permalink":"/cs-notes/computer-and-programming-fundamentals/caching"},"next":{"title":"Interpreter","permalink":"/cs-notes/computer-and-programming-fundamentals/interpreter"}}');var r=t(74848),i=t(28453);const s={slug:"/computer-and-programming-fundamentals/compilation",id:"compilation",title:"Compilation",description:"Compilation"},o=void 0,c={},l=[{value:"Language Abstraction",id:"language-abstraction",level:3},{value:"Compilation Process",id:"compilation-process",level:3}];function d(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Main Source:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Compiler",children:"Compiler \u2014 Wikipedia"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"https://stackoverflow.com/questions/1782415/what-is-the-difference-between-assembly-code-and-bytecode",children:"What is the difference between assembly code and bytecode? \u2014 stackoverflow"})})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"When we write code using a particular programming language, it is still in the form of high-level source code. By high-level source code, it means the code is human-readable and involves less direct interaction with the underlying hardware. The purpose high-level programming language is to provide abstraction that make it easier for programmer to make a program."}),"\n",(0,r.jsxs)(n.p,{children:["However, computers don't understand high-level code. At the lowest level, a computer can only understand binary instructions (1s and 0s). Generally, we refer to code intended to be read and executed directly by a machine as ",(0,r.jsx)(n.strong,{children:"machine code"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["So, writing code in high-level language is just one way to program computer through natural language. The code written in programming language will need to be translated into machine code before they can be executed. The translation process may include more than once, it may be translated into intermediate representation before translated to final binary code. The translation process is done by ",(0,r.jsx)(n.strong,{children:"compilers"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Compiler"})," is a program that translates code written in one language into another, typically converting high-level language code into low-level language code."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/computer-and-programming-fundamentals/interpreter",children:"interpreter"})})," doesn't translate code, but rather read and understand code. Based on its understanding, it performs the corresponding actions. This means that an interpreted programming language won't be translated into machine code."]})}),"\n",(0,r.jsx)(n.h3,{id:"language-abstraction",children:"Language Abstraction"}),"\n",(0,r.jsx)(n.p,{children:"Computer executes the lowest-level codes, which is binary instruction. Programmers have no way to write binary codes, so it is abstracted in many levels up to a high-level programming language. Here are some of different levels of language abstraction:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"High-Level Code"}),": High-level code refers to code written in a high-level programming language, such as Python, Java, C++, etc. These languages provide a high level of abstraction and are designed to be human-readable. High-level code is typically written using some programming constructs like ",(0,r.jsx)(n.a,{href:"/computer-and-programming-fundamentals/programming-concepts#variables--data-types",children:"variables"}),", ",(0,r.jsx)(n.a,{href:"/computer-and-programming-fundamentals/programming-concepts#functions",children:"functions"}),", or even some ",(0,r.jsx)(n.a,{href:"/computer-and-programming-fundamentals/object-oriented-programming",children:"OOP concepts"})," like ",(0,r.jsx)(n.a,{href:"/computer-and-programming-fundamentals/object-oriented-programming#object",children:"object"})," and ",(0,r.jsx)(n.a,{href:"/computer-and-programming-fundamentals/object-oriented-programming#class",children:"classes"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/compilers-and-programming-languages/intermediate-representation",children:"Intermediate Representation (IR)"})}),": IR is a representation of source code between a high-level language and low-level machine code. It is a general term for an abstraction of machine code that is higher than assembly language (see next) but lower than a high-level code. An intermediate representation can be transformed into lower-level representation through additional process, or directly behave as instructions for the computer. One popular IR for the latter is the ",(0,r.jsx)(n.strong,{children:"bytecode"}),", which is also known as ",(0,r.jsx)(n.strong,{children:"p-code (portable code)"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"In general, instructions of IR are basic and fundamental to the machine. Even a single line of code can result in a few lines of instruction. The characteristic of bytecode is that an instruction is identified with a one-byte opcode, followed by several parameters."}),"\n",(0,r.jsxs)(n.p,{children:["Bytecode is designed to be executed in a ",(0,r.jsx)(n.a,{href:"/cloud-computing-and-distributed-systems/virtualization",children:"virtual machine"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"A virtual machine can be thought of as a virtualized computer system. It isn't a real computer, but can be thought of as one. In simple term, we don't call it a real computer system because technically it doesn't consist of typical constructs like a CPU, but rather something that simulates it. In the context of code execution, it isn't actually executing machine code."})}),"\n",(0,r.jsxs)(n.p,{children:["In the virtual machine that executes bytecode, there exists something called an ",(0,r.jsx)(n.a,{href:"/computer-and-programming-fundamentals/interpreter",children:"interpreter"}),". The bytecode is fed to the interpreter, which dynamically does things according to the instruction. Examples of languages that use bytecode include Java and Python."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["Another term that is often heard is ",(0,r.jsx)(n.a,{href:"/computer-organization-and-architecture/isa#instructions",children:"operation code (opcode)"}),". Opcode refers to the instruction of machine language that specifies the operation to be performed by the computer's processor. It represents the fundamental operations that the hardware can execute, such as arithmetic operations, memory access, and control flow instructions. Typically, they are identified by raw binaries or represented in hexadecimal. For example, if we want to add between numbers, we must specify the instruction with the hexadecimal ",(0,r.jsx)(n.code,{children:"B1"}),"."]})}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Assembly Language"}),": Assembly language is a low-level programming language that represent machine code instructions in human-readable form. It provides a close representation to machine code and is specific to a particular hardware architecture."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Machine Code"}),": Machine code is the lowest level of abstraction in programming. It can be ",(0,r.jsx)(n.a,{href:"/computer-and-programming-fundamentals/number-system#binary",children:"binary"})," code (sequences of 0s and 1s) or ",(0,r.jsx)(n.a,{href:"/computer-and-programming-fundamentals/number-system#hexadecimal",children:"hexadecimal"})," that directly represents the instructions and data that a computer's hardware can execute. Machine language instructions are specific to the hardware architecture and are directly understood and executed by the processor."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.img,{alt:"Language abstraction comparison",src:t(83169).A+"",width:"1455",height:"423"}),(0,r.jsx)(n.br,{}),"\n","Source: ",(0,r.jsx)(n.a,{href:"https://stackify.com/python-tips-10-tricks-for-optimizing-your-code/",children:"High-level code"}),", ",(0,r.jsx)(n.a,{href:"https://www.sciencedirect.com/topics/computer-science/bytecode",children:"Bytecode"}),", ",(0,r.jsx)(n.a,{href:"https://www.nayuki.io/page/a-fundamental-introduction-to-x86-assembly-programming",children:"assembly and machine code"})]}),"\n",(0,r.jsx)(n.h3,{id:"compilation-process",children:"Compilation Process"}),"\n",(0,r.jsx)(n.p,{children:"The compilation process typically involves the following stages:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Preprocessor"}),': The preprocessor is a tool or component that processes the source code before it goes through compilation. It performs preprocessing directives tasks, which is special instructions in programming language like C and C++. The instruction starts with the "#" symbol, basically it provides a way to modify the source code before it is passed to the compiler.']}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Compiler"}),": The compiler takes the preprocessed source code as input and translates it into low-level code or an intermediate representation such as bytecode. The compiler checks the syntax and semantics of the code, processes the code, generates optimized code if applicable, and produces output. Compiler does the following process:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Lexical Analysis"}),": In this stage, the source code is broken down into a sequence of ",(0,r.jsx)(n.strong,{children:"tokens"}),". Tokens are the smallest meaningful units in the programming language, such as keywords, identifiers, operators, and literals. The ",(0,r.jsx)(n.strong,{children:"lexical analyzer (lexer)"})," scans the source code character by character and groups characters into tokens based on predefined rules and patterns. The tokens are then passed to the next stage."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Syntax Analysis"}),": The syntax analysis, also known as parsing, checks whether the sequence of tokens generated by the lexical analyzer is valid according to the grammar rules of the programming language. It builds a ",(0,r.jsx)(n.strong,{children:"parse tree"})," (or ",(0,r.jsx)(n.strong,{children:"abstract syntax tree (AST)"}),", the simpler version of parse tree) that represents the structure of the code in a tree-like structure. The parser analyzes the relationships and arrangements of the tokens according to the language's grammar rules and detects syntax errors if the code violates those rules."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Semantic Analysis"}),": Once the syntax analysis is complete and the code is determined to be syntactically correct, the compiler moves on to the semantic analysis stage. Here, the compiler checks the meaning and validity of the code in terms of its semantics. It verifies things like checking if variable has been declared before it used, checking if variables types are valid, scoping rules, function calls, and other language-specific rules. The semantic analyzer ensures that the code adheres to the language's semantics and detects potential ",(0,r.jsx)(n.strong,{children:"semantic errors"})," or ",(0,r.jsx)(n.a,{href:"/computer-and-programming-fundamentals/programming-concepts#type-of-error",children:"compile-time error"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Code Generation"}),": After the semantic analysis, the compiler proceeds to generate target code based on the analyzed and validated input. The code generation stage involves transforming the high-level representation (such as the AST) into a lower-level form, which may be assembly language, machine code, bytecode, or an intermediate representation. The code generator translates the code into a format that can be executed by the target platform, while also applying optimizations to improve performance and efficiency."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.img,{alt:"Compiler operation",src:t(29355).A+"",width:"1264",height:"654"}),(0,r.jsx)(n.br,{}),"\n","Source: ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Abstract_syntax_tree",children:"Abstract syntax tree"}),", ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Compiler#/media/File:Xxx_Scanner_and_parser_example_for_C.gif",children:"Lexer - parser"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Assembler"}),": The assembler is responsible for translating assembly language code into machine code. It takes the output of the compiler and converts it into machine code that can be directly executed by the computer's processor. The assembler replaces the instructions and symbolic representations with their corresponding binary representations (opcodes)."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Linker"}),": The linker is a separate program that combines multiple object files, libraries, and other dependencies to create a complete executable program or a shared library. It resolves external references and ensures that all the necessary components are linked together correctly. The linker also handles tasks like memory address assignment, relocation, and generating the final executable file or library."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.img,{alt:"Compilation process",src:t(11491).A+"",width:"450",height:"400"}),(0,r.jsx)(n.br,{}),"\n","Source: ",(0,r.jsx)(n.a,{href:"https://medium.com/@3681/steps-of-compilation-5c02935a3904",children:"https://medium.com/@3681/steps-of-compilation-5c02935a3904"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["More detailed ",(0,r.jsx)(n.a,{href:"/compilers-and-programming-languages/cpl-fundamentals#compiler-toolchain",children:"compilation process"}),"."]})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},83169:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/language-abstraction-e238d1ff6ba81e79caac442daab6fb9a.png"}}]);