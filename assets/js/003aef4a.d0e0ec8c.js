"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[5119],{92962:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>x,frontMatter:()=>l,metadata:()=>h,toc:()=>m});var s=n(85893),a=n(11151);const r=n.p+"assets/medias/two-pointer-illustration-81bc34006a08ffdbc431f13824e975e5.mp4",i=n.p+"assets/medias/naive-solution-d872ead76e6e3110ca3ff76324ae64cb.mp4",o=n.p+"assets/medias/two-pointer-solution-0b84d833414bd912bd6ae4234514d3db.mp4",l={slug:"/data-structures-and-algorithms/two-pointer",id:"two-pointer",title:"Two Pointer",description:"Two Pointer"},c=void 0,h={id:"data-structures-and-algorithms/two-pointer/two-pointer",title:"Two Pointer",description:"Two Pointer",source:"@site/docs/data-structures-and-algorithms/20-two-pointer/two-pointer.mdx",sourceDirName:"data-structures-and-algorithms/20-two-pointer",slug:"/data-structures-and-algorithms/two-pointer",permalink:"/cs-notes/data-structures-and-algorithms/two-pointer",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/data-structures-and-algorithms/20-two-pointer/two-pointer.mdx",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1708687650,formattedLastUpdatedAt:"Feb 23, 2024",frontMatter:{slug:"/data-structures-and-algorithms/two-pointer",id:"two-pointer",title:"Two Pointer",description:"Two Pointer"},sidebar:"sidebar",previous:{title:"Dynamic Programming",permalink:"/cs-notes/data-structures-and-algorithms/dynamic-programming"},next:{title:"Sliding Window",permalink:"/cs-notes/data-structures-and-algorithms/sliding-window"}},d={},m=[{value:"Palindrome Checking",id:"palindrome-checking",level:3},{value:"Naive Solution",id:"naive-solution",level:4},{value:"Two Pointer Approach",id:"two-pointer-approach",level:4}];function p(e){const t={a:"a",annotation:"annotation",br:"br",code:"code",h3:"h3",h4:"h4",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Main Source :"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"https://algodaily.com/lessons/using-the-two-pointer-technique",children:"The Two Pointer Technique - AlgoDaily"})})}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Two Pointer"})," is a technique to solve problems that involve traversing a sequence or data structure using two pointers or references. For instance, when we iterate through an array, if we use single pointer, we only have a single variable that refer to the element of the array. If we use two pointer technique, we can have two variable that refer to the array."]}),"\n",(0,s.jsx)(t.p,{children:"Here is an illustration :"}),"\n",(0,s.jsx)("video",{width:"695",height:"392",controls:!0,children:(0,s.jsx)("source",{src:r})}),"\n",(0,s.jsx)(t.p,{children:"In this case, we used two pointer to traverse the array faster. The pointer will store the index it is accessing and we will increase the index of both pointer in each iteration. Using this technique, we are able to achieve 2x faster speed than just using one pointer."}),"\n",(0,s.jsx)(t.h3,{id:"palindrome-checking",children:"Palindrome Checking"}),"\n",(0,s.jsx)(t.p,{children:'Palindrome is a word, number, sequence, or phrase that reads the same as forwards and backwards. Example of a palindrome word is "racecar", reading it forward from left to right or backward from right to left will be the same.'}),"\n",(0,s.jsx)(t.h4,{id:"naive-solution",children:"Naive Solution"}),"\n",(0,s.jsxs)(t.p,{children:["How would we design an algorithm that checks if a given string is palindrome or not?",(0,s.jsx)(t.br,{}),"\n","The naive solution would be reading it forward first, then reading it backward after, and then compare it if they are the same or not."]}),"\n",(0,s.jsx)(t.p,{children:"Here is the pseudocode for it :"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'function(word: String): Boolean\n    readForward = ""\n    readBackward = ""\n\n    for each character in word:\n        append character to last position of readForward\n        append character to first position of readBackward\n\n    return readForward == readBackward\n'})}),"\n",(0,s.jsx)(t.p,{children:"Here's how will it look like :"}),"\n",(0,s.jsx)("video",{width:"695",height:"392",controls:!0,children:(0,s.jsx)("source",{src:i})}),"\n",(0,s.jsxs)(t.p,{children:["In this code, we created two empty string. We will iterate the string and append each character to last and first position of ",(0,s.jsx)(t.code,{children:"readForward"})," and ",(0,s.jsx)(t.code,{children:"readBackward"}),", respectively. We will need to iterate the whole string, therefore this algorithm results in ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsxs)(t.mrow,{children:[(0,s.jsx)(t.mi,{children:"O"}),(0,s.jsx)(t.mo,{stretchy:"false",children:"("}),(0,s.jsx)(t.mi,{children:"n"}),(0,s.jsx)(t.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"O(n)"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,s.jsx)(t.span,{className:"mopen",children:"("}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"n"}),(0,s.jsx)(t.span,{className:"mclose",children:")"})]})})]})," time complexity, where ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"n"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"n"})]})})]})," is the length of the string. The space complexity is ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsxs)(t.mrow,{children:[(0,s.jsx)(t.mi,{children:"O"}),(0,s.jsx)(t.mo,{stretchy:"false",children:"("}),(0,s.jsx)(t.mn,{children:"2"}),(0,s.jsx)(t.mi,{children:"n"}),(0,s.jsx)(t.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"O(2n)"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,s.jsx)(t.span,{className:"mopen",children:"("}),(0,s.jsx)(t.span,{className:"mord",children:"2"}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"n"}),(0,s.jsx)(t.span,{className:"mclose",children:")"})]})})]})," = ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsxs)(t.mrow,{children:[(0,s.jsx)(t.mi,{children:"O"}),(0,s.jsx)(t.mo,{stretchy:"false",children:"("}),(0,s.jsx)(t.mi,{children:"n"}),(0,s.jsx)(t.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"O(n)"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,s.jsx)(t.span,{className:"mopen",children:"("}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"n"}),(0,s.jsx)(t.span,{className:"mclose",children:")"})]})})]}),", because we used two string to store the read."]}),"\n",(0,s.jsx)(t.h4,{id:"two-pointer-approach",children:"Two Pointer Approach"}),"\n",(0,s.jsx)(t.p,{children:"Notice that we did a repeated work in the naive solution, we can optimize this using two pointer approach. If a string is palindrome, it will be read the same from forward and backward. The idea is, instead of storing the read somewhere, why don't we compare it on the fly while iterating? Now the question is, how would we compare it on the fly?"}),"\n",(0,s.jsx)(t.p,{children:"The solution is to have two pointer, with one pointing to the first character of the string or index 0, and the other pointer points to the last character. The first pointer (or we call left pointer because it starts from left) will be incremented while the second pointer (right pointer) will be decremented in each iteration. We will check if the character at the index of left pointer is the same as the character at index of right pointer. If they are not the same, we will return false, indicating they are not palindrome."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"function(word: String): Boolean\n    leftPointer = 0\n    rightPointer = last index of word\n\n    while leftPointer < rightPointer:\n        if word[leftPointer] != word[rightPointer]:\n            return false\n\n        leftPointer = leftPointer + 1\n        rightPointer = rightPointer + 1\n\n    return true\n"})}),"\n",(0,s.jsx)("video",{width:"695",height:"392",controls:!0,children:(0,s.jsx)("source",{src:o})}),"\n",(0,s.jsxs)(t.p,{children:["Using this two pointer approach, we managed to achieve a constant ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsxs)(t.mrow,{children:[(0,s.jsx)(t.mi,{children:"O"}),(0,s.jsx)(t.mo,{stretchy:"false",children:"("}),(0,s.jsx)(t.mn,{children:"1"}),(0,s.jsx)(t.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"O(1)"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,s.jsx)(t.span,{className:"mopen",children:"("}),(0,s.jsx)(t.span,{className:"mord",children:"1"}),(0,s.jsx)(t.span,{className:"mclose",children:")"})]})})]}),' space complexity, we don\'t need to store the string read anywhere. This algorithm also have better time complexity, the worst-time complexity would be the same as the naive solution, however, the best and average may differ in some scenario. In the case of "abcde", we can immediately return false in the first iteration, because "a" is indeed not equal to "e", it immediately break the palindrome definition.']})]})}function x(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>i});var s=n(67294);const a={},r=s.createContext(a);function i(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);