"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[7369],{81353:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var i=r(85893),n=r(11151);const s={slug:"/computer-graphics/rendering-part-2",id:"rendering-part-2",title:"Rendering (Part 2)",description:"Rendering (Part 2)"},a="Rendering (Part 2)",o={id:"computer-graphics/rendering-part-2/rendering-part-2",title:"Rendering (Part 2)",description:"Rendering (Part 2)",source:"@site/docs/computer-graphics/14-rendering-part-2/rendering-part-2.md",sourceDirName:"computer-graphics/14-rendering-part-2",slug:"/computer-graphics/rendering-part-2",permalink:"/cs-notes/computer-graphics/rendering-part-2",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/computer-graphics/14-rendering-part-2/rendering-part-2.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1710500856,formattedLastUpdatedAt:"Mar 15, 2024",frontMatter:{slug:"/computer-graphics/rendering-part-2",id:"rendering-part-2",title:"Rendering (Part 2)",description:"Rendering (Part 2)"},sidebar:"sidebar",previous:{title:"Rendering (Part 1)",permalink:"/cs-notes/computer-graphics/rendering-part-1"},next:{title:"Ray Tracing",permalink:"/cs-notes/computer-graphics/ray-tracing"}},h={},l=[{value:"Rendering Algorithm",id:"rendering-algorithm",level:3},{value:"Anti-Aliasing",id:"anti-aliasing",level:3},{value:"Scanline Rendering",id:"scanline-rendering",level:3},{value:"Painter Algorithm",id:"painter-algorithm",level:3},{value:"Z-Buffer Rasterization",id:"z-buffer-rasterization",level:3},{value:"A-Buffer Rasterization",id:"a-buffer-rasterization",level:3},{value:"REYES (Renders Everything You Ever Saw)",id:"reyes-renders-everything-you-ever-saw",level:3}];function c(e){const t={a:"a",br:"br",h1:"h1",h3:"h3",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,n.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"rendering-part-2",children:"Rendering (Part 2)"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.strong,{children:["Main Source : ",(0,i.jsx)(t.a,{href:"https://youtu.be/0WrzyD8nBlk?t=233",children:"Intro to Graphics 18 - Rendering Algorithms"})]})}),"\n",(0,i.jsx)(t.h3,{id:"rendering-algorithm",children:"Rendering Algorithm"}),"\n",(0,i.jsx)(t.p,{children:"Rendering process which include rasterization, uses several algorithm :"}),"\n",(0,i.jsx)(t.p,{children:"Rasterization :"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scanline Rendering"}),"\n",(0,i.jsx)(t.li,{children:"Painter Algorithm"}),"\n",(0,i.jsx)(t.li,{children:"Z-Buffer Rasterization"}),"\n",(0,i.jsx)(t.li,{children:"A-Buffer Rasterization"}),"\n",(0,i.jsx)(t.li,{children:"REYES (Renders Everything You Ever Saw)"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"anti-aliasing",children:"Anti-Aliasing"}),"\n",(0,i.jsxs)(t.p,{children:["In rasterization process, 3d object are converted into 2d image with pixel, and then will be colored. In some cases, coloring the pixel directly would make it appear jaggy, this is called ",(0,i.jsx)(t.strong,{children:"Aliasing"}),". ",(0,i.jsx)(t.strong,{children:"Anti-Aliasing"})," which is the technique to reduce aliasing in digital images, it smoothes out the edges of objects and reducing jaggedness in the image to produce a more visually pleasing result."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"Anti aliased triangle with red color",src:r(34934).Z+"",width:"420",height:"162"}),(0,i.jsx)(t.br,{}),"\n","Source : ",(0,i.jsx)(t.a,{href:"https://youtu.be/0WrzyD8nBlk?t=334",children:"https://youtu.be/0WrzyD8nBlk?t=334"})]}),"\n",(0,i.jsxs)(t.p,{children:["There is also an improvement for Anti-Aliasing (AA) which is ",(0,i.jsx)(t.strong,{children:"Multi Sample Anti-Aliasing (MSAA)"}),". MSAA works by sampling multiple points within each pixel, instead of just one, and using the average of the color values at those sample points to generate the final color for the pixel."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"A triangle is sampled four times in each pixel",src:r(2240).Z+"",width:"251",height:"209"}),(0,i.jsx)(t.br,{}),"\n","Source : ",(0,i.jsx)(t.a,{href:"https://youtu.be/0WrzyD8nBlk?t=1425",children:"https://youtu.be/0WrzyD8nBlk?t=1425"})]}),"\n",(0,i.jsx)(t.h3,{id:"scanline-rendering",children:"Scanline Rendering"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Scanline Rendering"})," is a technique used in computer graphics to generate images by processing one horizontal line of pixels, known as a scanline, at a time. It involves determining the intersection points of geometric primitives (such as triangles or polygons) with each scanline and then shading those pixels to produce the final image."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"A gif of scanline rendering scanning through a triangle",src:r(29090).Z+"",width:"400",height:"225"}),(0,i.jsx)(t.br,{}),"\n","Source : ",(0,i.jsx)(t.a,{href:"https://youtu.be/TEAtmCYYKZA",children:"https://youtu.be/TEAtmCYYKZA"})]}),"\n",(0,i.jsx)(t.h3,{id:"painter-algorithm",children:"Painter Algorithm"}),"\n",(0,i.jsxs)(t.p,{children:["The painter's algorithm is a simple algorithm to render object by ",(0,i.jsx)(t.strong,{children:"drawing the object furthest away to the camera to the closest"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"The algorithm is based on the idea of painting each object in the scene onto an imaginary canvas from back to front, with each object partially or fully obscuring the objects behind it. This mean the object needs to be sorted."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"A sequence of images drawing from the behind to front, the mountain, grassland, and the trees",src:r(46258).Z+"",width:"602",height:"154"}),(0,i.jsx)(t.br,{}),"\n","Source : ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Painter%27s_algorithm",children:"https://en.wikipedia.org/wiki/Painter's_algorithm"})]}),"\n",(0,i.jsx)(t.p,{children:"Painter algorithm draws object one by one from back to front, when objects overlap, the algorithm has to make assumptions about which object is in front of the other based purely on distance. This can lead to incorrect results if the objects are not sorted correctly or if there are ambiguities in the ordering."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"Blue and red triangle overlapping",src:r(56591).Z+"",width:"181",height:"223"}),(0,i.jsx)(t.br,{}),"\n","Source : ",(0,i.jsx)(t.a,{href:"https://youtu.be/0WrzyD8nBlk?t=730",children:"https://youtu.be/0WrzyD8nBlk?t=730"})]}),"\n",(0,i.jsx)(t.h3,{id:"z-buffer-rasterization",children:"Z-Buffer Rasterization"}),"\n",(0,i.jsxs)(t.p,{children:["Z-buffer algorithm works by ",(0,i.jsx)(t.strong,{children:"keeping track of the depth value of each pixel"})," in the image plane during the rasterization process. The depth value represents the distance from the camera to the closest object at that pixel."]}),"\n",(0,i.jsx)(t.p,{children:"The depth value is used to determine which object to draw in front. This algorithm allows for efficient and accurate rendering of 3D scenes, because it allows objects to be rendered in any order and still produce correct results."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"Two triangle overlapping but still shows the correct rasterization",src:r(74557).Z+"",width:"457",height:"207"}),(0,i.jsx)(t.br,{}),"\n","Source : ",(0,i.jsx)(t.a,{href:"https://youtu.be/0WrzyD8nBlk?t=1194",children:"https://youtu.be/0WrzyD8nBlk?t=1194"})]}),"\n",(0,i.jsx)(t.p,{children:"There is a problem with Z-buffer algorithm while rendering transparent objects that should blend. If the blue triangle is rendered first and then red after, it will result in the middle image. However, if we do the opposite, rendering red first and blue after, the result wouldn\u2019t blend the color. This is because the depth value of the blue triangle is behind the red hence it\u2019s not drew."}),"\n",(0,i.jsx)(t.p,{children:"The solution for this is to sort the object from back to front, which require more computation."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"Two triangle overlapping resulting in different color whether red comes first or blue comes first",src:r(7343).Z+"",width:"482",height:"163"}),(0,i.jsx)(t.br,{}),"\n","Source : ",(0,i.jsx)(t.a,{href:"https://youtu.be/0WrzyD8nBlk?t=1585",children:"https://youtu.be/0WrzyD8nBlk?t=1585"})]}),"\n",(0,i.jsx)(t.h3,{id:"a-buffer-rasterization",children:"A-Buffer Rasterization"}),"\n",(0,i.jsx)(t.p,{children:"A-buffer rasterization is an extension of the traditional Z-buffer algorithm that uses layers to track each pixel which is stored in linked list. This means A-buffer require more memory than z-buffer and also computationally expensive because the linked lists must be traversed and sorted for each pixel."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"A few rectangle intersecting with each other with point in each intersection showing the order",src:r(31943).Z+"",width:"649",height:"276"}),(0,i.jsx)(t.br,{}),"\n","Source : ",(0,i.jsx)(t.a,{href:"https://www.geeksforgeeks.org/a-buffer-method/",children:"https://www.geeksforgeeks.org/a-buffer-method/"})]}),"\n",(0,i.jsx)(t.h3,{id:"reyes-renders-everything-you-ever-saw",children:"REYES (Renders Everything You Ever Saw)"}),"\n",(0,i.jsx)(t.p,{children:"REYES is a graphics rendering algorithm that was developed by Pixar in the late 1980s for use in their animated films."}),"\n",(0,i.jsx)(t.p,{children:"The REYES algorithm works by dividing the scene into small patches, typically 16x16 pixels in size. Each patch is then subdivided into small micropolygons, which are typically 2x2 or 4x4 pixels in size. For each micropolygon, the algorithm computes the shading and other attributes of the object, such as texture mapping and lighting."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"A texture is mapped using a micropolygon",src:r(6470).Z+"",width:"378",height:"219"}),(0,i.jsx)(t.br,{}),"\n","Source : ",(0,i.jsx)(t.a,{href:"https://www.semanticscholar.org/paper/The-Reyes-image-rendering-architecture-Cook-Carpenter/9477daf6e5cfc58d0daa41c893391d1eee8097e8",children:"https://www.semanticscholar.org/paper/The-Reyes-image-rendering-architecture-Cook-Carpenter/9477daf6e5cfc58d0daa41c893391d1eee8097e8"})]})]})}function d(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},31943:(e,t,r)=>{r.d(t,{Z:()=>i});const i=r.p+"assets/images/a-buffer-rasterization-ae796f8cbd1b4451a6ca4403c4b89f88.png"},34934:(e,t,r)=>{r.d(t,{Z:()=>i});const i=r.p+"assets/images/anti-aliasing-9a135cb85584ab06016e24d0820eb9a7.png"},7343:(e,t,r)=>{r.d(t,{Z:()=>i});const i=r.p+"assets/images/blending-problem-e4ae32b17bcd92d4554aad349244a4ac.png"},56591:(e,t,r)=>{r.d(t,{Z:()=>i});const i=r.p+"assets/images/intersecting-triangles-f16430e835b1e173d2a01e38bd07e0b5.png"},2240:(e,t,r)=>{r.d(t,{Z:()=>i});const i=r.p+"assets/images/multi-sample-anti-aliasing-c84c36d765cfbeb33a49b6705d37a058.png"},46258:(e,t,r)=>{r.d(t,{Z:()=>i});const i=r.p+"assets/images/painters-algorithm-4e78cd800ae56e9424b2795254c4cc89.png"},6470:(e,t,r)=>{r.d(t,{Z:()=>i});const i=r.p+"assets/images/reyes-590883a2d027241c16cadd963c3d5af2.png"},29090:(e,t,r)=>{r.d(t,{Z:()=>i});const i=r.p+"assets/images/scanline-rendering-6ecac058a39dace52427e495e43c4915.gif"},74557:(e,t,r)=>{r.d(t,{Z:()=>i});const i=r.p+"assets/images/z-buffer-algorithm-8b72a43b0cf2db29ae4fc83213449a1c.png"},11151:(e,t,r)=>{r.d(t,{Z:()=>o,a:()=>a});var i=r(67294);const n={},s=i.createContext(n);function a(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);