"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[5048],{20003:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var s=t(85893),i=t(11151);const r={slug:"/compilers/compilers-fundamentals",id:"compilers-fundamentals",title:"Compilers Fundamentals",description:"Compilers Fundamentals"},a=void 0,o={id:"compilers/compilers-fundamentals/compilers-fundamentals",title:"Compilers Fundamentals",description:"Compilers Fundamentals",source:"@site/docs/compilers/01-compilers-fundamentals/compilers-fundamentals.md",sourceDirName:"compilers/01-compilers-fundamentals",slug:"/compilers/compilers-fundamentals",permalink:"/cs-notes/compilers/compilers-fundamentals",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/compilers/01-compilers-fundamentals/compilers-fundamentals.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1714543168e3,frontMatter:{slug:"/compilers/compilers-fundamentals",id:"compilers-fundamentals",title:"Compilers Fundamentals",description:"Compilers Fundamentals"},sidebar:"sidebar",previous:{title:"Compilers",permalink:"/cs-notes/compilers"},next:{title:"Syntax",permalink:"/cs-notes/compilers/syntax"}},c={},l=[{value:"Compilation Process",id:"compilation-process",level:3},{value:"Terminology",id:"terminology",level:3}];function d(e){const n={a:"a",br:"br",code:"code",em:"em",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Main Source :"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Chapter 1, Programming Language Pragmatics - Michael L. Scott"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Compiler is ..."}),"\n",(0,s.jsx)(n.h3,{id:"compilation-process",children:"Compilation Process"}),"\n",(0,s.jsxs)(n.p,{children:["Adding up from ",(0,s.jsx)(n.a,{href:"/computer-and-programming-fundamentals/compilation#compilation-process",children:"compilation process"}),", the process can be broken down further into 6 steps. The first 3 steps is called the ",(0,s.jsx)(n.strong,{children:"frontend"}),", where the compilers interact with high-level source code (language-dependent). The 3 later stages are called ",(0,s.jsx)(n.strong,{children:"backend"})," process, where the compiler focuses on generating code that is specific to the target machine from the output of frontend (machine-dependent). The frontend stages of compiler is same for any machine, but compiler may have different internal structure during the backend stages."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"Compilation process",src:t(59801).Z+"",width:"449",height:"384"}),(0,s.jsx)(n.br,{}),"\n","Source : Book page 763"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Lexical Analysis (Scanning)"})," : The first steps filter out unnecessary symbols from the source code, keeping only necessary input that comes from the language (we call it tokens). This includes removing white spaces and comments, while keeping identifier (e.g., variable names, function names), keywords, literals, operators, etc. The compiler may use the ",(0,s.jsx)(n.strong,{children:"symbol table"})," for storing global information about the compilation and code."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Syntax Analysis (Parsing)"})," : This steps analyze code correctness according to defined grammar. A ",(0,s.jsx)(n.em,{children:"parse tree"})," is constructed from the produced tokens from the previous step. The parse tree represents code organization based on grammar rules. For instance, a language may use ",(0,s.jsx)(n.a,{href:"/theory-of-computation-and-automata/context-free-grammar",children:"context-free grammar"})," do define its grammar. The compiler identifies if tokens belong to any valid categories. Compiler will continue constructing the tree whenever it encounters valid grammar, while encountering unexpected tokens gives a ",(0,s.jsx)(n.strong,{children:"syntax error"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If a grammar is defined as ",(0,s.jsx)(n.code,{children:"<while_statement> -> while <boolean_expression> <statement>"}),", it basically means that a while statement must start with the keyword ",(0,s.jsx)(n.code,{children:"while"})," followed by an expression that returns a boolean type, and finally a statement, which performs the actual operation. The boolean expression could be a comparison, equality checking, or other. If the compiler receives ",(0,s.jsx)(n.code,{children:"while x = 3"}),", this may not conform to the grammar since ",(0,s.jsx)(n.code,{children:"x = 3"})," is not a valid boolean expression. It is more like assignment, where the grammar may look like ",(0,s.jsx)(n.code,{children:"<identifier> = <literals>"})," (i.e., ",(0,s.jsx)(n.code,{children:"x"})," is an identifier, a name given by the programmers, and 3 is a literal number)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"Parse tree",src:t(51631).Z+"",width:"420",height:"320"}),(0,s.jsx)(n.br,{}),"\n","Source : ",(0,s.jsx)(n.a,{href:"https://ruslanspivak.com/lsbasi-part7/",children:"https://ruslanspivak.com/lsbasi-part7/"})]}),"\n",(0,s.jsxs)(n.p,{children:["The above is an example of a parse tree. When the compiler sees ",(0,s.jsx)(n.code,{children:"2 * 7 + 3"}),", it recognizes that it is an expression. It knows that expression should be ",(0,s.jsx)(n.code,{children:"<term> +|-|*|/ <term>"})," (i.e., a term combined with one choice of operator and followed by another term). It further recognizes that one of the term itself is nested with the operator ",(0,s.jsx)(n.code,{children:"*"}),". A term can be obtained from a single factor, just like what 3 is, or consist of a factor multiplied by another term (which could be another single factor)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Semantic Analysis"})," : In this step, the compiler checks the meaning of the code beyond its syntax. This can include type checking, scoping rules, and other language semantics. It may enforce that an integer type cannot be added to a string, or checking whether a variable is defined before it is used."]}),"\n",(0,s.jsxs)(n.p,{children:["Language like Java won't allow a string to be accessed with square bracket like an array (called string indexing). In contrast, Python allows you to get character at some index like ",(0,s.jsx)(n.code,{children:"str[3]"}),". This will be a compile-time error in Java, as it violates the language's semantics and type system (certain rules may only be checked at runtime)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Machine-independent Optimization"})," : These optimizations are applied without considering the specific target machine architecture. For example, some function can be inlined, meaning the actual content of a function is substituted to the call site. This can reduce overhead of calling a function."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Target Code Generation"})," : Compiler translates the parse tree into target code specific to the target machine architecture. The target code can be assembly language, machine code, or an intermediate representation such as bytecode or LLVM IR. The target code generation stage involves mapping the high-level constructs of the source language to the low-level instructions of the target machine."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Machine-dependent Optimization"})," : Once the target code is generated, the compiler can apply additional optimizations that are specific to the target machine architecture. Examples of machine-dependent optimizations include instruction scheduling, register allocation, and target-specific code transformations."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"terminology",children:"Terminology"}),"\n",(0,s.jsx)(n.p,{children:"compiler vs transpiler vs decompiler vs (obfuscator, minimizer, optimizer)"})]})}function m(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},59801:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/images/compilation-process-5755907dbd2c8cea8c01c97d1ea7b41b.png"},51631:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/images/parse-tree-dda8029183d58cd01987baeca3dc1ea2.png"},11151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>a});var s=t(67294);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);