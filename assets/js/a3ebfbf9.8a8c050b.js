"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[1597],{47391:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var i=t(85893),a=t(11151);const r={slug:"/software-engineering/creational-patterns",id:"creational-patterns",title:"Creational Patterns",description:"Creational Patterns"},s=void 0,c={id:"software-engineering/creational-patterns/creational-patterns",title:"Creational Patterns",description:"Creational Patterns",source:"@site/docs/software-engineering/04-creational-patterns/creational-patterns.md",sourceDirName:"software-engineering/04-creational-patterns",slug:"/software-engineering/creational-patterns",permalink:"/cs-notes/software-engineering/creational-patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/software-engineering/04-creational-patterns/creational-patterns.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1711103900,formattedLastUpdatedAt:"Mar 22, 2024",frontMatter:{slug:"/software-engineering/creational-patterns",id:"creational-patterns",title:"Creational Patterns",description:"Creational Patterns"},sidebar:"sidebar",previous:{title:"Diagrams",permalink:"/cs-notes/software-engineering/diagrams"},next:{title:"Structural Patterns",permalink:"/cs-notes/software-engineering/structural-patterns"}},o={},l=[{value:"Creational Patterns",id:"creational-patterns",level:3},{value:"Builder",id:"builder",level:4},{value:"Singleton",id:"singleton",level:4},{value:"Prototype",id:"prototype",level:4},{value:"Factory",id:"factory",level:4},{value:"Abstract Factory",id:"abstract-factory",level:4}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Main Source :"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://refactoring.guru/design-patterns/creational-patterns",children:"Creational Design Patterns - Refactoring Guru"})})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Design Patterns"})," are general and reusable solution to common software design problems. They provide guidelines and best practices for solving specific design issues and to improve software quality."]}),"\n",(0,i.jsx)(n.p,{children:"Design patterns are categorized into three main groups :"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#creational-patterns",children:"Creational"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/software-engineering/structural-patterns",children:"Structural"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/software-engineering/behavioral-patterns",children:"Behavioral"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"creational-patterns",children:"Creational Patterns"}),"\n",(0,i.jsx)(n.p,{children:"Creational patterns focus on object creation mechanisms, providing ways to create objects in a flexible and reusable manner."}),"\n",(0,i.jsx)(n.h4,{id:"builder",children:"Builder"}),"\n",(0,i.jsxs)(n.p,{children:["Builder design pattern aims to simplify the creation of complex objects. If we are constructing a class with many properties, we typically provide it via the constructor. An example of constructing a ",(0,i.jsx)(n.code,{children:"Pizza"})," class would be :"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'class Pizza(\n    val size: String,\n    val crustType: String,\n    val sauceType: String,\n    val cheeseType: String,\n    val toppings: List<String>\n) {}\n\nfun main() {\n    val pizza: Pizza = Pizza("Large", "Thin", "Tomato", "Mozzarella", listOf("Onions", "Pepperoni"))\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["As the class and the constructor get larger, constructing the class can be confusing. We may need to see the class definition to know where is the ",(0,i.jsx)(n.code,{children:"size"})," parameters or which position correspond to ",(0,i.jsx)(n.code,{children:"cheeseType"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The idea of builder patterns is to construct a complex object step by step using methods. This will increase the flexibility to create different variations of the same object, while keeping the construction clean with descriptive name. To do this, we will make another class called ",(0,i.jsx)(n.code,{children:"PizzaBuilder"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'class PizzaBuilder {\n    private var size: String = ""\n    private var crustType: String = ""\n    private var sauceType: String = ""\n    private var cheeseType: String = ""\n    private var toppings: MutableList<String> = mutableListOf()\n\n    fun setSize(size: String): PizzaBuilder {\n        this.size = size\n        return this\n    }\n\n    fun setCrustType(crustType: String): PizzaBuilder {\n        this.crustType = crustType\n        return this\n    }\n\n    fun setSauceType(sauceType: String): PizzaBuilder {\n        this.sauceType = sauceType\n        return this\n    }\n\n    fun setCheeseType(cheeseType: String): PizzaBuilder {\n        this.cheeseType = cheeseType\n        return this\n    }\n\n    fun addTopping(topping: String): PizzaBuilder {\n        toppings.add(topping)\n        return this\n    }\n\n    fun build(): Pizza {\n        return Pizza(size, crustType, sauceType, cheeseType, toppings)\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["These are the methods that will be used by the user to set the temporary stored in the class, which will be used to construct the final ",(0,i.jsx)(n.code,{children:"Pizza"})," object using the ",(0,i.jsx)(n.code,{children:"build()"})," method. An example constructing ",(0,i.jsx)(n.code,{children:"Pizza"})," :"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val pizza: Pizza = PizzaBuilder()\n    .setSize("Large")\n    .setCrustType("Thin Crust")\n    .setSauceType("Tomato")\n    .setCheeseType("Mozzarella")\n    .addTopping("Pepperoni")\n    .addTopping("Mushrooms")\n    .addTopping("Onions")\n    .build()\n'})}),"\n",(0,i.jsxs)(n.p,{children:["It is common to chain the method calls in each line to set the attributes of the ",(0,i.jsx)(n.code,{children:"Pizza"})," object."]}),"\n",(0,i.jsxs)(n.p,{children:["In some case, we may create an interface that represent a ",(0,i.jsx)(n.code,{children:"Builder"}),". The specific class that use builder pattern will create ",(0,i.jsx)(n.code,{children:"ConcreteBuilder"})," that implements the ",(0,i.jsx)(n.code,{children:"Builder"})," interface. Each concrete builder represents a different variation or configuration of the object being built."]}),"\n",(0,i.jsxs)(n.p,{children:["We can also introduce ",(0,i.jsx)(n.code,{children:"Director"})," class, which provide a more high-level interface for object construction. For example, this class may take various type of builder, setting some default values, or constructing the builder in a specific order of steps."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["Although the code sample is in Kotlin, it is not commonly used in practice. This is because Kotlin class has default constructor parameters, and when constructing them, we can use named parameters. For example, constructing ",(0,i.jsx)(n.code,{children:"Pizza"})," class by ",(0,i.jsx)(n.code,{children:'val pizza = Pizza(size = "Large", toppings = listOf("Pepperoni", "Mushrooms"))'})," may not be that bad."]})}),"\n",(0,i.jsx)(n.h4,{id:"singleton",children:"Singleton"}),"\n",(0,i.jsxs)(n.p,{children:["In OOP, if we have a class, we can create as many instance as we want. ",(0,i.jsx)(n.strong,{children:"Singleton"})," design pattern ensures that a class has only one instance. If we insist creating multiple instance, we will be prevented and redirected to that single instance. It is commonly used when we want to restrict the instantiation of a class to a single object throughout our application, such as a single instance of database."]}),"\n",(0,i.jsx)(n.p,{children:"It is very simple to implement in Kotlin :"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"class Database private constructor() {\n    companion object {\n        private var instance: Database? = null\n\n        fun getInstance(): Database {\n            if (instance == null) {\n                instance = Database()\n            }\n\n            return instance as Database\n        }\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We will make the class constructor private, to prevent anyone for using it. We will instead divert any construct call to the static method ",(0,i.jsx)(n.code,{children:"getInstance()"}),". In Kotlin, to make members of a class static, we put it inside the ",(0,i.jsx)(n.code,{children:"companion object"})," block."]}),"\n",(0,i.jsxs)(n.p,{children:["In the method call, we will first check if the instance of the class has been created before. If it is, the instance shouldn't be ",(0,i.jsx)(n.code,{children:"null"}),", and we will simply return that instance. If the instance is ",(0,i.jsx)(n.code,{children:"null"}),", assign it with newly created instance and return it."]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["In Kotlin, the ",(0,i.jsx)(n.code,{children:"?"})," symbol behind the type name indicates the type is nullable. In the end of ",(0,i.jsx)(n.code,{children:"getInstance"})," method, we type cast it to ",(0,i.jsx)(n.code,{children:"Database"}),", because we know that it's not null."]})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["Its worth noting that the above implementation is not thread-safe, meaning it may not be safe to use it in multithreaded environment. This is because there could be multiple thread accessing the ",(0,i.jsx)(n.code,{children:"getInstance"})," method at the same time, potentially creating multiple instances."]})}),"\n",(0,i.jsx)(n.h4,{id:"prototype",children:"Prototype"}),"\n",(0,i.jsx)(n.p,{children:"Prototype pattern allows us to create new objects by cloning or copying existing objects, rather than creating them from scratch."}),"\n",(0,i.jsx)(n.p,{children:"The traditional way of copying an object is creating an object from scratch and copying and pasting the properties of the class we intend to copy from. There are three reason why this is not preferred :"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Copying and pasting properties from large class can be exhausting."}),"\n",(0,i.jsx)(n.li,{children:"Some properties of the class may be private, which means the user that wants to copy it can't access it."}),"\n",(0,i.jsx)(n.li,{children:"Increase coupling, the user needs to know the member of the class. This is also not possible when the class it copies from is an interface, instead of concrete class."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Prototype pattern simplifies the process of copying objects by delegating the responsibility of copying to the class itself. Rather than having the user control the copy of an object, the class that needs to be copied takes charge. Users can simply call a method like ",(0,i.jsx)(n.code,{children:"clone()"})," or ",(0,i.jsx)(n.code,{children:"copy() "}),"to obtain a copied object easily."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"data class Rectangle(var width: Int, var height: Int) {\n    fun clone(): Rectangle {\n        return Rectangle(this.width, this.height)\n    }\n}\n\nfun main() {\n    val rectangle = Rectangle(2, 4)\n    val rectangleCopy = rectangle.clone()\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"clone()"})," method is defined from the ",(0,i.jsx)(n.code,{children:"Rectangle"})," class itself, which has access to its members (although they are not private in this case)."]}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsxs)(n.p,{children:["In the case of using ",(0,i.jsx)(n.code,{children:"data class"}),", the clone design pattern is typically not used. This is because Kotlin ",(0,i.jsx)(n.code,{children:"data class"})," already has a built-in way to copy an object (although it's a shallow copy). We don't need to implement the copy mechanism, and simply call it like ",(0,i.jsx)(n.code,{children:"rectangle.copy()"}),"."]}),(0,i.jsxs)(n.p,{children:["We can also provide some new properties we intend to replace, such as ",(0,i.jsx)(n.code,{children:"rectangle.copy(width = 5)"}),", this will effectively create rectangle with width of 5 and height of 4 copied from the other rectangle."]})]}),"\n",(0,i.jsx)(n.h4,{id:"factory",children:"Factory"}),"\n",(0,i.jsx)(n.p,{children:"The primary purpose of factory pattern is to abstract away the complexity of constructing different type of objects. This is useful when we have a common interface or base class, and we have to choose which subclass or implementation we have to create."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'interface Logistics {\n    fun transport()\n}\n\nclass RoadLogistics: Logistics {\n    override fun transport() {\n        println("Transporting via road")\n    }\n}\n\nclass SeaLogistics: Logistics {\n    override fun transport() {\n        println("Transporting via sea")\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"This example demonstrates the use of the factory pattern in the context of logistics. The logistics can be transported differently based on the specific type of transportation method chosen."}),"\n",(0,i.jsx)(n.p,{children:"A traditional way to instantiate logistics would be :"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'fun main() {\n    val delivery = Delivery("New York") // assume this class exist\n\n    // and have the decideTransportation method\n    if (delivery.decideTransportation() == "Road") {\n        val transportation = RoadLogistics()\n        delivery.transport()\n    } else if (delivery.decideTransportation() = "Sea") {\n        val transportation = SeaLogistics()\n        delivery.transport()\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Factory pattern allows us to simplify this creation by making a class dedicated to handle this."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'class LogisticsFactory {\n    fun createLogistics(delivery: Delivery): Logistics {\n        if (delivery.decideTransportation() == "Road") {\n            return RoadLogistics()\n        } else if (delivery.decideTransportation() = "Sea") {\n            return SeaLogistics()\n        }\n    }\n}\n\nfun main() {\n    val delivery = Delivery("New York")\n    val factory = LogisticsFactory()\n    val transportation = factory.createLogistics(delivery)\n    transportation.delivery()\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"LogisticsFactory"})," class do the same thing as we did before. The ",(0,i.jsx)(n.code,{children:"createLogistics"})," decide which class to be constructed based on ",(0,i.jsx)(n.code,{children:"Delivery"}),", and returns it."]}),"\n",(0,i.jsx)(n.h4,{id:"abstract-factory",children:"Abstract Factory"}),"\n",(0,i.jsx)(n.p,{children:"Abstract factory pattern allows us to construct object with a combination of other related families of object without specifying their concrete classes. Abstract factory is achievable using the previous factory pattern implemented in each class."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"class Furniture(val chair: Chair, val table: Table) {}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Let's say we are creating a furniture that consist of ",(0,i.jsx)(n.code,{children:"Chair"})," and ",(0,i.jsx)(n.code,{children:"Table"}),". There are different type of chair and table :"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"interface Chair {}\nclass VictorianChair: Chair {}\nclass ModernChair: Chair {}\n\ninterface Table {}\nclass VictorianTable: Table {}\nclass ModernTable: Table {}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Suppose that we are going to create furniture with ",(0,i.jsx)(n.code,{children:"VictorianChair"})," and ",(0,i.jsx)(n.code,{children:"ModernTable"}),". The traditional way would look like this :"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"fun main() {\n    val chair = VictorianChair()\n    val table = ModernTable()\n    val furniture = Furniture(chair, table)\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The user or the one that construct ",(0,i.jsx)(n.code,{children:"Furniture"})," require the knowledge of concrete class. In other words, it tightly couples the user code to specific implementation. It requires user to manually constructing chair and table. It would make more sense to create a class that is dedicated to create a specific implementation, which user code would depend on instead."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"Hiding your implementation or code details from user can be useful when designing public API, to simplify the code user would use."})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"interface FurnitureFactory {\n    fun createChair(): Chair\n    fun createTable(): Table\n}\n\nclass VictorianFurnitureFactory: FurnitureFactory {\n    override fun createChair(): Chair {\n        return VictorianChair()\n    }\n\n    override fun createTable(): Table {\n        return VictorianTable()\n    }\n}\n\nclass ModernFurnitureFactory: FurnitureFactory {\n    override fun createChair(): Chair {\n        return ModernChair()\n    }\n\n    override fun createTable(): Table {\n        return ModernTable()\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We do this by creating a ",(0,i.jsx)(n.code,{children:"FurnitureFactory"})," interface, which will be implemented by ",(0,i.jsx)(n.code,{children:"VictorianFurnitureFactory"})," and ",(0,i.jsx)(n.code,{children:"ModernFurnitureFactory"})," for victorian and modern furniture, respectively. To actually use it :"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"class Furniture(val chair: Chair, val table: Table) {}\n\nfun main() {\n    val victorianFactory = VictorianFurnitureFactory()\n    val modernFactory = ModernFurnitureFactory()\n\n    val furniture = Furniture(\n        chair = victorianFactory.createChair(),\n        table = modernFactory.createTable()\n    )\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Having factory class become even more useful if the construction of object is complex, just like the previous Factory example."})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>s});var i=t(67294);const a={},r=i.createContext(a);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);