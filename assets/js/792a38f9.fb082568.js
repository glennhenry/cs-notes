"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[266],{28453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>m});var i=n(96540);const t={},a=i.createContext(t);function r(e){const s=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function m(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(a.Provider,{value:s},e.children)}},30582:(e,s,n)=>{n.d(s,{A:()=>i});const i=n.p+"assets/images/minimum-spanning-tree-9ffb81c45da293b3eee846ab35f10c2d.jpg"},45475:(e,s,n)=>{n.d(s,{A:()=>i});const i=n.p+"assets/images/prim-algorithm-dca59832d15ca72c0d76f022f2091494.gif"},67754:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>m,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"data-structures-and-algorithms/minimum-spanning-tree/minimum-spanning-tree","title":"Minimum Spanning Tree","description":"Minimum Spanning Tree","source":"@site/docs/data-structures-and-algorithms/27-minimum-spanning-tree/minimum-spanning-tree.md","sourceDirName":"data-structures-and-algorithms/27-minimum-spanning-tree","slug":"/data-structures-and-algorithms/minimum-spanning-tree","permalink":"/cs-notes/data-structures-and-algorithms/minimum-spanning-tree","draft":false,"unlisted":false,"editUrl":"https://github.com/glennhenry/cs-notes/tree/main/docs/data-structures-and-algorithms/27-minimum-spanning-tree/minimum-spanning-tree.md","tags":[],"version":"current","lastUpdatedBy":"glennhenry","lastUpdatedAt":1723455088000,"frontMatter":{"slug":"/data-structures-and-algorithms/minimum-spanning-tree","id":"minimum-spanning-tree","title":"Minimum Spanning Tree","description":"Minimum Spanning Tree"},"sidebar":"sidebar","previous":{"title":"Topological Sort","permalink":"/cs-notes/data-structures-and-algorithms/topological-sort"},"next":{"title":"Computer Organization & Architecture","permalink":"/cs-notes/computer-organization-and-architecture"}}');var t=n(74848),a=n(28453);const r={slug:"/data-structures-and-algorithms/minimum-spanning-tree",id:"minimum-spanning-tree",title:"Minimum Spanning Tree",description:"Minimum Spanning Tree"},m=void 0,l={},c=[{value:"Prim&#39;s Algorithm",id:"prims-algorithm",level:3}];function h(e){const s={a:"a",annotation:"annotation",br:"br",code:"code",h3:"h3",img:"img",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Main Source:"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Prim%27s_algorithm",children:"Prim's algorithm \u2014 Wikipedia"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.a,{href:"https://youtu.be/cplfcGZmX7I?si=cd3rQ5d0UnaGxECM",children:"Prim's algorithm in 2 minutes \u2014 Michael Sambol"})})}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Minimum Spanning Tree (MST)"})," is a concept in ",(0,t.jsx)(s.a,{href:"/data-structures-and-algorithms/graph",children:"graph"}),", specifically in a ",(0,t.jsx)(s.a,{href:"/data-structures-and-algorithms/graph#weighted",children:"weighted graph"}),", where we need to find the minimum possible total weight for connecting all the vertices. The real world application of this is to make the most effective connection between a set of locations."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.img,{alt:"Minimum spanning tree",src:n(30582).A+"",width:"780",height:"349"}),(0,t.jsx)(s.br,{}),"\n","Source: ",(0,t.jsx)(s.a,{href:"https://www.hackerearth.com/practice/algorithms/graphs/minimum-spanning-tree/tutorial/",children:"https://www.hackerearth.com/practice/algorithms/graphs/minimum-spanning-tree/tutorial/"})]}),"\n",(0,t.jsx)(s.p,{children:"Notice that we don't need to explore the entire graph's edges, we are only needed to connect the vertices. The difficulty of this problem arise when there are a lot of vertices and edges, making us need to choose path carefully, so it can lead to the minimum cost."}),"\n",(0,t.jsx)(s.h3,{id:"prims-algorithm",children:"Prim's Algorithm"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Prim's algorithm"})," is a ",(0,t.jsx)(s.a,{href:"/data-structures-and-algorithms/greedy",children:"greedy algorithm"})," that finds a minimum spanning tree for a ",(0,t.jsx)(s.a,{href:"/data-structures-and-algorithms/graph#weighted",children:"weighted"})," ",(0,t.jsx)(s.a,{href:"/data-structures-and-algorithms/graph#undirected",children:"undirected"})," graph."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"function prim(graph, start):\n    MST = set()\n    PQ = PriorityQueue()\n    visited = set()\n\n    PQ.add(start, 0)\n\n    while PQ is not empty:\n        current = PQ.extractMin()\n\n        if current is not in visited:\n            visited.add(current)\n            MST.add(current)\n\n            for each neighbor in current's neighbors:\n                if neighbor is not in visited:\n                    PQ.add(neighbor, weight(current, neighbor))\n\n    return MST\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Similar to ",(0,t.jsx)(s.a,{href:"/data-structures-and-algorithms/shortest-path#dijkstras-algorithm",children:"Dijkstra's algorithm"}),", it uses priority queue to help to prioritize the minimum weight and a visited set to keep track the visited vertex."]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["It begins from the ",(0,t.jsx)(s.code,{children:"start"})," node, which is initially added to the PQ and extracted immediately."]}),"\n",(0,t.jsx)(s.li,{children:"Ensure that we only visit the node which hasn't been visited."}),"\n",(0,t.jsx)(s.li,{children:"If it hasn't been visited, add it to the visited set and MST set."}),"\n",(0,t.jsx)(s.li,{children:"Iterate over each neighbor of the current vertex, make sure that only neighbors that have not been visited yet are added."}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.img,{alt:"Prim&#39;s algorithm",src:n(45475).A+"",width:"314",height:"323"}),(0,t.jsx)(s.br,{}),"\n","Source: ",(0,t.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Prim%27s_algorithm",children:"https://en.wikipedia.org/wiki/Prim%27s_algorithm"})]}),"\n",(0,t.jsxs)(s.p,{children:["The complexity depends on the graph representation (e.g., adjacency list or adjacency matrix) and the priority queue implementation (e.g, binary heap or Fibonacci heap). Using adjacency list and binary heap, we can obtain ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"E"}),(0,t.jsx)(s.mi,{children:"log"}),(0,t.jsx)(s.mo,{children:"\u2061"}),(0,t.jsx)(s.mi,{children:"V"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(E \\log V)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsxs)(s.span,{className:"mop",children:["lo",(0,t.jsx)(s.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]})," time complexity. Updating a key in the heap takes ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"log"}),(0,t.jsx)(s.mo,{children:"\u2061"}),(0,t.jsx)(s.mi,{children:"V"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(\\log V)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsxs)(s.span,{className:"mop",children:["lo",(0,t.jsx)(s.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]}),", updating it for each edge takes ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"E"}),(0,t.jsx)(s.mi,{children:"log"}),(0,t.jsx)(s.mo,{children:"\u2061"}),(0,t.jsx)(s.mi,{children:"V"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(E \\log V)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsxs)(s.span,{className:"mop",children:["lo",(0,t.jsx)(s.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]}),". The space complexity would be ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"V"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(V)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]}),", which comes from the visited set storing the visited vertices and the heap itself."]})]})}function d(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}}}]);