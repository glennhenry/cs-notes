"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[5881],{77231:(e,s,a)=>{a.r(s),a.d(s,{assets:()=>h,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var n=a(85893),t=a(11151);const r={slug:"/data-structures-and-algorithms/search",id:"search",title:"Search",description:"Search"},i=void 0,l={id:"data-structures-and-algorithms/search/search",title:"Search",description:"Search",source:"@site/docs/data-structures-and-algorithms/13-search/search.md",sourceDirName:"data-structures-and-algorithms/13-search",slug:"/data-structures-and-algorithms/search",permalink:"/cs-notes/data-structures-and-algorithms/search",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/data-structures-and-algorithms/13-search/search.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1708339409,formattedLastUpdatedAt:"Feb 19, 2024",frontMatter:{slug:"/data-structures-and-algorithms/search",id:"search",title:"Search",description:"Search"},sidebar:"sidebar",previous:{title:"Sorting",permalink:"/cs-notes/data-structures-and-algorithms/sorting"},next:{title:"Recursion",permalink:"/cs-notes/data-structures-and-algorithms/recursion"}},h={},c=[{value:"Linear Search",id:"linear-search",level:3},{value:"Binary Search",id:"binary-search",level:3}];function o(e){const s={a:"a",annotation:"annotation",br:"br",code:"code",h3:"h3",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.p,{children:(0,n.jsx)(s.strong,{children:"Main Source :"})}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:(0,n.jsx)(s.strong,{children:(0,n.jsx)(s.a,{href:"/computer-and-programming-fundamentals/data-structures-and-algorithms#basic-type-of-algorithm",children:"Data Structures & Algorithms - Computer & Programming Fundamentals (with some rephrasing)"})})}),"\n"]}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"Search algorithms"})," are algorithm that is used to locate a specific item or element within a collection of data. The collection of data can take various forms, such as an ",(0,n.jsx)(s.a,{href:"/data-structures-and-algorithms/array",children:"array"}),", ",(0,n.jsx)(s.a,{href:"/data-structures-and-algorithms/linked-list",children:"list"}),", ",(0,n.jsx)(s.a,{href:"/data-structures-and-algorithms/tree",children:"tree"}),", ",(0,n.jsx)(s.a,{href:"/data-structures-and-algorithms/graph",children:"graph"}),", or any other data structure."]}),"\n",(0,n.jsxs)(s.p,{children:["This note explains the simple linear and binary search algorithm, other search algorithm for more complex data structure are explained in the other notes. (e.g., ",(0,n.jsx)(s.a,{href:"/data-structures-and-algorithms/traversal#tree-traversal",children:"searching in tree with DFS"}),")."]}),"\n",(0,n.jsx)(s.h3,{id:"linear-search",children:"Linear Search"}),"\n",(0,n.jsxs)(s.p,{children:["Linear search, also known as ",(0,n.jsx)(s.strong,{children:"sequential search"}),", is the simple and intuitive search algorithm that sequentially checks each element in a collection of data until a match is found or the entire collection has been traversed. It is applicable to both sorted and unsorted data."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{children:"function linearSearch(array, target):\n    for i from 0 to length(array) - 1 do:\n        if array[i] equals target then:\n            return i  // Return the index where the target is found\n        end if\n    end for\n\n    return -1  // Return -1 if the target is not found\nend function\n"})}),"\n",(0,n.jsx)(s.p,{children:"Linear search iterates from the beginning of the array/list, then check each element if it is the element we are looking for. If so, we will return the element and complete the search, else continue with the iteration. If we don't find the target element, we typically return -1 to indicate the target is not found."}),"\n",(0,n.jsxs)(s.p,{children:["Linear search results in best ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mi,{children:"O"}),(0,n.jsx)(s.mo,{stretchy:"false",children:"("}),(0,n.jsx)(s.mn,{children:"1"}),(0,n.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(1)"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,n.jsx)(s.span,{className:"mopen",children:"("}),(0,n.jsx)(s.span,{className:"mord",children:"1"}),(0,n.jsx)(s.span,{className:"mclose",children:")"})]})})]})," time, when the target element is at the beginning, average of ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mi,{children:"O"}),(0,n.jsx)(s.mo,{stretchy:"false",children:"("}),(0,n.jsx)(s.mi,{children:"n"}),(0,n.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(n)"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,n.jsx)(s.span,{className:"mopen",children:"("}),(0,n.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,n.jsx)(s.span,{className:"mclose",children:")"})]})})]})," time, and the worst-case scenario in ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mi,{children:"O"}),(0,n.jsx)(s.mo,{stretchy:"false",children:"("}),(0,n.jsx)(s.mi,{children:"n"}),(0,n.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(n)"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,n.jsx)(s.span,{className:"mopen",children:"("}),(0,n.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,n.jsx)(s.span,{className:"mclose",children:")"})]})})]})," time, which occurs when the target element is at the end of the collection. Linear search does nothing other than checking if the element in the array is equal to the target, it requires constant extra memory."]}),"\n",(0,n.jsx)(s.h3,{id:"binary-search",children:"Binary Search"}),"\n",(0,n.jsx)(s.p,{children:"Binary search is a searching algorithm, used for searching an element in a sorted collection."}),"\n",(0,n.jsx)(s.p,{children:"Binary search assumes that the collection is in sorted order, the idea is that, we don't need to look for the target element in the range of elements where they are smaller than the target element. Binary search will simply eliminate the portion of element that we think doesn't make sense to look in for."}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{children:"function binarySearch(array, target):\n    low := 0\n    high := length(array) - 1\n\n    while low <= high do:\n        mid := (low + high) / 2\n        if array[mid] equals target then:\n            return mid  // Return the index where the target is found\n        else if array[mid] < target then:\n            low := mid + 1\n        else:\n            high := mid - 1\n\n    return -1  // Return -1 if the target is not found\nend function\n"})}),"\n",(0,n.jsx)(s.p,{children:"Binary search starts checking in the middle, it checks if the element in the middle is larger or smaller than the target element. If it is smaller, then it will be impossible for our target element to be present in the smaller element range. We will eliminate that portion and search the other range of elements. This will effectively divide the search space by half until the target is found, or the target does not exist in the collection."}),"\n",(0,n.jsxs)(s.p,{children:["Binary search efficiently reduces the search space by half in each iteration, resulting in a logarithmic ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mi,{children:"O"}),(0,n.jsx)(s.mo,{stretchy:"false",children:"("}),(0,n.jsx)(s.mi,{children:"log"}),(0,n.jsx)(s.mo,{children:"\u2061"}),(0,n.jsx)(s.mi,{children:"n"}),(0,n.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(\\log n)"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,n.jsx)(s.span,{className:"mopen",children:"("}),(0,n.jsxs)(s.span,{className:"mop",children:["lo",(0,n.jsx)(s.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,n.jsx)(s.span,{className:"mclose",children:")"})]})})]})," time complexity, where ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsx)(s.mi,{children:"n"})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.4306em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",children:"n"})]})})]})," is the number of elements in the sorted array. It is significantly faster than linear search for large datasets. However, it requires a sorted collection, sorting an unsorted collection first would result longer than linear search, since a typical sorting algorithm requires ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mi,{children:"O"}),(0,n.jsx)(s.mo,{stretchy:"false",children:"("}),(0,n.jsx)(s.mi,{children:"n"}),(0,n.jsx)(s.mi,{children:"log"}),(0,n.jsx)(s.mo,{children:"\u2061"}),(0,n.jsx)(s.mi,{children:"n"}),(0,n.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(n \\log n)"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,n.jsx)(s.span,{className:"mopen",children:"("}),(0,n.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsxs)(s.span,{className:"mop",children:["lo",(0,n.jsx)(s.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,n.jsx)(s.span,{className:"mclose",children:")"})]})})]})," time."]}),"\n",(0,n.jsx)(s.p,{children:"Similar to linear search, binary search require constant memory space. No matter how large the collection is, the low, mid, and high pointer will always store an integer index."}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.img,{alt:"Comparison of linear or sequential and binary search",src:a(41344).Z+"",width:"640",height:"426"}),(0,n.jsx)(s.br,{}),"\n","Source : ",(0,n.jsx)(s.a,{href:"https://tenor.com/view/binary-search-sequence-search-gif-20595028",children:"https://tenor.com/view/binary-search-sequence-search-gif-20595028"})]})]})}function m(e={}){const{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(o,{...e})}):o(e)}},41344:(e,s,a)=>{a.d(s,{Z:()=>n});const n=a.p+"assets/images/search-algorithm-comparison-39acddd07ad4ba584d6aee2e8c46b9e5.gif"},11151:(e,s,a)=>{a.d(s,{Z:()=>l,a:()=>i});var n=a(67294);const t={},r=n.createContext(t);function i(e){const s=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);