"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[8852],{39955:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>l});var s=i(85893),a=i(11151);const t={slug:"/software-engineering/software-principles",id:"software-principles",title:"Software Principles",description:"Software Principles"},r=void 0,o={id:"software-engineering/software-principles/software-principles",title:"Software Principles",description:"Software Principles",source:"@site/docs/software-engineering/02-software-principles/software-principles.md",sourceDirName:"software-engineering/02-software-principles",slug:"/software-engineering/software-principles",permalink:"/cs-notes/software-engineering/software-principles",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/software-engineering/02-software-principles/software-principles.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1712057271,formattedLastUpdatedAt:"Apr 2, 2024",frontMatter:{slug:"/software-engineering/software-principles",id:"software-principles",title:"Software Principles",description:"Software Principles"},sidebar:"sidebar",previous:{title:"Software Process",permalink:"/cs-notes/software-engineering/software-process"},next:{title:"Diagrams",permalink:"/cs-notes/software-engineering/diagrams"}},c={},l=[{value:"OOP",id:"oop",level:3},{value:"DRY",id:"dry",level:3},{value:"KISS",id:"kiss",level:3},{value:"YAGNI",id:"yagni",level:3},{value:"Coupling &amp; Cohesion",id:"coupling--cohesion",level:3},{value:"Law of Demeter (LoD)",id:"law-of-demeter-lod",level:3},{value:"Separation of Concerns (SoC)",id:"separation-of-concerns-soc",level:3},{value:"Dependency Injection",id:"dependency-injection",level:3},{value:"Composition Over Inheritance",id:"composition-over-inheritance",level:3},{value:"Clean Code",id:"clean-code",level:3},{value:"SOLID",id:"solid",level:3},{value:"Single Responsibility Principle (SRP)",id:"single-responsibility-principle-srp",level:4},{value:"Open/Closed Principle (OCP)",id:"openclosed-principle-ocp",level:4},{value:"Liskov Substitution Principle (LSP)",id:"liskov-substitution-principle-lsp",level:4},{value:"Interface Segregation Principle (ISP)",id:"interface-segregation-principle-isp",level:4},{value:"Dependency Inversion Principle (DIP)",id:"dependency-inversion-principle-dip",level:4}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",br:"br",code:"code",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Main Source :"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Various Google searches"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself",children:"Don't repeat yourself - Wikipedia"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/KISS_principle",children:"KISS principle - Wikipedia"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it",children:"You aren't gonna need it - Wikipedia"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Law_of_Demeter",children:"Law of Demeter - Wikipedia"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Separation_of_concerns",children:"Separation of concerns - Wikipedia"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://stackoverflow.com/questions/49002/prefer-composition-over-inheritance",children:"Prefer composition over inheritance? - stackoverflow"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://gist.github.com/wojteklu/73c6914cc446146b8b533c0988cf8d29",children:"Summary of 'Clean code' by Robert C. Martin - wojteklu GitHub Gist"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/SOLID",children:"SOLID - Wikipedia"})," and the 5 articles"]})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Software Principles"})," are collection of guidelines, styles, tips, good practices, by various software and engineers to help to guide the process of developing a good software. By good software, it means they are reliable, maintainable, scalable, and many more listed in ",(0,s.jsx)(n.a,{href:"/software-engineering#software-characteristics",children:"software characteristics"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"oop",children:"OOP"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/computer-and-programming-fundamentals/object-oriented-programming",children:"Object-Oriented Programming (OOP)"})," is a common paradigm used in the world of software engineering. The elements of OOP such as classes, objects, inheritance, polymorphism, encapsulation, and many more promotes code organization, reusability, and modularity in a software system. These elements serve as the foundation of other software principle that we will see later."]}),"\n",(0,s.jsxs)(n.p,{children:["We will see an example that demonstrate the benefits OOP about code reusing (in ",(0,s.jsx)(n.a,{href:"https://kotlinlang.org",children:"Kotlin programming language"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"Non-OOP approach :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'val employee1Name = "John Doe"\nval employee1Age = 30\nval employee1Department = "Sales"\n\nval employee2Name = "Jane Smith"\nval employee2Age = 35\nval employee2Department = "Marketing"\n\nfun introduceEmployee(name: String, age: Int, department: String) {\n    println("Hello, my name is $name. I am $age years old and work in the $department department.")\n}\n\nintroduceEmployee(employee1Name, employee1Age, employee1Department)\nintroduceEmployee(employee2Name, employee2Age, employee2Department)\n'})}),"\n",(0,s.jsx)(n.p,{children:"OOP approach :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'class Employee(val name: String, val age: Int, val department: String) {\n    fun introduce() {\n        println("Hello, my name is $name. I am $age years old and work in the $department department.")\n    }\n}\n\nval employee1 = Employee("John Doe", 30, "Sales")\nval employee2 = Employee("Jane Smith", 35, "Marketing")\n\nemployee1.introduce()\nemployee2.introduce()\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The code is about storing employee's data and have a function that can introduce them. The Non-OOP approach require us to make a bunch of variable just to store the data, while in OOP approach, we can make a class and represent the employee as an ",(0,s.jsx)(n.code,{children:"Employee"})," object. Class and objects provides a structured and organized way to encapsulate related data and behavior, leading to more maintainable code."]}),"\n",(0,s.jsx)(n.h3,{id:"dry",children:"DRY"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"DRY (Don't Repeat Yourself)"}),' is a software development principle that promotes code reuse and avoids duplication. The DRY principle is stated as "Every piece of knowledge must have a single, unambiguous, authoritative representation within a system".']}),"\n",(0,s.jsx)(n.p,{children:"When code is repeated in multiple places, it becomes harder to update or modify because changes need to be made in multiple locations, increasing the chances of introducing bugs and inconsistencies. When a change is required, it only needs to be made in one place, making maintenance and updates more efficient and less error-prone."}),"\n",(0,s.jsx)(n.p,{children:"Non-DRY approach :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'fun main() {\n    println("Hello, Alice!")\n    println("Hello, Bob!")\n    println("Hello, Charlie!")\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"DRY approach :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'fun greet(name: String) {\n    println("Hello, $name!")\n}\n\nfun main() {\n    val names = listOf("Alice", "Bob", "Charlie")\n    for (name in names) {\n        greet(name)\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The code is about storing names and having a function to greet them. Non-DRY approach manually call ",(0,s.jsx)(n.code,{children:"println"})," thrice with the name data. If we somehow wanted to change the greet message, we will need to modify all the three line of code. The DRY approach helps us to avoid printing the greeting message by putting it all in one function, and then integrate it with a for loop."]}),"\n",(0,s.jsx)(n.p,{children:"The previous OOP example also follows this DRY principle."}),"\n",(0,s.jsx)(n.h3,{id:"kiss",children:"KISS"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"KISS (Keep It Simple, Stupid)"})," is a software development principle that promotes emphasizes the importance of simplicity. The principle suggests that systems and code should be kept as simple as possible, avoiding unnecessary complexity."]}),"\n",(0,s.jsx)(n.p,{children:"An example of unnecessary abstracted code :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'class Parity(val num: Int) {\n    var isEven = false\n\n    fun updateIsEven() {\n        if (decideIsEven(num)) {\n            numIsEven()\n        } else {\n            numIsNotEven()\n        }\n    }\n\n    fun numIsEven() {\n        isEven = true\n    }\n\n    fun numIsNotEven() {\n        isEven = false\n    }\n\n    fun decideIsEven(n: Int): Boolean {\n        if (n % 2 == 0) {\n            return true\n        } else {\n            return false\n        }\n    }\n\n    fun getIsEven(): Boolean {\n        return isEven\n    }\n}\n\nfun main() {\n    val parity = Parity(3)\n    parity.updateIsEven()\n    println("Is 3 even?: ${parity.getIsEven()}")\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This code creates a class that is supposed to handle the parity of a number. The purpose of introducing a class in this code is to create an abstraction, this way the function caller doesn't need to handle the parity logic. In reality, the handling of parity is actually very simple and doesn't need to be overly abstracted like above. The checks for ",(0,s.jsx)(n.code,{children:"num % 2 == 0"})," to determine if a number is even is a relatively well-known concept."]}),"\n",(0,s.jsxs)(n.p,{children:["We don't need to make function for every single expression we are executing. Making a function just to set a field variable is unnecessary. Making a getter to get the ",(0,s.jsx)(n.code,{children:"isEven"})," variable is also not needed, because in Kotlin properties can have implicit getters generated automatically."]}),"\n",(0,s.jsx)(n.h3,{id:"yagni",children:"YAGNI"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"YAGNI (You Ain't Gonna Need It)"})," principle suggests developers should avoid adding functionality until it is necessary. It is typically associated with ",(0,s.jsx)(n.a,{href:"/software-engineering/software-process#agile",children:"agile development methodology"}),", where the development style revolve around quick incremental software development."]}),"\n",(0,s.jsx)(n.p,{children:"Its main idea is to focus on delivering the minimum viable product (MVP) or the necessary features to meet the immediate requirements, rather than adding functionality that may or may not be needed in the future."}),"\n",(0,s.jsx)(n.p,{children:"There are some factors to consider when developing functionality :"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Development Costs"})," : Resources required to build the software, such as developers' salaries, project management expenses, software licenses, development tools, and infrastructure costs."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Maintenance and Repair Costs"})," : There is a potential that the functionality may need bug fixes, updates, security patches, or technical support."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Unnecessary development sacrifice time and effort for future development and maintenance, possibly introducing ",(0,s.jsx)(n.strong,{children:"technical debt"}),". Technical debt is a consequence of software development bad decisions that keep accumulating costs and challenges as the software evolves, similar to financial debt that accumulates interest over time."]}),"\n",(0,s.jsx)(n.h3,{id:"coupling--cohesion",children:"Coupling & Cohesion"}),"\n",(0,s.jsxs)(n.p,{children:["Both describe the relationship and dependency between software components. ",(0,s.jsx)(n.strong,{children:"Coupling"})," refers to the inter-component interaction, while ",(0,s.jsx)(n.strong,{children:"cohesion"})," refers to the intra-component interaction."]}),"\n",(0,s.jsx)(n.p,{children:"Cohesion is the degree to which elements within a component or module are related and work together to accomplish a single, well-defined purpose."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"High Cohesion"})," : High cohesion indicates that the elements within a component are closely related and focused on a specific functionality or responsibility. A highly cohesive component performs a single task or represents a cohesive set of related tasks, making it easier to understand, reuse, and maintain."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Low Cohesion"})," : Low cohesion occurs when a component has multiple unrelated responsibilities or tasks. This can lead to a component that is difficult to understand, modify, and test. Low cohesion may also result in code duplication and reduced reusability."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"On the other hand, coupling describe the interaction between modules."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Loose Coupling"})," : In a loosely coupled system, components are independent and interact through well-defined interfaces. Loose coupling principle encourages components to have minimal dependencies on each other. Changes to one component have minimal impact on other components, making the system more flexible, modular, and easier to maintain."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tight Coupling"})," : Tight coupling occurs when components have strong dependencies and rely heavily on each other's internal details or implementation. In a tightly coupled system, changes in one component may require corresponding changes in multiple other components. This can lead to code that is harder to modify, test, and maintain."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"Cohesion and coupling",src:i(80431).Z+"",width:"650",height:"575"}),(0,s.jsx)(n.br,{}),"\n","Source : ",(0,s.jsx)(n.a,{href:"https://www.boardinfinity.com/blog/cohesion/",children:"top"}),", ",(0,s.jsx)(n.a,{href:"https://www.engati.com/glossary/cohesion-and-coupling",children:"down"})]}),"\n",(0,s.jsx)(n.p,{children:"Below are code that demonstrate cohesion and coupling."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Low Cohesion :"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class Customer {\n    fun calculateOrderTotal(order: Order) {}\n    fun sendOrderConfirmationEmail(order: Order) {}\n    fun updateCustomerInformation(customerData: CustomerData) {}\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"High Cohesion :"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class OrderProcessor {\n    fun processOrder(order: Order) {\n        validateOrder(order)\n        calculateOrderTotal(order)\n        updateInventory(order)\n        notifyCustomer(order)\n    }\n    private fun validateOrder(order: Order) {}\n    private fun calculateOrderTotal(order: Order) {}\n    private fun updateInventory(order: Order) {}\n    private fun notifyCustomer(order: Order) {}\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The class in low cohesion code have their own responsibility within the class. On the other hand, the high cohesion code focuses on the ",(0,s.jsx)(n.code,{children:"processOrder"})," method, where it calls the other private method."]}),"\n",(0,s.jsxs)(n.p,{children:["The high cohesion code may be preferable as it makes the caller easier to interact with the class. The caller can just call the method ",(0,s.jsx)(n.code,{children:"processOrder"})," passing in an ",(0,s.jsx)(n.code,{children:"Order"})," to process it. In contrast, in the low cohesion code, caller requires an understanding of how ",(0,s.jsx)(n.code,{children:"Customer"})," class process order. (i.e., should we call ",(0,s.jsx)(n.code,{children:"sendOrderConfirmationEmail"})," or ",(0,s.jsx)(n.code,{children:"updateCustomerInformation"})," first?)"]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["We typically call component that invokes or calls a function or method ",(0,s.jsx)(n.strong,{children:"caller"}),", while the one that is being invoked or called is called ",(0,s.jsx)(n.strong,{children:"callee"}),"."]})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Tight Coupling :"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class UserService {\n    private val userRepository = UserRepository()\n\n    fun getUserById(userId: String): User {\n        return userRepository.getUserById(userId)\n    }\n\n    fun saveUser(user: User) {\n        userRepository.saveUser(user)\n    }\n}\n\nclass UserRepository {\n    fun getUserById(userId: String): User {}\n    fun saveUser(user: User) {}\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Loose Coupling :"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"interface UserRepository {\n    fun getUserById(userId: String): User\n    fun saveUser(user: User)\n}\n\nclass UserService(private val userRepository: UserRepository) {\n    fun getUserById(userId: String): User {\n        return userRepository.getUserById(userId)\n    }\n\n    fun saveUser(user: User) {\n        userRepository.saveUser(user)\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"UserService"})," class in tight coupling code depends a lot on ",(0,s.jsx)(n.code,{children:"UserRepository"})," class. By depend, it means that the class really need to suit their method and the way of how it operates based on the class it depends on. If somehow we want to change the behavior of ",(0,s.jsx)(n.code,{children:"UserRepository"}),", we will need to change the ",(0,s.jsx)(n.code,{children:"UserService"})," as well. Tight coupling decrease flexibility and maintainability."]}),"\n",(0,s.jsxs)(n.p,{children:["On the other hand, the loose coupling code introduce an interface, which allows for different implementation of ",(0,s.jsx)(n.code,{children:"UserRepository"})," to be provided for ",(0,s.jsx)(n.code,{children:"UserService"})," class. The ",(0,s.jsx)(n.code,{children:"UserService"})," depend on the interface, and the implementor adhere to it. A modification to ",(0,s.jsx)(n.code,{children:"UserRepository"})," behavior doesn't require us to modify many things, this is because they are based on the interface contract."]}),"\n",(0,s.jsxs)(n.p,{children:["The contract is nothing but a specification that the method ",(0,s.jsx)(n.code,{children:"getUserById"})," must take a ",(0,s.jsx)(n.code,{children:"userId"})," of type ",(0,s.jsx)(n.code,{children:"String"})," and return an object ",(0,s.jsx)(n.code,{children:"User"}),", similar to the ",(0,s.jsx)(n.code,{children:"saveUser"})," method. This allows us to create a variety of class that may have different way of processing the data internally."]}),"\n",(0,s.jsx)(n.h3,{id:"law-of-demeter-lod",children:"Law of Demeter (LoD)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"LoD (Law of Demeter)"})," is a design principle that promotes loose coupling and encapsulation in ",(0,s.jsx)(n.a,{href:"/computer-and-programming-fundamentals/object-oriented-programming",children:"object-oriented programming"}),". The principle states that an object should have limited knowledge about other objects and should only interact with its immediate neighbors."]}),"\n",(0,s.jsxs)(n.p,{children:["There are three principles of LoD, based on ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Law_of_Demeter",children:"Wikipedia"})," :"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Each unit should have only limited knowledge about other units: only units "closely" related to the current unit.'}),"\n",(0,s.jsx)(n.li,{children:"Each unit should only talk to its friends; don't talk to strangers."}),"\n",(0,s.jsx)(n.li,{children:"Only talk to your immediate friends."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["An object could have dependency to other object, meaning it relies on another object to fulfill certain tasks or provide specific functionality. We call the object that it depends on a ",(0,s.jsx)(n.strong,{children:"friend"})," or ",(0,s.jsx)(n.strong,{children:"neighbor"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The principle states that an object should have limited knowledge about its friend. One of the benefits of an object with limited knowledge about its companion can be seen in the case of designing a public API. A random person using your API shouldn't need to understand the inner working of your API too much, because that is the point of API, to provide a high level of abstraction."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"LoD principle",src:i(83278).Z+"",width:"655",height:"364"}),(0,s.jsx)(n.br,{}),"\n","Source : ",(0,s.jsx)(n.a,{href:"https://blog.knoldus.com/the-law-of-demeter/",children:"https://blog.knoldus.com/the-law-of-demeter/"})]}),"\n",(0,s.jsx)(n.p,{children:"Let's say we are making an API that lets user (developer) to store book name data."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'val dm = DataManager()\ndm.saveData("Software Engineering 9th Edition by Ian Sommerville")\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We can save data by just calling ",(0,s.jsx)(n.code,{children:"saveData"})," method. Now under the hood, the API may use SQLite database to actually store the data."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class DataManager(private val databaseManager: DatabaseManager) {\n    fun saveData(data: String) {\n        // preprocess the data...\n        databaseManager.saveToDB(data)\n    }\n}\n\nclass DatabaseManager(private val db: SQLite) {\n    fun saveToDB(data: String) {\n        db.initialize()\n        db.syncWithRemoteServer()\n        // other database setup here...\n        db.save(data)\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The point of this API is to abstract away the process of saving data to database. ",(0,s.jsx)(n.code,{children:"DataManager"})," is responsible for handling data, including preprocessing it and saving it to the database. The process of saving to database is abstracted again by ",(0,s.jsx)(n.code,{children:"DatabaseManager"}),", it doesn't even know which database it is interacting to. Finally, the ",(0,s.jsx)(n.code,{children:"DatabaseManager"})," choose ",(0,s.jsx)(n.code,{children:"SQLite"})," as its database, and it contains the actual code that interact with database."]}),"\n",(0,s.jsxs)(n.p,{children:["The application of LoD principle in this example can be seen in the ",(0,s.jsx)(n.code,{children:"DataManager"})," class. It considers ",(0,s.jsx)(n.code,{children:"SQLite"})," as a stranger, and they don't interact directly. They don't even know each other detail, ",(0,s.jsx)(n.code,{children:"DataManager"})," is not responsible for instantiating the database."]}),"\n",(0,s.jsx)(n.h3,{id:"separation-of-concerns-soc",children:"Separation of Concerns (SoC)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Separation of Concerns (SoC)"})," is a principle for dividing a complex system into distinct and independent parts, where each part addresses a specific concern or responsibility."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Concern"}),' is a specific aspect or responsibility of a software system. It represents a distinct functionality or set of related behaviors that can be identified and separated from other parts of the system. For example, in a web application, concerns could include user authentication, database access, business logic, user interface rendering, logging, and error handling. These are general concern, concern can be as specific as "the name of which class to instantiate".']}),"\n",(0,s.jsxs)(n.p,{children:["In SoC, a software system should be divided into modules or components, and each module should be responsible for a single concern or functionality. In the example of Law of Demeter, ",(0,s.jsx)(n.code,{children:"DataManager"})," chose to not handle database connection. It instead communicates with an intermediary, which is ",(0,s.jsx)(n.code,{children:"DatabaseManager"}),". The example demonstrates separation of concerns, where we delegate the database related task to class that is supposed to handle these."]}),"\n",(0,s.jsxs)(n.p,{children:["SoC allows for code to be modular. If ",(0,s.jsx)(n.code,{children:"DataManager"})," were to communicate directly with ",(0,s.jsx)(n.code,{children:"SQLite"})," database, then if there exist another class that interact with database, we would need to repeat the similar code (i.e., setting up the database). Modularity allows for code reuse, as individual modules can be used in different contexts or projects."]}),"\n",(0,s.jsx)(n.h3,{id:"dependency-injection",children:"Dependency Injection"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Dependency Injection (DI)"}),' is a technique used to achieve loose coupling and modularity in software engineering. If an object depends on another object, the object must be "injected" into the class rather than the class creating them internally.']}),"\n",(0,s.jsx)(n.p,{children:"Dependency injection is typically done through interface and provided via constructor. To demonstrate, consider this example."}),"\n",(0,s.jsx)(n.p,{children:"Without DI :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'// Service interface\ninterface MessageService {\n    fun getMessage(): String\n    fun isMessageAvailable(): Boolean\n}\n\n// Implementation of MessageService\nclass EmailService : MessageService {\n    override fun getMessage(): String {\n        return "Email message"\n    }\n\n    override fun isMessageAvailable(): String {\n        return true // for simplicity, let\'s say message is always available\n    }\n}\n\n// Class that directly creates an instance of EmailService\nclass MessageBroadcaster {\n    private val messageService: MessageService = EmailService()\n\n    fun broadcast() {\n        while (messageService.isMessageAvailable()) {\n            val message = messageService.getMessage()\n            println("Broadcast: $message")\n        }\n    }\n}\n\nfun main() {\n    // Using MessageProcessorWithoutDI directly\n    val broadcaster = MessageBroadcaster()\n    broadcaster.broadcast()\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["A message service is a service that should provide message, we should be able to retrieve the message using ",(0,s.jsx)(n.code,{children:"getMessage()"})," and check its availability using ",(0,s.jsx)(n.code,{children:"isMessageAvailable()"}),". Let's say we are making an email service, so we will make a class called ",(0,s.jsx)(n.code,{children:"EmailService"})," that implements ",(0,s.jsx)(n.code,{children:"MessageService"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A message broadcaster is supposed to broadcast the latest message from the service. A message broadcaster without DI would instantiate its own service inside the class (look at ",(0,s.jsx)(n.code,{children:"private val messageService: MessageService = EmailService()"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["The problem without DI arise when we wanted to have different instance of service, maybe ",(0,s.jsx)(n.code,{children:"EmailService"})," and ",(0,s.jsx)(n.code,{children:"UserService"}),". We can either make an entirely new broadcaster class or just instantiate an instance of ",(0,s.jsx)(n.code,{children:"UserService"})," inside ",(0,s.jsx)(n.code,{children:"MessageBroadcaster"}),". However, the latter is probably not an ideal solution. It introduces tight coupling and makes it difficult to replace or switch to a different implementation without modifying the class itself."]}),"\n",(0,s.jsx)(n.p,{children:"With DI :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'// Service interface\ninterface MessageService {\n    fun getMessage(): String\n    fun isMessageAvailable(): Boolean\n}\n\n// Implementation of MessageService\nclass EmailService : MessageService {\n    override fun getMessage(): String {\n        return "Email message"\n    }\n\n    override fun isMessageAvailable(): String {\n        return true // for simplicity, let\'s say message is always available\n    }\n}\n\n// MessageService in constructor now\nclass MessageBroadcaster(private val messageService: MessageService) {\n    fun broadcast() {\n        while (messageService.isMessageAvailable()) {\n            val message = messageService.getMessage()\n            println("Broadcast: $message")\n        }\n    }\n}\n\nclass UserService: MessageService {\n    /* ... */\n}\n\nfun main() {\n    // Creating an instance of EmailService (dependency)\n    val emailService = EmailService()\n\n    // Injecting the dependency into MessageBroadcaster\n    val emailBroadcaster = MessageBroadcaster(emailService)\n\n    // Easily create another type of MessageBroadcaster\n    val userService = UserService()\n    val userBroadcaster = MessageBroadcaster(userService)\n\n    // Using MessageBroadcaster with injected dependency\n    emailBroadcaster.processMessage()\n    userBroadcaster.processMessage()\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"MessageBroadcaster"})," no longer instantiates an instance of ",(0,s.jsx)(n.code,{children:"MessageService"})," itself; instead, it accepts whatever is provided to it through the constructor. This increases flexibility and allows us to create different types of ",(0,s.jsx)(n.code,{children:"MessageBroadcaster"}),". We can make implementation of ",(0,s.jsx)(n.code,{children:"MessageService"})," as we want, and provide it to ",(0,s.jsx)(n.code,{children:"MessageBroadcaster"})," easily."]}),"\n",(0,s.jsx)(n.h3,{id:"composition-over-inheritance",children:"Composition Over Inheritance"}),"\n",(0,s.jsxs)(n.p,{children:["In OOP, there is a concept called ",(0,s.jsx)(n.a,{href:"/computer-and-programming-fundamentals/object-oriented-programming#inheritance",children:"inheritance"}),". Inheritance allows a class to inherit all the properties and behaviors from a parent class. While inheritance can be useful in some cases, it can also lead to a rigid and inflexible class hierarchy. Inheritance creates a tight coupling between classes, making it difficult to modify or extend the behavior of a class without affecting other classes in the hierarchy."]}),"\n",(0,s.jsxs)(n.p,{children:["Inheritance is often associated with an ",(0,s.jsx)(n.strong,{children:'"is-a" relationship'}),". When a class inherits from another class, it is stating that the derived class is a specialized version of the base class. The derived class shares the characteristics and behaviors of the base class and adds additional features or overrides existing ones."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Composition"}),", on the other hand, involves building complex objects by combining simpler objects or components. Instead of inheriting behavior from a parent class, an object is composed of other objects that provide the desired functionality. We often refer composition as a ",(0,s.jsx)(n.strong,{children:'"has-a" relationship'}),", signifying that one class has another class as part of its structure. This approach promotes loose coupling and flexibility in the design."]}),"\n",(0,s.jsx)(n.p,{children:"An example of code with inheritance :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"open class Manufacturer(open val name: String)\n\nclass Car(\n    override val name: String, val model: String, val color: String\n) : Manufacturer(name)\n"})}),"\n",(0,s.jsx)(n.p,{children:'Inheritance is not suitable for this code. While a car is associated with a manufacturer, but a car doesn\'t have an "is-a" relationship. A car is not a manufacturer, but rather associated with particular manufacturer.'}),"\n",(0,s.jsxs)(n.p,{children:["A scenario that would be suitable with inheritance is ",(0,s.jsx)(n.code,{children:"Person"})," and ",(0,s.jsx)(n.code,{children:"Employee"})," class. A person is a general representation of person, while an employee is a specialized person. An employee can definitely inherit a person and extend its properties and behavior."]}),"\n",(0,s.jsxs)(n.p,{children:["Here's how ",(0,s.jsx)(n.code,{children:"Manufacturer"})," and ",(0,s.jsx)(n.code,{children:"Car"})," class would look like with composition :"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class Manufacturer(open val name: String)\n\nclass Car(\n    val manufacturer: Manufacturer,\n    val model: String,\n    val color: String\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Instead of inheriting the manufacturer, we chose to include it inside car."}),"\n",(0,s.jsx)(n.p,{children:"In summary, the principle of composition over inheritance doesn't mean we have use composition all the time. It suggests that, in certain cases, it is preferable to favor composition over inheritance when the class is actually composed of the other class. Inheritance is not the only choice when a class has particular characteristics of another class."}),"\n",(0,s.jsx)(n.h3,{id:"clean-code",children:"Clean Code"}),"\n",(0,s.jsx)(n.p,{children:"The definition of clean code typically refers to well-structured, readable, and maintainable code that follows best practices and conventions to make it is easy to understand and modify."}),"\n",(0,s.jsx)(n.p,{children:"Some principles of clean code :"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Following standard conventions (e.g., language or team standard)."}),"\n",(0,s.jsx)(n.li,{children:"Following code principles such as KISS, DRY, etc."}),"\n",(0,s.jsx)(n.li,{children:"Following design principles such as dependency injection, Law of Demeter, etc."}),"\n",(0,s.jsx)(n.li,{children:"Pronounceable, searchable, descriptive, and meaningful naming of identifier."}),"\n",(0,s.jsx)(n.li,{children:"Function can be made small and focus on one logic at a time."}),"\n",(0,s.jsx)(n.li,{children:'Adding comment that explains "why" rather than "what".'}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"solid",children:"SOLID"}),"\n",(0,s.jsx)(n.p,{children:"SOLID principles is a set of five design principles aimed to make OOP code more understandable, flexible, and maintainable."}),"\n",(0,s.jsx)(n.h4,{id:"single-responsibility-principle-srp",children:"Single Responsibility Principle (SRP)"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"A class should have only one reason to change, meaning it should have a single responsibility."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.code,{children:"Order"})," class may have a ",(0,s.jsx)(n.code,{children:"calculateDiscount()"})," method. Upon a successful order, we may want to send an email the customer. The email contains order information, which ",(0,s.jsx)(n.code,{children:"Order"})," class have. It will be much easier to have ",(0,s.jsx)(n.code,{children:"sendEmail()"})," method in the ",(0,s.jsx)(n.code,{children:"Order"})," class, but this violates SRP principle. Violation of SRP introduces tight coupling and the mixing of unrelated code together. An alternative would be making another class, such as ",(0,s.jsx)(n.code,{children:"EmailSender"}),", which is responsible for sending emails."]}),"\n",(0,s.jsx)(n.h4,{id:"openclosed-principle-ocp",children:"Open/Closed Principle (OCP)"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. This principle encourages designing systems that can be easily extended with new functionality without modifying existing code."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Some choices to implement OCP includes using interfaces, abstract classes, composition, dependency injection, and generics."}),"\n",(0,s.jsx)(n.h4,{id:"liskov-substitution-principle-lsp",children:"Liskov Substitution Principle (LSP)"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program. This principle ensures that subtypes adhere to the behavior expected from their base types."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["A common example illustrating LSP principle is ",(0,s.jsx)(n.code,{children:"Rectangle"})," and ",(0,s.jsx)(n.code,{children:"Square"})," class that inherits ",(0,s.jsx)(n.code,{children:"Shape"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"open class Rectangle(val width: Int, val height: Int) {\n    open fun setWidth(width: Int) {\n        this.width = width\n    }\n\n    open fun setHeight(height: Int) {\n        this.height = height\n    }\n}\n\nclass Square(val sideLength: Int) : Rectangle(sideLength, sideLength) {\n    override fun setWidth(width: Int) {\n        sideLength = width\n    }\n\n    override fun setHeight(height: Int) {\n        sideLength = height\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The LSP principle states that we should be able to treat subclass interchangeably with the superclass without having unexpected behavior. This mean we can treat ",(0,s.jsx)(n.code,{children:"Square"})," as ",(0,s.jsx)(n.code,{children:"Rectangle"}),". A rectangle have method ",(0,s.jsx)(n.code,{children:"setWidth"})," and ",(0,s.jsx)(n.code,{children:"setHeight"}),", treating ",(0,s.jsx)(n.code,{children:"Square"})," as ",(0,s.jsx)(n.code,{children:"Rectangle"})," would mean we can set its width and height independently. However, this violates the nature properties of square, where its side should be equal, and yet we change them independently."]}),"\n",(0,s.jsxs)(n.p,{children:["A solution for this would be making ",(0,s.jsx)(n.code,{children:"Square"})," to not inherit ",(0,s.jsx)(n.code,{children:"Rectangle"}),", maybe inherit a more general class like ",(0,s.jsx)(n.code,{children:"Shape"}),". Another way to solve this is simply updating the width in ",(0,s.jsx)(n.code,{children:"setHeight"})," and updating the height in the ",(0,s.jsx)(n.code,{children:"setWidth"})," method, although this sounds counter-intuitive."]}),"\n",(0,s.jsx)(n.h4,{id:"interface-segregation-principle-isp",children:"Interface Segregation Principle (ISP)"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Clients should not be forced to depend on interfaces they do not use. This principle advises breaking down large interfaces into smaller, more focused ones, tailored to the specific needs of clients."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Consider a base class ",(0,s.jsx)(n.code,{children:"Animal"}),", it could have method ",(0,s.jsx)(n.code,{children:"eat()"})," and ",(0,s.jsx)(n.code,{children:"sleep()"}),". We may have ",(0,s.jsx)(n.code,{children:"Dog"}),", ",(0,s.jsx)(n.code,{children:"Cat"}),", etc., that inherits the base class ",(0,s.jsx)(n.code,{children:"Animal"}),". As our class hierarchy get larger, we may need more method such as ",(0,s.jsx)(n.code,{children:"fly()"}),". However, some of animal may not be able to fly, such as penguin. Because penguin inherits ",(0,s.jsx)(n.code,{children:"Animal"}),", we are required to implement it. A way to avoid this is to implement the method with meaningless body, but this violates the principle."]}),"\n",(0,s.jsxs)(n.p,{children:["A way to adhere ISP principle is splitting the class or interface hierarchy into a smaller and specific ones. So, we could make a subclass ",(0,s.jsx)(n.code,{children:"FlyingAnimal"})," that inherits ",(0,s.jsx)(n.code,{children:"Animal"}),", and move the behavior related to flying inside the ",(0,s.jsx)(n.code,{children:"FlyingAnimal"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"dependency-inversion-principle-dip",children:"Dependency Inversion Principle (DIP)"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"High-level modules should not depend on low-level modules. Both should depend on abstractions. This principle promotes loose coupling and allows for easier substitution of dependencies."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'class EmailSender {\n    fun sendEmail(message: String) {\n        println("Sending email: $message")\n    }\n}\n\nclass NotificationService {\n    private val emailSender = EmailSender()\n\n    fun sendEmailNotification(message: String) {\n        emailSender.sendEmail(message)\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, the ",(0,s.jsx)(n.code,{children:"NotificationService"})," is the higher level module that we use that depends on ",(0,s.jsx)(n.code,{children:"EmailSender"}),". The behavior or ",(0,s.jsx)(n.code,{children:"NotificationService"})," is dictated by ",(0,s.jsx)(n.code,{children:"EmailSender"}),", such as the requirement of passing ",(0,s.jsx)(n.code,{children:"message"})," and calling the ",(0,s.jsx)(n.code,{children:"sendEmail"})," method. Think of ",(0,s.jsx)(n.code,{children:"EmailSender"})," as a public API, if we change its behavior (e.g., changing parameters), all the user using the ",(0,s.jsx)(n.code,{children:"NotificationService"})," would need to change its behavior as well, which is not favorable. Furthermore, the cost of this become larger as we have a long chain of dependency within the system."]}),"\n",(0,s.jsx)(n.p,{children:"A code following dependency inversion would look like this :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'interface MessageSender {\n    fun sendMessage(message: String)\n}\n\nclass EmailSender : MessageSender {\n    override fun sendMessage(message: String) {\n        println("Sending email: $message")\n    }\n}\n\nclass NotificationService(private val sender: MessageSender) {\n    fun sendNotification(message: String) {\n        sender.sendMessage(message)\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"NotificationService"})," now depend on the ",(0,s.jsx)(n.code,{children:"MessageSender"})," interface, which can be implemented by various type of sender, including ",(0,s.jsx)(n.code,{children:"EmailSender"}),". If somehow ",(0,s.jsx)(n.code,{children:"EmailSender"})," need to change, all it needs is to follow the interface contract. It becomes decoupled from the specific implementation details of the message sending logic, allowing for greater flexibility and modularity."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"Dependency inversion",src:i(37516).Z+"",width:"532",height:"265"}),(0,s.jsx)(n.br,{}),"\n","Source : ",(0,s.jsx)(n.a,{href:"https://levelup.gitconnected.com/solid-programming-for-arduino-the-dependency-inversion-principle-4ce3bdb787d1",children:"https://levelup.gitconnected.com/solid-programming-for-arduino-the-dependency-inversion-principle-4ce3bdb787d1"})]})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},80431:(e,n,i)=>{i.d(n,{Z:()=>s});const s=i.p+"assets/images/cohesion-coupling-cddf66e3155590235fa9b95ebc73f607.png"},37516:(e,n,i)=>{i.d(n,{Z:()=>s});const s=i.p+"assets/images/dependency-inversion-2af0841905ffe6d2d1975bb6b7af7f8f.png"},83278:(e,n,i)=>{i.d(n,{Z:()=>s});const s=i.p+"assets/images/lod-efcf1bd4b1625494b56976cef32e1ead.png"},11151:(e,n,i)=>{i.d(n,{Z:()=>o,a:()=>r});var s=i(67294);const a={},t=s.createContext(a);function r(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);