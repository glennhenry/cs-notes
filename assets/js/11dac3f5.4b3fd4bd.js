"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[9969],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>u});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=p(a),h=r,u=c["".concat(l,".").concat(h)]||c[h]||d[h]||i;return a?n.createElement(u,s(s({ref:t},m),{},{components:a})):n.createElement(u,s({ref:t},m))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[c]="string"==typeof e?e:r,s[1]=o;for(var p=2;p<i;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},58211:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var n=a(87462),r=(a(67294),a(3905));const i={slug:"/deep-learning/variational-autoencoder",id:"variational-autoencoder",title:"Variational Autoencoder",description:"Variational Autoencoder"},s=void 0,o={unversionedId:"deep-learning/variational-autoencoder/variational-autoencoder",id:"deep-learning/variational-autoencoder/variational-autoencoder",title:"Variational Autoencoder",description:"Variational Autoencoder",source:"@site/docs/deep-learning/12-variational-autoencoder/variational-autoencoder.md",sourceDirName:"deep-learning/12-variational-autoencoder",slug:"/deep-learning/variational-autoencoder",permalink:"/cs-notes/deep-learning/variational-autoencoder",draft:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/deep-learning/12-variational-autoencoder/variational-autoencoder.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1697109148,formattedLastUpdatedAt:"Oct 12, 2023",frontMatter:{slug:"/deep-learning/variational-autoencoder",id:"variational-autoencoder",title:"Variational Autoencoder",description:"Variational Autoencoder"},sidebar:"sidebar",previous:{title:"Autoencoder",permalink:"/cs-notes/deep-learning/autoencoder"},next:{title:"GAN",permalink:"/cs-notes/deep-learning/gan"}},l={},p=[{value:"Encoder",id:"encoder",level:3},{value:"Sampling",id:"sampling",level:3},{value:"Interpolation",id:"interpolation",level:4},{value:"Decoder",id:"decoder",level:3},{value:"Loss Calculation",id:"loss-calculation",level:4},{value:"Reparameterization Trick",id:"reparameterization-trick",level:3}],m={toc:p},c="wrapper";function d(e){let{components:t,...i}=e;return(0,r.kt)(c,(0,n.Z)({},m,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Main Source :")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("a",{parentName:"strong",href:"https://youtu.be/FzYBn1slG8w?si=5BBrGBCCEnZGe_N5"},"Variational Autoencoders simplified - Prof. Ryan Ahmed"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("a",{parentName:"strong",href:"https://youtu.be/9zKuYvjFFS8?si=mj79JK4lr00vjQG3"},"Variational Autoencoders - Arxiv Insights")))),(0,r.kt)("p",null,"Autoencoder is good for reconstructing input data, however, it has limitation for generating new data. They focus on learning how to reconstruct the original data. They are more suitable for task like image upscaling or compression, where we don't need to generate new data."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Variational Autoencoder (VAE)")," is a type of generative model, which is a model that learns to generate new data samples that are similar to the training data. The model capture patterns, dependencies, and the structure of the data to generate new samples."),(0,r.kt)("p",null,"The main concept is the data distribution, the model will capture the probability distribution of different data samples occuring. The generation process is a probabilistic, it is done by sampling the distribution. This will make the model able to generate samples that are similar to the training data but not necessarily identical."),(0,r.kt)("p",null,"Actually, we can use the similar concept of VAE that samples the data obtained from the encoder which will later be represented in the latent space to generate new image. However, the latent space doesn't model the variability or uncertainty of the data, it is simply a lower-dimensional representation of the data. They are also not continous or discrete, meaning sampling it would be challenging."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"VAE architecture",src:a(17177).Z,width:"756",height:"462"}),(0,r.kt)("br",{parentName:"p"}),"\n","Source : ",(0,r.kt)("a",{parentName:"p",href:"https://theaisummer.com/Autoencoder/"},"https://theaisummer.com/Autoencoder/")),(0,r.kt)("h3",{id:"encoder"},"Encoder"),(0,r.kt)("p",null,"Input data such as image is fed to the encoder. Similar to traditional autoencoder, it consist of several layers such as ",(0,r.kt)("a",{parentName:"p",href:"/deep-learning/cnn#convolution-1"},"convolution layers")," and ",(0,r.kt)("a",{parentName:"p",href:"/deep-learning/cnn#pooling-1"},"pooling layers"),"."),(0,r.kt)("p",null,"After going through encoder layers and arrived at the final fully-connected layer, the output kinda different. As explained before, the data samples will be represented in a distribution, and we will sample from the distribution. The output is still gonna be the lower-dimensional representation of the data, often called as ",(0,r.kt)("strong",{parentName:"p"},"latent variables"),". However, these latent variables will be modeled into a probability distribution instead of being flattened, they will be transformed into a probability distribution called ",(0,r.kt)("strong",{parentName:"p"},"latent space distribution"),"."),(0,r.kt)("p",null,"The distribution follows the multivariate Gaussian distribution, it will be constructed based on two vectors parameters : ",(0,r.kt)("strong",{parentName:"p"},"mean(",(0,r.kt)("span",{parentName:"strong",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"\u03bc")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mu")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"\u03bc"))))),")")," vector and the ",(0,r.kt)("strong",{parentName:"p"},"standard deviations (",(0,r.kt)("span",{parentName:"strong",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"\u03c3")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\sigma")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"\u03c3"))))),")")," or ",(0,r.kt)("strong",{parentName:"p"},"variance (",(0,r.kt)("span",{parentName:"strong",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msup",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msup"},"\u03c3"),(0,r.kt)("mn",{parentName:"msup"},"2"))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\sigma^2")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8141em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"\u03c3"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))))))),")")," vector. These vectors are produced in the two branch of the final fully-connected layer of the encoder."),(0,r.kt)("p",null,"In a more advanced VAE, the lower-dimensional representation of data may include multiple dimension of feature data, to be able to capture more aspect of the data."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The mean vector provides the central tendency of the distribution, while the standard deviation (or variance) vector determines the spread or uncertainty of the distribution, similar to statistics in math.")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Encoder",src:a(57356).Z,width:"700",height:"433"}),(0,r.kt)("br",{parentName:"p"}),"\n","Source : ",(0,r.kt)("a",{parentName:"p",href:"https://www.compthree.com/blog/autoencoder/"},"https://www.compthree.com/blog/autoencoder/")),(0,r.kt)("h3",{id:"sampling"},"Sampling"),(0,r.kt)("p",null,"After constructing the distribution, we can start the sampling process. We will sample from the distribution defined by the mean and the variance. We will take sample as much as required to suit with the shape of the latent variables. The sampled latent is often denoted as ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"z")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"z")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.04398em"}},"z"))))),"."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Sampling process",src:a(25479).Z,width:"629",height:"339"}),(0,r.kt)("br",{parentName:"p"}),"\n","Source : ",(0,r.kt)("a",{parentName:"p",href:"https://notebook.community/diegocavalca/Studies/books/deep-learning-with-python/8.4-generating-images-with-vaes"},"https://notebook.community/diegocavalca/Studies/books/deep-learning-with-python/8.4-generating-images-with-vaes")),(0,r.kt)("h4",{id:"interpolation"},"Interpolation"),(0,r.kt)("p",null,"Another technique in sampling is the ",(0,r.kt)("strong",{parentName:"p"},"interpolation"),", basically it takes multiple sample in the latent space and take the interpolation of it. By taking the interpolation, we will generate a similar data with the previous sample. The purpose of this is to make a smooth transition between different input data."),(0,r.kt)("p",null,"For example, we can use this to transform a face that originally doesn't wear sunglasses to wear it. We will first encode the original face to obtain the latent variables. We will then encode a face with sunglasses to obtain the latent variables aswell. Linear interpolation will be done between these two latent variables, we can choose the degree of interpolation, whether we want the result to be closer to original face or closer to the face with sunglasses. The interpolated vector will be passed to the decoder network and a reconstructed image between the interpolated path will be generated."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Interpolation of face sunglasses",src:a(92847).Z,width:"516",height:"334"}),(0,r.kt)("br",{parentName:"p"}),"\n","Source : ",(0,r.kt)("a",{parentName:"p",href:"https://www.compthree.com/blog/autoencoder/"},"https://www.compthree.com/blog/autoencoder/")),(0,r.kt)("h3",{id:"decoder"},"Decoder"),(0,r.kt)("p",null,"The decoder layer of VAE is similar to the decoder layer in autoencoder, it is the reverse process of encoder that gradually increase the dimensionality of the sampled latent vectors, transforming them back into the original input space dimensions. Deconvolutional and reverse pooling process will be done."),(0,r.kt)("h4",{id:"loss-calculation"},"Loss Calculation"),(0,r.kt)("p",null,"After getting back the original input dimension, a new data is successfully generated. The loss calculation involve two terms, ",(0,r.kt)("strong",{parentName:"p"},"reconstruction loss"),", which measures the discrepancy between the reconstructed data and the original input data, same as the loss in traditional autoencoder. The second term is the ",(0,r.kt)("strong",{parentName:"p"},"Kullback-Leibler (KL) divergence"),", which measures the dissimilarity or information loss between two probability distributions. We compared the probability distribution we used to sample the new data with a normal distribution."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Loss function",src:a(76911).Z,width:"638",height:"55"}),(0,r.kt)("br",{parentName:"p"}),"\n","Source : ",(0,r.kt)("a",{parentName:"p",href:"https://youtu.be/9zKuYvjFFS8?si=wLkw3K_EXqw_1jpP&t=391"},"https://youtu.be/9zKuYvjFFS8?si=wLkw3K_EXqw_1jpP&t=391")),(0,r.kt)("h3",{id:"reparameterization-trick"},"Reparameterization Trick"),(0,r.kt)("p",null,"The sampling process uses the mean and the standard deviation/variances, however, the sampling process is not differentiable, which means we can't use the backpropagation process to optimize the loss function and update the model's parameters."),(0,r.kt)("p",null,"This is where an epsilon (",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"\u03f5")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\epsilon")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"\u03f5"))))),") vector is introduced. Epsilon vector is randomly drawn from the normal distribution. However, during the backpropagation process, we aren't actually optimizing it, it is simply a trick to make the function differentiable."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Reparameterization before and after",src:a(82134).Z,width:"511",height:"312"}),(0,r.kt)("br",{parentName:"p"}),"\n","Source : ",(0,r.kt)("a",{parentName:"p",href:"https://stats.stackexchange.com/questions/199605/how-does-the-reparameterization-trick-for-vaes-work-and-why-is-it-important"},"https://stats.stackexchange.com/questions/199605/how-does-the-reparameterization-trick-for-vaes-work-and-why-is-it-important")))}d.isMDXComponent=!0},57356:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/encoder-395dfb504380b666c199c730633fb079.png"},92847:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/interpolation-f26fe1221669ccf8ea68ca6036195615.png"},76911:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/loss-f3cfdd77feb05e9b36487f742474488b.png"},82134:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/reparameterization-6b2a17c40777f56332771c8c77553794.png"},25479:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sampling-0dcf435b9951a2b5fb9f0af0a45b3a72.png"},17177:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/vae-a1f0d21b87607ee37cb4c8a42c465459.png"}}]);