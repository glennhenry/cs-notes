"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[3407],{90252:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>h,contentTitle:()=>r,default:()=>l,frontMatter:()=>n,metadata:()=>c,toc:()=>o});var s=t(85893),a=t(11151);const n={slug:"/backend-development/caching",id:"caching",title:"Caching",description:"Caching"},r=void 0,c={id:"backend-development/caching/caching",title:"Caching",description:"Caching",source:"@site/docs/backend-development/21-caching/caching.md",sourceDirName:"backend-development/21-caching",slug:"/backend-development/caching",permalink:"/cs-notes/backend-development/caching",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/backend-development/21-caching/caching.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1715765664e3,frontMatter:{slug:"/backend-development/caching",id:"caching",title:"Caching",description:"Caching"},sidebar:"sidebar",previous:{title:"Backend & Server Security",permalink:"/cs-notes/backend-development/backend-server-security"},next:{title:"Backend Optimization",permalink:"/cs-notes/backend-development/backend-optimization"}},h={},o=[{value:"Caching Example",id:"caching-example",level:3},{value:"Type of Caching",id:"type-of-caching",level:3},{value:"Client-side",id:"client-side",level:4},{value:"Server-side",id:"server-side",level:4},{value:"Caching Strategy",id:"caching-strategy",level:3},{value:"Cache Invalidation",id:"cache-invalidation",level:3},{value:"Cache Replacement",id:"cache-replacement",level:3},{value:"Redis",id:"redis",level:3}];function d(e){const i={a:"a",admonition:"admonition",br:"br",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Main Source :"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.a,{href:"https://aws.amazon.com/caching/",children:"Caching Overview - AWS"})})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.a,{href:"https://youtu.be/G1rOthIU-uo?si=ED-VbtEqY25-TZkW",children:"Redis in 100 Seconds - Fireship"})})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.a,{href:"https://medium.com/@mmoshikoo/cache-strategies-996e91c80303",children:"Cache Strategies by Moshe Binieli - Medium Blog"})})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.a,{href:"https://dev.to/satrobit/cache-replacement-algorithms-how-to-efficiently-manage-the-cache-storage-2ne1",children:"Cache Replacement Algorithms: How To Efficiently Manage The Cache Storage by Amir Keshavarz - DEV.to"})})}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Caching"})," is the process of storing data or computation results in storage, typically in a high-speed memory, to improve the performance when the same data is accessed again. The storage can be non-persistent, such as ",(0,s.jsx)(i.a,{href:"/computer-organization-and-architecture/coa-fundamentals#ram",children:"RAM"}),", persistent storage, such as database, and stored locally or in a remote server."]}),"\n",(0,s.jsx)(i.p,{children:"When receiving a data retrieval request, whether it's a web server serving webpages, or an image viewer displaying images, caching can improve their performance. Instead of doing the same computation or retrieving data over and over again, we can store its result for future access."}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.img,{alt:"Caching",src:t(93874).Z+"",width:"452",height:"372"}),(0,s.jsx)(i.br,{}),"\n","Source : ",(0,s.jsx)(i.a,{href:"https://pressidium.com/blog/browser-cache-work/",children:"https://pressidium.com/blog/browser-cache-work/"})]}),"\n",(0,s.jsx)(i.h3,{id:"caching-example",children:"Caching Example"}),"\n",(0,s.jsx)(i.p,{children:"An example of caching in social media application."}),"\n",(0,s.jsx)(i.p,{children:"In social media applications, there are often feeds containing posts from users and their friends. Each post may include text, images, and the profile photo of the poster. The typical operation for retrieving post information involves the application making a request to a remote server, which then retrieves the requested data from a database."}),"\n",(0,s.jsx)(i.p,{children:"Instead of repeating this process multiple times, we can store post information in local storage and modify the application logic to check if the data is present before requesting it from the remote server. This approach leads to faster response times, reduced bandwidth usage, and a decrease in the server workload for serving requests."}),"\n",(0,s.jsx)(i.h3,{id:"type-of-caching",children:"Type of Caching"}),"\n",(0,s.jsx)(i.h4,{id:"client-side",children:"Client-side"}),"\n",(0,s.jsx)(i.p,{children:"The caching technique is implemented in the client side, they are typically handled by the web browsers (in the case of web application). This includes caching static resources such as HTML pages, images, files that are loaded when the user visits a website. Web browser also include local storage API, which can be used to store frequently accessed data such as user credentials."}),"\n",(0,s.jsxs)(i.p,{children:["Another use case of client-side caching is, as explained in the ",(0,s.jsx)(i.a,{href:"#caching-example",children:"social media caching example"}),"."]}),"\n",(0,s.jsx)(i.h4,{id:"server-side",children:"Server-side"}),"\n",(0,s.jsx)(i.p,{children:"Caching technique where the server or the developer is the one who handles it, they are typically implemented on the server to store and serve frequently accessed data or resources."}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.a,{href:"/software-engineering/system-design#cdn",children:"CDN Caching"})})," : CDN is a geographically distributed network of servers that are strategically placed in different locations worldwide. The primary purpose of a CDN is to improve the delivery speed and performance of web content to end-users."]}),"\n",(0,s.jsx)(i.p,{children:"For example, a person connecting from Asia is likely to have a better connection to a server located in Asia compared to a server located in a distant region, such as North America or Europe."}),"\n",(0,s.jsxs)(i.p,{children:["We may also cache the resource in the CDN itself, which is what CDN caching is, they are considered ",(0,s.jsx)(i.strong,{children:"distributed caching"}),", which is the practice of distributing cache around multiple servers to allows efficient data access across different machines or locations."]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.img,{alt:"CDN",src:t(87425).Z+"",width:"532",height:"287"}),(0,s.jsx)(i.br,{}),"\n","Source : ",(0,s.jsx)(i.a,{href:"https://www.wallarm.com/what/difference-between-a-cdn-and-web-accelerator",children:"https://www.wallarm.com/what/difference-between-a-cdn-and-web-accelerator"})]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Database Query"})," : When a common type of query is executed, the result is stored in a cache. If the same query is requested again, the server can return the cached result instead of executing the query again."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"caching-strategy",children:"Caching Strategy"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Cache-Aside"})," : The application is responsible for managing the cache. When data is requested, the application first checks the cache, if the data is found, it is retrieved from the cache and returned to the requester. If the data is not in the cache (called ",(0,s.jsx)(i.strong,{children:"cache miss"}),"), the application retrieves it from the data source, stores it in the cache for future use, and then returns it to the requester."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Write-Through"})," : This is a cache writing strategy where, every time data is written or updated, it is written to both cache and data source simultaneously. Write-through caching ensures data consistency but may have higher write latency due to the additional write operation to the data source."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Write-Back"})," : Write-back caching involves writing or updating data in the cache first and deferring the write to the underlying data source. This will reduce latency compared to write-through strategy, however, this approach introduce the risk of data loss."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Read-Through"})," : When data is requested and not found in the cache (a cache miss), the cache automatically retrieves the data from the underlying data source. The retrieved data is then stored in the cache and returned to the requester."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.img,{alt:"Cache strategies",src:t(83055).Z+"",width:"1183",height:"516"}),(0,s.jsx)(i.br,{}),"\n","Source : ",(0,s.jsx)(i.a,{href:"https://medium.com/@mmoshikoo/cache-strategies-996e91c80303",children:"https://medium.com/@mmoshikoo/cache-strategies-996e91c80303"})]}),"\n",(0,s.jsx)(i.h3,{id:"cache-invalidation",children:"Cache Invalidation"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Cache Invalidation"})," is the process of removing or marking data as invalid in a cache when the corresponding data in the underlying data source is updated or deleted. It ensures that the cached data remains consistent with the source of truth."]}),"\n",(0,s.jsx)(i.p,{children:"The methods are :"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Explicit Invalidation"})," : The application explicitly triggers the invalidation of specific data in the cache when changes are made to the corresponding data in the data source. This can involve calling cache-specific methods or APIs to remove or update the affected data in the cache."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Time-Based Invalidation"})," : Associates a ",(0,s.jsx)(i.strong,{children:"time-to-live (TTL)"})," value with each cached item. When the TTL expires, the cached item is considered invalid and is evicted from the cache."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Event-Based Invalidation"})," : Cache is invalidated by observing events or triggers that signify changes in the data source. These events can be ",(0,s.jsx)(i.a,{href:"/database-system/trigger-and-constraints",children:"database triggers"})," or ",(0,s.jsx)(i.a,{href:"/backend-development/message-broker",children:"message queue notifications"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"cache-replacement",children:"Cache Replacement"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Cache Replacement"}),", also known as ",(0,s.jsx)(i.strong,{children:"cache eviction"}),", is the process of selecting which data should be evicted from a cache when the cache reaches its capacity limit and a new item needs to be stored."]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Least Recently Used (LRU)"})," : This policy assumes that recently accessed data is more likely to be accessed again in the near future. The data item that has not been accessed for the longest period is evicted."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Least Frequently Used (LFU)"})," : This policy assumes that frequently accessed items are more valuable and should be retained in the cache. The data item that has been accessed the least number of times will be evicted."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"First-In-First-Out (FIFO)"})," : The data item that was inserted into the cache first is evicted when the cache is full. This follows a ",(0,s.jsx)(i.a,{href:"/data-structures-and-algorithms/queue",children:"queue-like behavior"}),", where the oldest data is removed."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Random Replacement"})," : This will select a random data item from the cache for eviction. It does not take into account the recency or frequency of access."]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.img,{alt:"LRU cache",src:t(54173).Z+"",width:"220",height:"250"}),(0,s.jsx)(i.br,{}),"\n","Source : ",(0,s.jsx)(i.a,{href:"https://www.interviewcake.com/concept/java/lru-cache",children:"https://www.interviewcake.com/concept/java/lru-cache"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"redis",children:"Redis"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"REmote DIctionary Server (Redis)"})," is a popular use case for a remote, distributed, in-memory data structure store. It is typically used for distributed caching, particularly its ",(0,s.jsx)(i.a,{href:"/data-structures-and-algorithms/hash-table",children:"hash map"})," data structure."]}),"\n",(0,s.jsx)(i.p,{children:"The reason a hash map is suitable for caching is that, in a hash map, data is stored as key-value pairs. The keys are unique identifiers, and the corresponding values which is where we store our actual data. Given a key, the data structure will return the value. So, as long as we know the key, then an efficient average constant O(1) for read and write speed can be achieved."}),"\n",(0,s.jsx)(i.p,{children:"More than a hash-map, Redis can be used to store other data structure, such as lists, sets, sorted sets, strings, bitmaps, etc."}),"\n",(0,s.jsxs)(i.p,{children:["One important thing about Redis is, its distributed nature. Redis supports ",(0,s.jsx)(i.a,{href:"/cloud-computing-and-distributed-systems/distributed-database#database-sharding",children:"sharding"})," and ",(0,s.jsx)(i.a,{href:"/database-system/logging-and-recovery#replication",children:"replication"}),", it allows developers to distribute data across multiple Redis instances deployed on multiple servers for improved scalability and fault tolerance. This can be beneficial for applications that need to handle large amounts of data or high traffic loads. In contrast, a traditional hash maps typically operate within a single process or machine."]}),"\n",(0,s.jsx)(i.p,{children:"For example, a backend application is deployed across multiple distinct servers. The application is supposed to serve request from anywhere around the world. If the application uses a traditional hash-map for storing data and serving the request, then all the instances would have inconsistent data."}),"\n",(0,s.jsx)(i.p,{children:"This is because traditional hash maps don't have a synchronization mechanism implemented. Unless we implement a synchronization mechanism across multiple instances of the application, it simply won't work. So basically, Redis makes it easier for developers to handle synchronizing between distributed servers."}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.img,{alt:"Redis",src:t(55725).Z+"",width:"502",height:"334"}),(0,s.jsx)(i.br,{}),"\n","Source : ",(0,s.jsx)(i.a,{href:"https://blog.hackajob.com/how-to-implement-redis-in-go/",children:"https://blog.hackajob.com/how-to-implement-redis-in-go/"})]}),"\n",(0,s.jsx)(i.admonition,{type:"tip",children:(0,s.jsxs)(i.p,{children:["See also ",(0,s.jsx)(i.a,{href:"/cloud-computing-and-distributed-systems",children:"distributed systems"}),"."]})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"data locality"}),"\n",(0,s.jsx)(i.li,{children:"spatial locality"}),"\n",(0,s.jsx)(i.li,{children:"cpu caching"}),"\n",(0,s.jsx)(i.li,{children:"client caching"}),"\n",(0,s.jsx)(i.li,{children:"server caching (cdn, load balancer)"}),"\n",(0,s.jsx)(i.li,{children:"cache line"}),"\n",(0,s.jsx)(i.li,{children:"cpu stall"}),"\n",(0,s.jsx)(i.li,{children:"loop interchange"}),"\n",(0,s.jsx)(i.li,{children:"matrix mul opitimization"}),"\n",(0,s.jsx)(i.li,{children:"cache policies"}),"\n"]})]})}function l(e={}){const{wrapper:i}={...(0,a.a)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},83055:(e,i,t)=>{t.d(i,{Z:()=>s});const s=t.p+"assets/images/cache-strategy-a1d76d65670b72d3e89c84dd34425ce8.png"},93874:(e,i,t)=>{t.d(i,{Z:()=>s});const s=t.p+"assets/images/caching-b115369dc5fd8ae849de3495f4df4994.png"},87425:(e,i,t)=>{t.d(i,{Z:()=>s});const s=t.p+"assets/images/cdn-7ef968bbed0cb8269b9870b56cc28470.png"},54173:(e,i,t)=>{t.d(i,{Z:()=>s});const s=t.p+"assets/images/lru-cache-b288abe94f9e4e91de18145ec18fb708.png"},55725:(e,i,t)=>{t.d(i,{Z:()=>s});const s=t.p+"assets/images/redis-6ca2b18e4c5304bd5f876761adf94274.png"},11151:(e,i,t)=>{t.d(i,{Z:()=>c,a:()=>r});var s=t(67294);const a={},n=s.createContext(a);function r(e){const i=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(n.Provider,{value:i},e.children)}}}]);