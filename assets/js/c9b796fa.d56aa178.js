"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[8122],{9572:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var a=t(85893),r=t(11151);const i={slug:"/software-engineering/behavioral-patterns",id:"behavioral-patterns",title:"Behavioral Patterns",description:"Behavioral Patterns"},s=void 0,o={id:"software-engineering/behavioral-patterns/behavioral-patterns",title:"Behavioral Patterns",description:"Behavioral Patterns",source:"@site/docs/software-engineering/06-behavioral-patterns/behavioral-patterns.md",sourceDirName:"software-engineering/06-behavioral-patterns",slug:"/software-engineering/behavioral-patterns",permalink:"/cs-notes/software-engineering/behavioral-patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/software-engineering/06-behavioral-patterns/behavioral-patterns.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1711894123,formattedLastUpdatedAt:"Mar 31, 2024",frontMatter:{slug:"/software-engineering/behavioral-patterns",id:"behavioral-patterns",title:"Behavioral Patterns",description:"Behavioral Patterns"},sidebar:"sidebar",previous:{title:"Structural Patterns",permalink:"/cs-notes/software-engineering/structural-patterns"},next:{title:"Client-Server",permalink:"/cs-notes/software-engineering/client-server"}},l={},d=[{value:"Command",id:"command",level:3},{value:"Iterator",id:"iterator",level:3},{value:"Observer",id:"observer",level:3},{value:"State",id:"state",level:3},{value:"Chain of Responsibility",id:"chain-of-responsibility",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Main Source :"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"https://refactoring.guru/design-patterns/behavioral-patterns",children:"Behavioral Design Patterns - Refatoring Guru"})})}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Behavioral patterns are design patterns that focus on the interaction and communication between objects. They address the behavior and responsibilities of objects, helping to define how objects collaborate and fulfill their tasks."}),"\n",(0,a.jsx)(n.h3,{id:"command",children:"Command"}),"\n",(0,a.jsx)(n.p,{children:"Command pattern encapsulates a request as an object that contains information about the request. Each command object encapsulates a specific request along with any necessary parameters. We can provide useful information in the object, such as what it executes briefly, which allows us to support undo-redo operations."}),"\n",(0,a.jsx)(n.p,{children:"Consider a simplified text editor :"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'class TextEditor {\n    private var text = StringBuilder()\n\n    fun write(start: Int, content: String) {\n        text.append(content, start, content.length)\n    }\n\n    fun delete(start: Int, end: Int): String {\n        val deleted = text.substring(start, end)\n        text.deleteRange(start, end)\n        return deleted\n    }\n\n    fun print() {\n        println(text.toString())\n    }\n}\n\nfun main() {\n    val t = TextEditor()\n    t.write(0, "asdf")\n    t.print() // Output "asdf"\n    t.delete(0, 2)\n    t.print() // Output "df"\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["It's a simple class that hold a text (in ",(0,a.jsx)(n.code,{children:"StringBuilder"}),"), which we can edit through the ",(0,a.jsx)(n.code,{children:"write"})," and ",(0,a.jsx)(n.code,{children:"delete"})," method."]}),"\n",(0,a.jsx)(n.p,{children:"If we were to implement undo functionality, one way to do that is storing a list of previously written text. So we would add current text to the list everytime we edit it. While this is easy to implement, it can consume so much space to store the string and a lot of time to copy the string."}),"\n",(0,a.jsx)(n.p,{children:"Following command pattern, we would make another object that encapsulate the writing or deleting operation along with extra information, and another class that handles the undo. With the given information, we will reverse the text operation."}),"\n",(0,a.jsx)(n.p,{children:"The text commands :"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'sealed interface TextCommand {\n    val start: Int\n    val end: Int\n    val content: String\n\n    // move content to first, so we can use its length for end\n    data class Write(\n        override val content: String,\n        override val start: Int,\n        override val end: Int = content.length\n    ) : TextCommand\n\n    // move content to last, so by default we don\'t have to specify it\n    data class Delete(\n        override val start: Int,\n        override val end: Int,\n        override val content: String = "" // only used for undoing\n    ) : TextCommand\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In Kotlin, sealed interface can be thought as an interface that prevent anyone to implement it, unless they are inside the interface block. Sealed interface will form a hierarchy within its implementation, and allow us to access the member by dot notation, such as ",(0,a.jsx)(n.code,{children:"TextCommand.Write"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"class TextCommandInvoker(private val textEditor: TextEditor) {\n    private val history = mutableListOf<TextCommand>()\n\n    fun execute(command: TextCommand) {\n        when (command) {\n            is Write -> {\n                textEditor.write(command.start, command.content)\n                history.add(command)\n            }\n            is Delete -> {\n                val deleted = textEditor.delete(command.start, command.end)\n                history.add(Delete(command.start, command.end, deleted))\n            }\n        }\n    }\n\n    fun undo() {\n        if (history.isNotEmpty()) {\n            val lastCommand = history.removeAt(history.lastIndex)\n\n            when (lastCommand) {\n                is Write -> {\n                    textEditor.delete(lastCommand.start, lastCommand.end)\n                }\n                is Delete -> {\n                    textEditor.write(lastCommand.start, lastCommand.content)\n                }\n            }\n        }\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We move all the code to ",(0,a.jsx)(n.code,{children:"TextCommandInvoker"}),", a class responsible for executing the text command. It will execute command based on the type of command it received. Any text command will be identified by ",(0,a.jsx)(n.code,{children:"TextCommand"})," sealed interface. It will also keep track the text edit history by adding the command to a list for undoing operation. This will reduce much more space than if we were to store the copy of string each time we edit it."]}),"\n",(0,a.jsx)(n.p,{children:"Sample usage :"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'fun main() {\n    val t = TextEditor()\n    val invoker = TextCommandInvoker(t)\n\n    invoker.execute(TextCommand.Write(content = "asdf", start = 0))\n    invoker.execute(TextCommand.Delete(start = 0, end = 2))\n\n    t.print() // Output "df"\n    invoker.undo()\n    t.print() // Output "asdf"\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["We will now do any text edit from ",(0,a.jsx)(n.code,{children:"TextCommandInvoker"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"iterator",children:"Iterator"}),"\n",(0,a.jsx)(n.p,{children:"Iterator patterns provide a way to access elements of a collection (array, list, stack, tree, etc.) sequentially without exposing the underlying implementation details."}),"\n",(0,a.jsx)(n.p,{children:"A traditional way of accessing a list would be :"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun main() {\n    val collection = listOf(1, 2, 3, 4, 5)\n    println(collection[0]) // Output 1\n    println(collection[1]) // Output 2\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"The downside of this approach is the potential for going out of bounds. To prevent that, we would first check if the index is in the collection range before accessing any element. The purpose of iterator pattern is to abstract away the index checking and provide a simpler API for user."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"class SimpleIterator(private val collection: List<Int>) {\n    private var currentIdx = 0\n\n    fun getNext(): Int {\n        if (hasNext()) {\n            val element = collection[currentIdx]\n            currentIdx++\n            return element\n        }\n        return -1\n    }\n\n    fun hasNext(): Boolean {\n        return currentIdx < collection.size\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We created a simple iterator class, for simplicity, it can only take a list of integers. It still stores index under the hood, but it always checks if the index is out of bound using the ",(0,a.jsx)(n.code,{children:"hasNext"})," method. User would use this iterator like :"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun main() {\n    val collection = listOf(1, 2, 3, 4, 5)\n    val iterator = SimpleIterator(collection)\n\n    println(iterator.hasNext()) // Output true\n    println(iterator.getNext()) // Output 1\n\n    while (iterator.hasNext()) {\n        println(iterator.getNext()) // Output 2 to 5\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To make it possible to use this iterator in a loop, we can use ",(0,a.jsx)(n.code,{children:"hasNext"})," as the condition for the while loop."]}),"\n",(0,a.jsxs)(n.p,{children:["This iterator patterns seems useless for basic collection like list or array. This is because some language typically implements iterator under the hood for loop expression like ",(0,a.jsx)(n.code,{children:"for (num in collection)"}),". Still, iterator pattern for list allow for flexibility in getting element, we don't have to create a loop if we are just getting several elements. We can also customize the behavior of the iteration as we like. We may implement filtering to skip element, progress at different rates, or in different directions. Iterator pattern will be much more useful for complex data structure like tree or graph."]}),"\n",(0,a.jsx)(n.h3,{id:"observer",children:"Observer"}),"\n",(0,a.jsx)(n.p,{children:"Observer pattern implements a subscription mechanism, which allow multiple observer, to be notified automatically when the state of a subject object (also known as the observable) changes."}),"\n",(0,a.jsx)(n.p,{children:"The subject maintains a list of observers and provides methods to add, remove, and notify observers. The observers register themselves with the subject and receive updates when the subject's state changes."}),"\n",(0,a.jsxs)(n.p,{children:["Let's imagine a YouTube subscription system. There is a ",(0,a.jsx)(n.code,{children:"Youtuber"}),", acting as the subject, and there is ",(0,a.jsx)(n.code,{children:"Subscriber"}),", acting as the observer."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"data class Subscriber(val name: String, val subscribeTo: List<Youtuber>)\n\nclass Youtuber(val name: String) {\n    fun hasUploaded(): Boolean {\n        return true\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"One way for subscriber to check if a YouTuber has uploaded a new video is, checking themselves."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'fun main() {\n    val yt1 = Youtuber("yt1")\n    val yt2 = Youtuber("yt2")\n\n    val subs1 = Subscriber("subs1", listOf(yt1))\n    val subs2 = Subscriber("subs2", listOf(yt1))\n\n    val subs3 = Subscriber("subs3", listOf(yt2))\n\n    for (youtuber in subs1.subscribeTo) {\n        youtuber.hasUploaded()\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"This is obviously not realistic whether in code or in real life. It won't be efficient to create a loop for every subscriber and check every single YouTuber it subscribed."}),"\n",(0,a.jsxs)(n.p,{children:["So, why can't the YouTuber be the one that notify their subscriber whenever they uploaded a video? We can alter the ",(0,a.jsx)(n.code,{children:"Youtuber"})," class to make it stores a list of subscriber and method to add or remove them."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'data class Subscriber(val name: String) {\n    fun notify(from: String) {\n        println("$name: Youtuber $from has uploaded a new video")\n    }\n}\n\nclass Youtuber(val name: String) {\n    val subscribers = mutableListOf<Subscriber>()\n\n    fun addSubscriber(subs: Subscriber) {\n        subscribers.add(subs)\n    }\n\n    fun removeSubscriber(subs: Subscriber) {\n        subscribers.remove(subs)\n    }\n\n    fun uploadVideoAndNotify() {\n        for (subs in subscribers) {\n            subs.notify(name)\n        }\n    }\n\n    fun hasUploaded(): Boolean {\n        return true\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["We also modified the ",(0,a.jsx)(n.code,{children:"Subscriber"})," class for ",(0,a.jsx)(n.code,{children:"notify"})," method. To use it :"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'fun main() {\n    val yt1 = Youtuber("yt1")\n    val yt2 = Youtuber("yt2")\n\n    val subs1 = Subscriber("subs1")\n    val subs2 = Subscriber("subs2")\n    val subs3 = Subscriber("subs3")\n\n    yt1.addSubscriber(subs1)\n    yt1.addSubscriber(subs2)\n    yt1.uploadVideoAndNotify()\n\n    /* Output:\n      subs1: Youtuber yt1 has uploaded a new video\n      subs2: Youtuber yt1 has uploaded a new video\n     */\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["While this code works, it may not make sense because the one adding or removing subscribers is the YouTuber itself. If you want a more realistic code where subscribers subscribe or unsubscribe themselves, you can edit the ",(0,a.jsx)(n.code,{children:"Subscriber"})," code. Add a method, such as ",(0,a.jsx)(n.code,{children:"subscribeTo"})," or ",(0,a.jsx)(n.code,{children:"unsubscribeFrom"}),", which takes a YouTuber object and calls the ",(0,a.jsx)(n.code,{children:"addSubscriber"})," or ",(0,a.jsx)(n.code,{children:"removeSubscriber"})," method on it."]}),"\n",(0,a.jsx)(n.h3,{id:"state",children:"State"}),"\n",(0,a.jsx)(n.p,{children:"State pattern allows an object to change its behavior dynamically as its internal state changes. It encapsulates each state as a separate class, and the object delegates its behavior to the current state class."}),"\n",(0,a.jsx)(n.p,{children:"An example would be a vending machine that operates differently based on the condition if an item is selected or not. Each state would have access to the machine to change its internal state."}),"\n",(0,a.jsx)(n.p,{children:"The vending machine would work this way :"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["User selects an item","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"If item is not selected yet, select it"}),"\n",(0,a.jsx)(n.li,{children:"If item is already selected, don't do anything"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["User dispense an item","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"If item is not selected yet, don't do anything"}),"\n",(0,a.jsx)(n.li,{children:"If item is already selected, dispense it"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The vending machine state is modeled by an interface :"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'interface VendingMachineState {\n    fun selectItem(item: String)\n    fun dispenseItem()\n}\n\nclass NoSelectionState(private val vm: VendingMachine) : VendingMachineState {\n    override fun selectItem(item: String) {\n        println("Selected item: $item")\n        vm.changeState(ItemSelectedState(vm))\n    }\n\n    override fun dispenseItem() {\n        println("Please select an item first.")\n    }\n}\n\nclass ItemSelectedState(private val vm: VendingMachine) : VendingMachineState {\n    override fun selectItem(item: String) {\n        println("Item $item is already selected.")\n    }\n\n    override fun dispenseItem() {\n        println("Dispensing item...")\n        vm.changeState(NoSelectionState(vm))\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"The vending machine :"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"class VendingMachine {\n    private var currentState: VendingMachineState = NoSelectionState(this)\n\n    fun changeState(newState: VendingMachineState) {\n        currentState = newState\n    }\n\n    fun selectItem(item: String) {\n        currentState.selectItem(item)\n    }\n\n    fun dispenseItem() {\n        currentState.dispenseItem()\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["State changes go through ",(0,a.jsx)(n.code,{children:"changeState"})," method, which overwrite the current state."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'fun main() {\n    val vm = VendingMachine()\n\n    vm.selectItem("Coke")\n    vm.dispenseItem()\n\n    vm.dispenseItem()\n    vm.selectItem("Chips")\n    vm.selectItem("Chips")\n    vm.dispenseItem()\n\n    /*\n    Output :\n        Selected item: Coke\n        Dispensing item...\n        Please select an item first.\n        Selected item: Chips\n        Item Chips is already selected.\n        Dispensing item...\n    */\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"chain-of-responsibility",children:"Chain of Responsibility"}),"\n",(0,a.jsx)(n.p,{children:"Chain of Responsibility pattern allows an object to pass a request along a chain of potential handlers until the request is handled or reaches the end of the chain. Each handler in the chain has the ability to handle the request or pass it to the next handler in the chain."}),"\n",(0,a.jsx)(n.p,{children:"Consider a math function that we can customize its behavior, maybe add the number first, then multiply, and finally subtract. Here's a simplified implementation of this :"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"abstract class MathOperationHandler {\n    abstract val operand: Int\n    abstract fun handle(prevResult: Int): Int\n\n    var nextHandler: MathOperationHandler? = null\n    fun m_setNextHandler(handler: MathOperationHandler) {\n        nextHandler = handler\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Each math operator has a handler, which has an operand provided for its calculation. They are able to set the ",(0,a.jsx)(n.code,{children:"nextHandler"})," by the ",(0,a.jsx)(n.code,{children:"m_setNextHandler"})," method (prefixed with m_ to avoid JVM conflict)."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"handle"})," method takes the previous result from the previous operand (or the initial value if they are the first operator). The handler will calculate the result with their given operand based on what type of math operation are they. The result is then passed again to the next handler."]}),"\n",(0,a.jsxs)(n.p,{children:["We also made ",(0,a.jsx)(n.code,{children:"MathOperationHandler"})," abstract instead of an interface, because the ",(0,a.jsx)(n.code,{children:"nextHandler"})," and ",(0,a.jsx)(n.code,{children:"m_setNextHandler"})," should be the same for any operator."]}),"\n",(0,a.jsx)(n.p,{children:"And here's all the operator implemented :"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"class AddHandler(override val operand: Int) : MathOperationHandler() {\n    override fun handle(prevResult: Int): Int {\n        val currentResult = prevResult + operand // Here lies the difference between operator\n        return nextHandler?.handle(currentResult) ?: currentResult\n    }\n}\n\nclass SubHandler(override val operand: Int) : MathOperationHandler() {\n    override fun handle(prevResult: Int): Int {\n        val currentResult = prevResult - operand\n        return nextHandler?.handle(currentResult) ?: currentResult\n    }\n}\n\nclass MulHandler(override val operand: Int) : MathOperationHandler() {\n    override fun handle(prevResult: Int): Int {\n        val currentResult = prevResult * operand\n        return nextHandler?.handle(currentResult) ?: currentResult\n    }\n}\n\nclass DivHandler(override val operand: Int) : MathOperationHandler() {\n    override fun handle(prevResult: Int): Int {\n        val currentResult = prevResult / operand\n        return nextHandler?.handle(currentResult) ?: currentResult\n    }\n}\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"?"})," and ",(0,a.jsx)(n.code,{children:"?:"})," is a Kotlin operator related to ",(0,a.jsx)(n.a,{href:"https://kotlinlang.org/docs/null-safety.html",children:"Kotlin null safety"}),". In short, using ",(0,a.jsx)(n.code,{children:"?"})," on a method call ensure that we are only invoking the method if the object we are invoking on is not null. On the other hand, the ",(0,a.jsx)(n.code,{children:"?:"})," replace a null value with an alternative value."]})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun main() {\n    val add = AddHandler(2)\n    val mul = MulHandler(5)\n    val sub = SubHandler(1)\n\n    add.m_setNextHandler(mul)\n    mul.m_setNextHandler(sub)\n\n    val result = add.handle(0)\n    println(result) // Output : 9\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The code set addition, multiplication, and subtraction operation respectively. The number 0 we passed in the first ",(0,a.jsx)(n.code,{children:"handle"})," method that we call on ",(0,a.jsx)(n.code,{children:"additionHandler"})," act as the initial value."]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>s});var a=t(67294);const r={},i=a.createContext(r);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);