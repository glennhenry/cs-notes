"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[261],{12261:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var a=t(85893),s=t(11151);const i={slug:"/database-system/logging-and-recovery",id:"logging-and-recovery",title:"Logging & Recovery",description:"Logging & Recovery"},r=void 0,o={id:"database-system/logging-and-recovery/logging-and-recovery",title:"Logging & Recovery",description:"Logging & Recovery",source:"@site/docs/database-system/08-logging-and-recovery/logging-and-recovery.md",sourceDirName:"database-system/08-logging-and-recovery",slug:"/database-system/logging-and-recovery",permalink:"/cs-notes/database-system/logging-and-recovery",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/database-system/08-logging-and-recovery/logging-and-recovery.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1723455088e3,frontMatter:{slug:"/database-system/logging-and-recovery",id:"logging-and-recovery",title:"Logging & Recovery",description:"Logging & Recovery"},sidebar:"sidebar",previous:{title:"Trigger & Constraints",permalink:"/cs-notes/database-system/trigger-and-constraints"},next:{title:"Database Index",permalink:"/cs-notes/database-system/database-index"}},c={},l=[{value:"Logging",id:"logging",level:3},{value:"Transaction Log",id:"transaction-log",level:4},{value:"Replication",id:"replication",level:3},{value:"Synchronous vs Asynchronous",id:"synchronous-vs-asynchronous",level:4},{value:"RAID",id:"raid",level:4},{value:"Migration",id:"migration",level:3}];function d(e){const n={a:"a",br:"br",em:"em",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Main Source:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Logging_(computing)",children:"Logging (computing) \u2014 Wikipedia"})})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Transaction_log",children:"Transaction log \u2014 Wikipedia"})})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Write-ahead_logging",children:"Write-ahead logging \u2014 Wikipedia"})})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Replication_(computing)",children:"Replication (computing) \u2014 Wikipedia"})})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Schema_migration",children:"Schema migration \u2014 Wikipedia"})})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Chapter 5, Designing Data Intensive Applications \u2014 Martin Kleppmann"})}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"logging",children:"Logging"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Logging"})," is the process of recording activities and changes that occur within a computer system. A log can be a problem, error, or just information on current operations."]}),"\n",(0,a.jsx)(n.h4,{id:"transaction-log",children:"Transaction Log"}),"\n",(0,a.jsxs)(n.p,{children:["Database operations are grouped into a unit of ",(0,a.jsx)(n.a,{href:"/database-system/transactions",children:"transaction"}),". Transaction log is the log file that contains all the transactions and changes made to the database over time."]}),"\n",(0,a.jsx)(n.p,{children:"Keeping track of database operation can be helpful to maintain data integrity. In the case of system failures, the DBMS can review the log and rolls back the state of database to a consistent state. By replaying the logged transactions, the system can reapply the changes made by committed transactions or undo the changes made by uncommitted or rolled-back transactions."}),"\n",(0,a.jsxs)(n.p,{children:["Database logs are linked together, forming a ",(0,a.jsx)(n.a,{href:"/data-structures-and-algorithms/linked-list",children:"linked list"}),". A log record is made up of:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Log Sequence Number (LSN)"}),": LSN is a unique ID of a log record, it is assigned to each transaction record."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Prev LSN"}),": A reference to the previous log record in the linked list structure of the log."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Transaction ID"}),": The associated transaction of a log record."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Type"}),": Type of database log record.","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Update"}),": It can be an update or change to database, it will include a reference to the modified page, length and offset of the page, and size of the page before and after the update."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Compensation"}),": A log about rollback of particular changes to the database. Each record is associated with the update log record, it also includes the next log record that needs to be undone for the transaction that wrote the last update log record."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Commit"}),": A decision to commit a transaction, which is a successful completion of a transaction."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Abort"}),": The decision to abort and rollback a transaction"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Checkpoint"})," Changes made in the memory is called ",(0,a.jsx)(n.strong,{children:"dirty pages"}),", a checkpoint is when all the dirty pages has been flushed or written to disk. The checkpoint record contains:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"redo LSN: Reference for first update after checkpoint, it is the starting point of redo on recovery."}),"\n",(0,a.jsx)(n.li,{children:"undo LSN: Reference to starting point for undoing the changes made by that transaction."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Completion"}),": Information about all work that has been done, either aborted or committed, for a particular transaction."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Actual Information"}),": Contains the necessary information to describe the changes made by the transaction that causes the log to be written."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.img,{alt:"Transaction log",src:t(2392).Z+"",width:"401",height:"350"}),(0,a.jsx)(n.br,{}),"\n","Source: ",(0,a.jsx)(n.a,{href:"https://sqlbak.com/academy/transaction-log/",children:"https://sqlbak.com/academy/transaction-log/"})]}),"\n",(0,a.jsxs)(n.p,{children:["During logging transaction, it can be implemented using the ",(0,a.jsx)(n.strong,{children:"write-ahead logging (WAL)"})," technique. This technique write changes to the database to a log file, along with undo and redo information, before they are applied to the actual data pages on disk."]}),"\n",(0,a.jsx)(n.p,{children:"The transaction and logging usually happens periodically. Transaction are written to the log, after some point, the system will perform a checkpoint, writing all the changes to the database and clear the logs."}),"\n",(0,a.jsx)(n.h3,{id:"replication",children:"Replication"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Replication"})," is the process of maintaining a copy of data for improved availability, fault-tolerance, and serving more request. When one instance of database fails, we can use the others. Furthermore, with more instance being present, they can help to serve multiple database request. This can be done locally or in a ",(0,a.jsx)(n.a,{href:"/cloud-computing-and-distributed-systems/distributed-database",children:"distributed database"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Key concept of data replication:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Replicated data can be stored in the same device or distributed in multiple device. We typically call an instance of database in distributed system as a ",(0,a.jsx)(n.strong,{children:"node"}),"."]}),"\n",(0,a.jsx)(n.li,{children:"Replicated data can be all or some subset of the data."}),"\n",(0,a.jsx)(n.li,{children:"The device or system a copy of data is called replica. Replica is updated frequently to ensure data is consistent."}),"\n",(0,a.jsx)(n.li,{children:"To synchronize with modification, we can either modify the primary and replicas simultaneously (asynchronous), or modify the primary data first and all the replicas after (synchronous)."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Some techniques of replication:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Master-Slave Replication"}),": Also known as leader-follower replication, this approach rely on two types of node. A ",(0,a.jsx)(n.em,{children:"master"})," database handles write operations, while one or more ",(0,a.jsx)(n.em,{children:"slave"})," databases replicate the data from the master. The slaves are intended to be read-only, they can only serve read queries from clients. The master should be responsible for propagating the changes to the slaves asynchronously or synchronously in some amount of time."]}),"\n",(0,a.jsxs)(n.p,{children:["The downside of using single master is, it could be overwhelmed by all the write request. Furthermore, it can lead to a single point of failures when the master fails. For that reason, when a master fails, it may be needed to select a new master through algorithm like ",(0,a.jsx)(n.a,{href:"/cloud-computing-and-distributed-systems/distributed-systems-model#leader-election",children:"leader election"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Multi-Master Replication"}),": In this approach, multiple master are present in the system. Each master can handle write operations independently, and changes made on one master are replicated to the other masters."]}),"\n",(0,a.jsxs)(n.p,{children:["While multi-master replication solves certain problems of master-slave replication, another ",(0,a.jsx)(n.a,{href:"/database-system/concurrency-control#conflict-serializability",children:"conflict"})," may occur. It arises when two or more master receive conflicting write operations that affect the same piece of data, therefore asking us which write is accepted. One way to resolve conflicts is to abort the operation and rollback to a specific timestamp when a change in one master was made. The choice of timestamp can be based on the ",(0,a.jsx)(n.strong,{children:"last-writer-wins (LWW)"})," principle, where the latest write operation is retained (although result in data loss)."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Multi-Level Replication"}),": This approach creates a hierarchy of replicas, where changes are propagated through multiple levels of replication. For example, changes made to a primary database are replicated to secondary replicas, which in turn replicate the data to tertiary replicas."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["When there is delay for accessing data because of replication (e.g., slow read/write, node fails), we call it ",(0,a.jsx)(n.strong,{children:"replication lag"}),". This delay can be bother the system, as various consistency problem may occur."]}),"\n",(0,a.jsx)(n.p,{children:"For instance, a client might update data through the master instance. Later, it reads data from a slave instance. This scenario can happen, for example, when a user submits a form through a web browser, and then refreshes the web browser to view the updated data. However, the slave instance hasn't received the write from the master yet. This can result in unexpected behavior observed by the user."}),"\n",(0,a.jsx)(n.h4,{id:"synchronous-vs-asynchronous",children:"Synchronous vs Asynchronous"}),"\n",(0,a.jsx)(n.p,{children:"In synchronous replication, the master always waits for the slave to update changes with new data until it completes, indicated when the slave sends a message. Consequently, this can be slower, but we can guarantee data consistency. The concern is not the performance, but rather when the slave fails. This could be due to hardware failure or network problems, which frequently encountered in distributed systems. Resolving these issues takes much longer than waiting for the write update. If all the slaves fail, the entire system could even halt entirely."}),"\n",(0,a.jsx)(n.p,{children:"In asynchronous replication, the master does not wait for the slave, which may lead to data inconsistency. Practically, the downside of synchronous replication is worse the asynchronous replication."}),"\n",(0,a.jsx)(n.p,{children:"Then there is also a semi-asynchronous approach where one node is made synchronous for maintaining consistent data, while others are made asynchronous. If the synchronous node fails, we can make the asynchronous slave synchronous."}),"\n",(0,a.jsx)(n.h4,{id:"raid",children:"RAID"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"RAID"})," is a fault-tolerance technique that involve creating redundancy in computer storage by distributing data across multiple disks."]}),"\n",(0,a.jsxs)(n.p,{children:["See ",(0,a.jsx)(n.a,{href:"/operating-system/disk-management#raid",children:"RAID"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"migration",children:"Migration"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Migration"})," is the process of moving or transferring a database from one system or environment to another. Database migration transfer data, schema, and associated objects from the source system to the target system while ensuring data integrity and compatibility."]}),"\n",(0,a.jsx)(n.p,{children:"A migration is needed when a specific changes applied to a database alters its structure. Some scenarios are:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Schema Changes"}),": When modifying the structure of a database, such as adding, modifying, or removing tables, columns, indexes, or constraints."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Data Transformations"}),": This may include data conversions, normalization, denormalization, etc."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Version Upgrades"}),": When upgrading the DBMS to a newer version, a migration is often required to ensure compatibility with the new database software."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"System Upgrades"}),": Scenario of system upgrades, or when moving data to a different platform, such as migrating from an on-premises database to a cloud-based solution."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},2392:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/transaction-log-3219ffce5427c266c6265cae9fe6784c.png"},11151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>r});var a=t(67294);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);