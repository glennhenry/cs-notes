"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[4080],{69897:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var a=r(85893),t=r(11151);const s={slug:"/software-engineering/structural-patterns",id:"structural-patterns",title:"Structural Patterns",description:"Structural Patterns"},i=void 0,o={id:"software-engineering/structural-patterns/structural-patterns",title:"Structural Patterns",description:"Structural Patterns",source:"@site/docs/software-engineering/05-structural-patterns/structural-patterns.md",sourceDirName:"software-engineering/05-structural-patterns",slug:"/software-engineering/structural-patterns",permalink:"/cs-notes/software-engineering/structural-patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/software-engineering/05-structural-patterns/structural-patterns.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1708252885e3,frontMatter:{slug:"/software-engineering/structural-patterns",id:"structural-patterns",title:"Structural Patterns",description:"Structural Patterns"},sidebar:"sidebar",previous:{title:"Creational Patterns",permalink:"/cs-notes/software-engineering/creational-patterns"},next:{title:"Behavioral Patterns",permalink:"/cs-notes/software-engineering/behavioral-patterns"}},c={},l=[{value:"Facade",id:"facade",level:3},{value:"Adapter",id:"adapter",level:3},{value:"Bridge",id:"bridge",level:3},{value:"Decorator",id:"decorator",level:3},{value:"Composite",id:"composite",level:3}];function d(e){const n={a:"a",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Main Source :"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"https://refactoring.guru/design-patterns/structural-patterns",children:"Structural Design Patterns - Refatoring Guru"})})}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Structural patterns"})," focus on structuring objects and classes to form larger structure. These patterns help to define and manage relationships between different components, ensuring that they work together effectively."]}),"\n",(0,a.jsx)(n.h3,{id:"facade",children:"Facade"}),"\n",(0,a.jsx)(n.p,{children:'Facade pattern advises simplifying a complex system by providing a unified and straightforward interface to the client. The system should feature an interface functioning as a "facade" or entry point to hide complexity underneath.'}),"\n",(0,a.jsx)(n.p,{children:"The point is to simplify complex interaction within the system. Complex interaction can occur in single or multiple class. For example, a computer consist of CPU, memory, and hard drive. A non-facade way of doing this would be :"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"class CPU {\n    fun processData() {}\n}\n\nclass Memory {\n    fun load() {}\n}\n\nclass HardDrive {\n    fun read() {}\n}\n\nfun main() {\n    val cpu = CPU()\n    val memory = Memory()\n    val hardDrive = HardDrive()\n\n    cpu.processData()\n    memory.load()\n    hardDrive.read()\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The problem of this code is, the user require understanding about the three classes. They need to know that they must construct the specific ",(0,a.jsx)(n.code,{children:"CPU"}),", ",(0,a.jsx)(n.code,{children:"Memory"}),", and ",(0,a.jsx)(n.code,{children:"HardDrive"})," class. Furthermore, they must know which method from which class should be called first."]}),"\n",(0,a.jsxs)(n.p,{children:["Following facade pattern, instead of constructing class and calling these methods individually, we could make another class (e.g., ",(0,a.jsx)(n.code,{children:"Computer"})," class) dedicated to handle it."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"class Computer {\n    val cpu = CPU()\n    val memory = Memory()\n    val hardDrive = HardDrive()\n\n    fun run() {\n        cpu.processData()\n        memory.load()\n        hardDrive.read()\n    }\n}\n\nfun main() {\n    val computer = Computer()\n    computer.run()\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"adapter",children:"Adapter"}),"\n",(0,a.jsx)(n.p,{children:"Adapter pattern allows objects with incompatible interfaces to work together. It acts as a bridge between two incompatible interfaces, converting required code in order for them to collaborate."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'interface Charger {\n    fun charge()\n}\n\nclass EuropeanCharger {\n    fun plugIn() {\n        println("Plugged in European charger")\n    }\n}\n\nclass AmericanCharger {\n    fun plugIn() {\n        println("Plugged in American charger")\n    }\n}\n\nclass Phone(val charger: EuropeanCharger) {\n    fun chargePhone() {\n        charger.plugIn()\n    }\n}\n\nfun main() {\n    val europeanCharger = EuropeanCharger()\n    val phone = Phone(europeanCharger)\n    phone.chargePhone()\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This code illustrates phone that we can charge using one of the two chargers, ",(0,a.jsx)(n.code,{children:"EuropeanCharger"})," and ",(0,a.jsx)(n.code,{children:"AmericanCharger"}),". This code assumes that both charger are incompatible with each other, and they can't implement ",(0,a.jsx)(n.code,{children:"Charger"})," interface directly."]}),"\n",(0,a.jsxs)(n.p,{children:["To make phone compatible with any type of charger, we will introduce two adapter class for ",(0,a.jsx)(n.code,{children:"AmericanCharger"})," and ",(0,a.jsx)(n.code,{children:"EuropeanCharger"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'class EuropeanChargerAdapter(private val charger: EuropeanCharger) : Charger {\n    override fun charge() {\n        // do complex convertion here...\n        charger.plugIn()\n        println("Charging using European charger (adapted)")\n    }\n}\n\nclass AmericanChargerAdapter(private val charger: AmericanCharger) : Charger {\n    override fun charge() {\n        // do complex convertion here...\n        charger.plugIn()\n        println("Charging using American charger (adapted)")\n    }\n}\n\nclass Phone(var charger: Charger) {\n    fun chargePhone() {\n        charger.charge()\n    }\n}\n\nfun main() {\n    val europeanCharger = EuropeanCharger()\n    val europeanChargerAdapter = EuropeanChargerAdapter(europeanCharger)\n    val phone = Phone(europeanChargerAdapter)\n    phone.chargePhone()\n\n    val americanCharger = AmericanCharger()\n    val americanChargerAdapter = AmericanChargerAdapter(americanCharger)\n    phone.charger = americanChargerAdapter\n    phone.chargePhone()\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The phone now takes charger that implements ",(0,a.jsx)(n.code,{children:"Charger"})," interface. The adapter class is dedicated for the conversion between specific type of charger to a general type of charger."]}),"\n",(0,a.jsx)(n.h3,{id:"bridge",children:"Bridge"}),"\n",(0,a.jsx)(n.p,{children:"Bridge pattern decouples an abstraction from its implementation, allowing them to vary independently."}),"\n",(0,a.jsxs)(n.p,{children:["Consider a ",(0,a.jsx)(n.code,{children:"Shape"})," interface that can be drawn on the screen. A shape can be ",(0,a.jsx)(n.code,{children:"Square"})," or ",(0,a.jsx)(n.code,{children:"Circle"}),", which are abstract classes."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"interface class Shape() {\n    fun draw()\n}\n\nabstract class Square: Shape() {\n    abstract fun draw()\n}\n\nabstract class Circle: Shape() {\n    abstract fun draw()\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Now, assume there are two method to render the shape on the screen, vector and raster. If we were to render ",(0,a.jsx)(n.code,{children:"Square"})," using vector method, we would need to create ",(0,a.jsx)(n.code,{children:"SquareVector"})," that implements ",(0,a.jsx)(n.code,{children:"Square"})," abstract class. The same for the remaining, ",(0,a.jsx)(n.code,{children:"SquareRaster"}),", ",(0,a.jsx)(n.code,{children:"CircleVector"}),", and ",(0,a.jsx)(n.code,{children:"CircleRaster"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"class SquareRaster(): Square {\n    override fun draw() {}\n}\n\nclass SquareVector(): Square {\n    override fun draw() {}\n}\n\nclass CircleRaster(): Circle {\n    override fun draw() {}\n}\n\nclass CircleVector(): Circle {\n    override fun draw() {}\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["As many shape and type of rendering available, the class hierarchy becomes exponentially large. If we have triangle shape, we would need two additional classes, ",(0,a.jsx)(n.code,{children:"TriangleRaster"})," and ",(0,a.jsx)(n.code,{children:"TriangleVector"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Bridge pattern solve the problem by ",(0,a.jsx)(n.a,{href:"/software-engineering/software-principles#composition-over-inheritance",children:"switching inheritance to composition"}),". Instead of making different renderer class for each type of shape, we associate a shape with a type of renderer. This effectively split the class hierarchy, which we can develop independently."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Renderer"})," hierarchy :"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"interface Renderer {\n    fun render()\n}\n\nclass VectorRenderer : Renderer {\n    override fun render() {}\n}\n\nclass RasterRenderer : Renderer {\n    override fun render() {}\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Shape"})," hierarchy :"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"abstract class Shape(val renderer: Renderer) {\n    abstract fun draw()\n}\n\nclass Circle(val renderer: Renderer) : Shape(renderer) {\n    override fun draw() {\n        renderer.renderShape()\n    }\n}\n\nclass Square(private val renderer: Renderer) : Shape(renderer) {\n    override fun draw() {\n        renderer.renderShape()\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Usage example :"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun main() {\n    val vectorRenderer = VectorRenderer()\n    val rasterRenderer = RasterRenderer()\n\n    val circle = Circle(vectorRenderer)\n    circle.draw()\n\n    val square = Square(rasterRenderer)\n    square.draw()\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If we add ",(0,a.jsx)(n.code,{children:"Triangle"})," class, then we would only be adding one additional class in the ",(0,a.jsx)(n.code,{children:"Shape"})," hierarchy."]}),"\n",(0,a.jsx)(n.h3,{id:"decorator",children:"Decorator"}),"\n",(0,a.jsx)(n.p,{children:"Decorator pattern allows us to add new behavior to an object dynamically. It is useful when you want to modify the functionality of an object without changing its underlying structure."}),"\n",(0,a.jsxs)(n.p,{children:["Consider a ",(0,a.jsx)(n.code,{children:"Pizza"})," class that lets us order pizza with different type of toppings."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'class Pizza {\n    fun pepperoni() {\n        println("Ordered pizza with pepperoni")\n    }\n\n    fun cheese() {\n        println("Ordered pizza with cheese")\n    }\n\n    fun pepperoniWithCheese() {\n        println("Ordered pizza with pepperoni, cheese")\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"There are three possible topping, pepperoni, cheese, or pepperoni with cheese. As many toppings available, the combination of different toppings causes the method to grows up exponentially."}),"\n",(0,a.jsx)(n.p,{children:"Decorator pattern solve this problem by making class that can extend the plain pizza class with new toppings."}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Pizza"})," class become an interface, and the default implementation would be ",(0,a.jsx)(n.code,{children:"PlainPizza"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'interface Pizza {\n    fun getDescription(): String\n}\n\nclass PlainPizza : Pizza {\n    override fun getDescription(): String {\n        return "Plain Pizza"\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The topping will become the decorator for ",(0,a.jsx)(n.code,{children:"Pizza"})," :"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'class PepperoniDecorator(val pizza: Pizza) : Pizza {\n    override fun getDescription(): String {\n        return pizza.getDescription() + ", Pepperoni"\n    }\n}\n\nclass CheeseDecorator(val pizza: Pizza) : Pizza {\n    override fun getDescription(): String {\n        return pizza.getDescription() + ", Cheese"\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Each decorator wraps around a ",(0,a.jsx)(n.code,{children:"Pizza"})," object and adds its specific topping to the description."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun main() {\n    val plainPizza: Pizza = SimplePizza()\n    val pizzaWithPepperoni: Pizza = PepperoniDecorator(plainPizza)\n    val pizzaWithPepperoniAndCheese: Pizza = CheeseDecorator(pizzaWithPepperoni)\n\n    println(plainPizza.getDescription()) // printed Plain Pizza\n    println(pizzaWithPepperoni.getDescription()) // printed Plain Pizza, Pepperoni\n    println(pizzaWithPepperoniAndCheese.getDescription()) // printed Plain Pizza, Pepperoni, Cheese\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"composite",children:"Composite"}),"\n",(0,a.jsx)(n.p,{children:"Composite pattern allows us to treat individual objects and groups of objects uniformly."}),"\n",(0,a.jsx)(n.p,{children:"Let's say we are grouping objects together. However, these objects have their own way of doing things, they do not behave similarly. The composite pattern solves the problem by enforcing individual objects to implement a common interface or base class. This is useful particularly where we want to group objects together, such as a tree-like structure."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"class Computer {\n    var totalCosts = 0\n}\n\nclass Processor(val core: Int) {\n    fun getCost(): Int {\n        return 1000 * core\n    }\n}\n\nclass Memory(val sizeMB: Int) {\n    fun getCost(): Int {\n        return 2 * sizeMB\n    }\n}\n\nclass HardDrive(val sizeGB: Int) {\n    fun getCost(): Int {\n        return 50 * sizeGB\n    }\n}\n\nfun main() {\n    val processor = Processor(4) // A processor with 4 core\n    val memory = Memory(1024) // A 1024 MB RAM\n    val hardDrive = HardDrive(20) // A 20 GB hard disk\n\n    val computer = Computer()\n    computer.totalCosts += processor.getCost()\n    computer.totalCosts += memory.getCost()\n    computer.totalCosts += hardDrive.getCost()\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The processor, memory, and hard drive doesn't have clear abstraction. These objects are not supposed to be scattered, the computer is supposed to own them. To group these objects together, they could implement a unified interface like ",(0,a.jsx)(n.code,{children:"Hardware"}),", and the computer will own a list of hardware."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"interface Hardware {\n    fun getCost(): Int\n}\n\nclass Processor(val core: Int): Hardware {\n    override fun getCost(): Int {\n        return 1000 * core\n    }\n}\n\nclass Memory(val sizeMB: Int): Hardware {\n    override fun getCost(): Int {\n        return 2 * sizeMB\n    }\n}\n\nclass HardDrive(val sizeGB: Int): Hardware {\n    override fun getCost(): Int {\n        return 50 * sizeGB\n    }\n}\n\nclass Computer {\n    val hardwares = mutableListOf<Hardware>()\n\n    fun addHardware(hardware: Hardware) {\n        hardwares.add(hardware)\n    }\n\n    fun getTotalCost(): Int {\n        total = 0\n        for (hardware in hardwares) {\n            total += hardware.getCost()\n        }\n        return total\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Now that these pieces of hardware implement a common interface, we can treat them as a single unit. We can calculate the total cost by calling ",(0,a.jsx)(n.code,{children:"getTotalCost()"}),", which will calculate each cost of individual hardware with ",(0,a.jsx)(n.code,{children:"getCost()"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>o,a:()=>i});var a=r(67294);const t={},s=a.createContext(t);function i(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);