"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[8852],{39955:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var s=i(85893),t=i(11151);const r={slug:"/software-engineering/software-principles",id:"software-principles",title:"Software Principles",description:"Software Principles"},o=void 0,a={id:"software-engineering/software-principles/software-principles",title:"Software Principles",description:"Software Principles",source:"@site/docs/software-engineering/02-software-principles/software-principles.md",sourceDirName:"software-engineering/02-software-principles",slug:"/software-engineering/software-principles",permalink:"/cs-notes/software-engineering/software-principles",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/software-engineering/02-software-principles/software-principles.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1707908587,formattedLastUpdatedAt:"Feb 14, 2024",frontMatter:{slug:"/software-engineering/software-principles",id:"software-principles",title:"Software Principles",description:"Software Principles"},sidebar:"sidebar",previous:{title:"Software Process",permalink:"/cs-notes/software-engineering/software-process"},next:{title:"Diagrams",permalink:"/cs-notes/software-engineering/diagrams"}},l={},c=[{value:"OOP",id:"oop",level:3},{value:"DRY",id:"dry",level:3},{value:"KISS",id:"kiss",level:3},{value:"YAGNI",id:"yagni",level:3},{value:"Coupling &amp; Cohesion",id:"coupling--cohesion",level:3},{value:"LoD",id:"lod",level:3},{value:"SoC",id:"soc",level:3},{value:"Unidirectional Data Flow",id:"unidirectional-data-flow",level:3},{value:"Composition Over Inheritance",id:"composition-over-inheritance",level:3},{value:"Clean Code",id:"clean-code",level:3},{value:"SOLID",id:"solid",level:3}];function d(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Main Source :"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Various Google searches"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself",children:"Don't repeat yourself - Wikipedia"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/KISS_principle",children:"KISS principle - Wikipedia"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it",children:"You aren't gonna need it - Wikipedia"})})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Software Principles"})," are collection of guidelines, styles, tips, good practices, by various software and engineers to help to guide the process of developing a good software. By good software, it means they are reliable, maintainable, scalable, and many more listed in ",(0,s.jsx)(n.a,{href:"/software-engineering#software-characteristics",children:"software characteristics"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"oop",children:"OOP"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/computer-and-programming-fundamentals/object-oriented-programming",children:"Object-Oriented Programming (OOP)"})," is a common paradigm used in the world of software engineering. The elements of OOP such as classes, objects, inheritance, polymorphism, encapsulation, and many more promotes code organization, reusability, and modularity in a software system. These elements serve as the foundation of other software principle that we will see later."]}),"\n",(0,s.jsxs)(n.p,{children:["We will see an example that demonstrate the benefits OOP about code reusing (in ",(0,s.jsx)(n.a,{href:"https://kotlinlang.org",children:"Kotlin programming language"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"Non-OOP approach :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'val employee1Name = "John Doe"\nval employee1Age = 30\nval employee1Department = "Sales"\n\nval employee2Name = "Jane Smith"\nval employee2Age = 35\nval employee2Department = "Marketing"\n\nfun introduceEmployee(name: String, age: Int, department: String) {\n    println("Hello, my name is $name. I am $age years old and work in the $department department.")\n}\n\nintroduceEmployee(employee1Name, employee1Age, employee1Department)\nintroduceEmployee(employee2Name, employee2Age, employee2Department)\n'})}),"\n",(0,s.jsx)(n.p,{children:"OOP approach :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'class Employee(val name: String, val age: Int, val department: String) {\n    fun introduce() {\n        println("Hello, my name is $name. I am $age years old and work in the $department department.")\n    }\n}\n\nval employee1 = Employee("John Doe", 30, "Sales")\nval employee2 = Employee("Jane Smith", 35, "Marketing")\n\nemployee1.introduce()\nemployee2.introduce()\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The code is about storing employee's data and have a function that can introduce them. The Non-OOP approach require us to make a bunch of variable just to store the data, while in OOP approach, we can make a class and represent the employee as an ",(0,s.jsx)(n.code,{children:"Employee"})," object. Class and objects provides a structured and organized way to encapsulate related data and behavior, leading to more maintainable code."]}),"\n",(0,s.jsx)(n.h3,{id:"dry",children:"DRY"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"DRY (Don't Repeat Yourself)"}),' is a software development principle that promotes code reuse and avoids duplication. The DRY principle is stated as "Every piece of knowledge must have a single, unambiguous, authoritative representation within a system".']}),"\n",(0,s.jsx)(n.p,{children:"When code is repeated in multiple places, it becomes harder to update or modify because changes need to be made in multiple locations, increasing the chances of introducing bugs and inconsistencies. When a change is required, it only needs to be made in one place, making maintenance and updates more efficient and less error-prone."}),"\n",(0,s.jsx)(n.p,{children:"Non-DRY approach :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'fun main() {\n    println("Hello, Alice!")\n    println("Hello, Bob!")\n    println("Hello, Charlie!")\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"DRY approach :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'fun greet(name: String) {\n    println("Hello, $name!")\n}\n\nfun main() {\n    val names = listOf("Alice", "Bob", "Charlie")\n    for (name in names) {\n        greet(name)\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The code is about storing names and having a function to greet them. Non-DRY approach manually call ",(0,s.jsx)(n.code,{children:"println"})," thrice with the name data. If we somehow wanted to change the greet message, we will need to modify all the three line of code. The DRY approach helps us to avoid printing the greeting message by putting it all in one function, and then integrate it with a for loop."]}),"\n",(0,s.jsx)(n.p,{children:"The previous OOP example also follows this DRY principle."}),"\n",(0,s.jsx)(n.h3,{id:"kiss",children:"KISS"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"KISS (Keep It Simple, Stupid)"})," is a software development principle that promotes emphasizes the importance of simplicity. The principle suggests that systems and code should be kept as simple as possible, avoiding unnecessary complexity."]}),"\n",(0,s.jsx)(n.p,{children:"An example of unnecessary abstracted code :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'class Parity(val num: Int) {\n    var isEven = false\n\n    fun updateIsEven() {\n        if (decideIsEven(num)) {\n            numIsEven()\n        } else {\n            numIsNotEven()\n        }\n    }\n\n    fun numIsEven() {\n        isEven = true\n    }\n\n    fun numIsNotEven() {\n        isEven = false\n    }\n\n    fun decideIsEven(n: Int): Boolean {\n        if (n % 2 == 0) {\n            return true\n        } else {\n            return false\n        }\n    }\n\n    fun getIsEven(): Boolean {\n        return isEven\n    }\n}\n\nfun main() {\n    val parity = Parity(3)\n    parity.updateIsEven()\n    println("Is 3 even?: ${parity.getIsEven()}")\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This code creates a class that is supposed to handle the parity of a number. The purpose of introducing a class in this code is to create an abstraction, this way the function caller doesn't need to handle the parity logic. In reality, the handling of parity is actually very simple and doesn't need to be overly abstracted like above. The checks for ",(0,s.jsx)(n.code,{children:"num % 2 == 0"})," to determine if a number is even is a relatively well-known concept."]}),"\n",(0,s.jsxs)(n.p,{children:["We don't need to make function for every single expression we are executing. Making a function just to set a field variable is unnecessary. Making a getter to get the ",(0,s.jsx)(n.code,{children:"isEven"})," variable is also not needed, because in Kotlin properties can have implicit getters generated automatically."]}),"\n",(0,s.jsx)(n.h3,{id:"yagni",children:"YAGNI"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"YAGNI (You Ain't Gonna Need It)"})," principle suggests developers should avoid adding functionality until it is necessary. It is typically associated with ",(0,s.jsx)(n.a,{href:"/software-engineering/software-process#agile",children:"agile development methodology"}),", where the development style revolve around quick incremental software development."]}),"\n",(0,s.jsx)(n.p,{children:"Its main idea is to focus on delivering the minimum viable product (MVP) or the necessary features to meet the immediate requirements, rather than adding functionality that may or may not be needed in the future."}),"\n",(0,s.jsx)(n.p,{children:"There are some factors to consider when developing functionality :"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Development Costs"})," : Resources required to build the software, such as developers' salaries, project management expenses, software licenses, development tools, and infrastructure costs."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Maintenance and Repair Costs"})," : There is a potential that the functionality may need bug fixes, updates, security patches, or technical support."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Unnecessary development sacrifice time and effort for future development and maintenance, possibly introducing ",(0,s.jsx)(n.strong,{children:"technical debt"}),". Technical debt is a consequence of software development bad decisions that keep accumulating costs and challenges as the software evolves, similar to financial debt that accumulates interest over time."]}),"\n",(0,s.jsx)(n.h3,{id:"coupling--cohesion",children:"Coupling & Cohesion"}),"\n",(0,s.jsxs)(n.p,{children:["Both describe the relationship and dependency between software components. ",(0,s.jsx)(n.strong,{children:"Coupling"})," refers to the inter-component interaction, while ",(0,s.jsx)(n.strong,{children:"cohesion"})," refers to the intra-component interaction."]}),"\n",(0,s.jsx)(n.p,{children:"Cohesion is the degree to which elements within a component or module are related and work together to accomplish a single, well-defined purpose."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"High Cohesion"})," : High cohesion indicates that the elements within a component are closely related and focused on a specific functionality or responsibility. A highly cohesive component performs a single task or represents a cohesive set of related tasks, making it easier to understand, reuse, and maintain."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Low Cohesion"})," : Low cohesion occurs when a component has multiple unrelated responsibilities or tasks. This can lead to a component that is difficult to understand, modify, and test. Low cohesion may also result in code duplication and reduced reusability."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"On the other hand, coupling describe the interaction between modules."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Loose Coupling"})," : In a loosely coupled system, components are independent and interact through well-defined interfaces. Loose coupling principle encourages components to have minimal dependencies on each other. Changes to one component have minimal impact on other components, making the system more flexible, modular, and easier to maintain."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tight Coupling"})," : Tight coupling occurs when components have strong dependencies and rely heavily on each other's internal details or implementation. In a tightly coupled system, changes in one component may require corresponding changes in multiple other components. This can lead to code that is harder to modify, test, and maintain."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"Cohesion and coupling",src:i(80431).Z+"",width:"650",height:"575"}),(0,s.jsx)(n.br,{}),"\n","Source : ",(0,s.jsx)(n.a,{href:"https://www.boardinfinity.com/blog/cohesion/",children:"top"}),", ",(0,s.jsx)(n.a,{href:"https://www.engati.com/glossary/cohesion-and-coupling",children:"down"})]}),"\n",(0,s.jsx)(n.p,{children:"Below are code that demonstrate cohesion and coupling."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Low Cohesion :"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class Customer {\n    fun calculateOrderTotal(order: Order) {}\n    fun sendOrderConfirmationEmail(order: Order) {}\n    fun updateCustomerInformation(customerData: CustomerData) {}\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"High Cohesion :"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class OrderProcessor {\n    fun processOrder(order: Order) {\n        validateOrder(order)\n        calculateOrderTotal(order)\n        updateInventory(order)\n        notifyCustomer(order)\n    }\n    private fun validateOrder(order: Order) {}\n    private fun calculateOrderTotal(order: Order) {}\n    private fun updateInventory(order: Order) {}\n    private fun notifyCustomer(order: Order) {}\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The class in low cohesion code have their own responsibility within the class. On the other hand, the high cohesion code focuses on the ",(0,s.jsx)(n.code,{children:"processOrder"})," method, where it calls the other private method."]}),"\n",(0,s.jsxs)(n.p,{children:["The high cohesion code may be preferable as it makes the caller easier to interact with the class. The caller can just call the method ",(0,s.jsx)(n.code,{children:"processOrder"})," passing in an ",(0,s.jsx)(n.code,{children:"Order"})," to process it. In contrast, in the low cohesion code, caller requires an understanding of how ",(0,s.jsx)(n.code,{children:"Customer"})," class process order. (i.e., should we call ",(0,s.jsx)(n.code,{children:"sendOrderConfirmationEmail"})," or ",(0,s.jsx)(n.code,{children:"updateCustomerInformation"})," first?)"]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["We typically call component that invokes or calls a function or method ",(0,s.jsx)(n.strong,{children:"caller"}),", while the one that is being invoked or called is called ",(0,s.jsx)(n.strong,{children:"callee"}),"."]})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Tight Coupling :"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class UserService {\n    private val userRepository = UserRepository()\n\n    fun getUserById(userId: String): User {\n        return userRepository.getUserById(userId)\n    }\n\n    fun saveUser(user: User) {\n        userRepository.saveUser(user)\n    }\n}\n\nclass UserRepository {\n    fun getUserById(userId: String): User {}\n    fun saveUser(user: User) {}\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Loose Coupling :"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"interface UserRepository {\n    fun getUserById(userId: String): User\n    fun saveUser(user: User)\n}\n\nclass UserService(private val userRepository: UserRepository) {\n    fun getUserById(userId: String): User {\n        return userRepository.getUserById(userId)\n    }\n\n    fun saveUser(user: User) {\n        userRepository.saveUser(user)\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"UserService"})," class in tight coupling code depends a lot on ",(0,s.jsx)(n.code,{children:"UserRepository"})," class. By depend, it means that the class really need to suit their method and the way of how it operates based on the class it depends on. If somehow we want to change the behavior of ",(0,s.jsx)(n.code,{children:"UserRepository"}),", we will need to change the ",(0,s.jsx)(n.code,{children:"UserService"})," as well. Tight coupling decrease flexibility and maintainability."]}),"\n",(0,s.jsxs)(n.p,{children:["On the other hand, the loose coupling code introduce an interface, which allows for different implementation of ",(0,s.jsx)(n.code,{children:"UserRepository"})," to be provided for ",(0,s.jsx)(n.code,{children:"UserService"})," class. The ",(0,s.jsx)(n.code,{children:"UserService"})," depend on the interface, and the implementor adhere to it. A modification to ",(0,s.jsx)(n.code,{children:"UserRepository"})," behavior doesn't require us to modify many things, this is because they are based on the interface contract."]}),"\n",(0,s.jsxs)(n.p,{children:["The contract is nothing but a specification that the method ",(0,s.jsx)(n.code,{children:"getUserById"})," must take a ",(0,s.jsx)(n.code,{children:"userId"})," of type ",(0,s.jsx)(n.code,{children:"String"})," and return an object ",(0,s.jsx)(n.code,{children:"User"}),", similar to the ",(0,s.jsx)(n.code,{children:"saveUser"})," method. This allows us to create a variety of class that may have different way of processing the data internally."]}),"\n",(0,s.jsx)(n.h3,{id:"lod",children:"LoD"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"LoD (Law of Demeter)"})," is a design principle that promotes loose coupling and encapsulation in ",(0,s.jsx)(n.a,{href:"/computer-and-programming-fundamentals/object-oriented-programming",children:"object-oriented programming"}),". The principle states that an object should have limited knowledge about other objects and should only interact with its immediate neighbors."]}),"\n",(0,s.jsx)(n.h3,{id:"soc",children:"SoC"}),"\n",(0,s.jsx)(n.h3,{id:"unidirectional-data-flow",children:"Unidirectional Data Flow"}),"\n",(0,s.jsx)(n.h3,{id:"composition-over-inheritance",children:"Composition Over Inheritance"}),"\n",(0,s.jsx)(n.h3,{id:"clean-code",children:"Clean Code"}),"\n",(0,s.jsx)(n.h3,{id:"solid",children:"SOLID"})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},80431:(e,n,i)=>{i.d(n,{Z:()=>s});const s=i.p+"assets/images/cohesion-coupling-cddf66e3155590235fa9b95ebc73f607.png"},11151:(e,n,i)=>{i.d(n,{Z:()=>a,a:()=>o});var s=i(67294);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);