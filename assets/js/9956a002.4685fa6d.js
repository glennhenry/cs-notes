"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[8128],{87817:(e,r,a)=>{a.r(r),a.d(r,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>c,toc:()=>d});var t=a(85893),n=a(11151);const i={slug:"/computer-organization-and-architecture/harvard",id:"harvard",title:"Harvard",description:"Harvard"},s=void 0,c={id:"computer-organization-and-architecture/harvard/harvard",title:"Harvard",description:"Harvard",source:"@site/docs/computer-organization-and-architecture/10-harvard/harvard.md",sourceDirName:"computer-organization-and-architecture/10-harvard",slug:"/computer-organization-and-architecture/harvard",permalink:"/cs-notes/computer-organization-and-architecture/harvard",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/computer-organization-and-architecture/10-harvard/harvard.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1708081935,formattedLastUpdatedAt:"Feb 16, 2024",frontMatter:{slug:"/computer-organization-and-architecture/harvard",id:"harvard",title:"Harvard",description:"Harvard"},sidebar:"sidebar",previous:{title:"Von Neumann",permalink:"/cs-notes/computer-organization-and-architecture/von-neumann"},next:{title:"ISA",permalink:"/cs-notes/computer-organization-and-architecture/isa"}},o={},d=[{value:"Modified Harvard Architecture",id:"modified-harvard-architecture",level:3}];function h(e){const r={a:"a",br:"br",h3:"h3",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,n.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Main Source :"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Harvard_architecture",children:"Harvard architecture - Wikipedia"})})}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Harvard architecture"})," is another computer architecture design, the characteristics is that it has separate storage for program's instructions and data. In contrast, ",(0,t.jsx)(r.a,{href:"/computer-organization-and-architecture/von-neumann#architecture",children:"von Neumann"})," architecture combines them both."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.img,{alt:"Harvard architecture",src:a(52047).Z+"",width:"362",height:"230"}),(0,t.jsx)(r.br,{}),"\n","Source : ",(0,t.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Harvard_architecture",children:"https://en.wikipedia.org/wiki/Harvard_architecture"})]}),"\n",(0,t.jsx)(r.p,{children:"Characteristics of Harvard architecture :"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Separate Instruction and Data Memory"})," : The Harvard architecture has physically distinct memory systems for storing instructions and data. Instructions are stored in an instruction memory, data is stored in a separate data memory. The distinct memory system makes the addressing different, the same address in the data memory corresponds to a different value in the instruction memory."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Independent Access"})," : The instruction memory and data memory have separate buses or pathways for accessing their respective memories. In contrast, von Neumann architecture uses a shared bus for both. By using separate buses, this allows simultaneous and independent access to instructions and data, enabling the CPU to fetch and process instructions while simultaneously accessing or manipulating data."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Parallel Reading/Writing"})," : In von Neumann architecture, the CPU is required to wait for some time during memory access operations, because they are located in the same place. While in Harvard architecture, the CPU can read and write data simultaneously."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"In general, the Harvard architecture is used in scenarios where cache is not reliable. This occurs when there is a need for frequent data modifications over time, making the previously stored data irrelevant. Another situation where the Harvard architecture is advantageous is when performance is important, having concurrent access to both instructions and data will be beneficial."}),"\n",(0,t.jsx)(r.h3,{id:"modified-harvard-architecture",children:"Modified Harvard Architecture"}),"\n",(0,t.jsx)(r.p,{children:"The modified Harvard architecture combines the original Harvard architecture with some element of von Neumann architecture. The ability of treating data and instruction in the same way can be beneficial in some cases, such as the scenario where the data is from user input and that input will be used to generate code."}),"\n",(0,t.jsx)(r.p,{children:"Modified Harvard architecture has less strict separation between the instructions and data. Some modifications are :"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Split-cache"})," : Modified Harvard architecture has a cache system for both instruction and data memory. The instructions and data caches are combined, which means they have a single address space. Although they may share the same physical cache memory, they are organized and accessed as separate caches."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Data-Instruction Interchangeability"})," : We can treat data in the data memory as instruction, and treat instruction in instruction memory as data. This allows for instruction generated from data, or instruction driven by data."]}),"\n"]})]})}function u(e={}){const{wrapper:r}={...(0,n.a)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},52047:(e,r,a)=>{a.d(r,{Z:()=>t});const t=a.p+"assets/images/harvard-architecture-d33cb82f131dc1a682d138454485f491.png"},11151:(e,r,a)=>{a.d(r,{Z:()=>c,a:()=>s});var t=a(67294);const n={},i=t.createContext(n);function s(e){const r=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),t.createElement(i.Provider,{value:r},e.children)}}}]);