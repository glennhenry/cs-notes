"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[4481],{54972:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>l});var a=i(85893),s=i(11151);const t={slug:"/programming-language-theory/names-scopes-bindings",id:"names-scopes-bindings",title:"Names, Scopes, Bindings",description:"Names, Scopes, Bindings"},r=void 0,o={id:"programming-language-theory/names-scopes-bindings/names-scopes-bindings",title:"Names, Scopes, Bindings",description:"Names, Scopes, Bindings",source:"@site/docs/programming-language-theory/04-names-scopes-bindings/names-scopes-bindings.md",sourceDirName:"programming-language-theory/04-names-scopes-bindings",slug:"/programming-language-theory/names-scopes-bindings",permalink:"/cs-notes/programming-language-theory/names-scopes-bindings",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/programming-language-theory/04-names-scopes-bindings/names-scopes-bindings.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1712317943,formattedLastUpdatedAt:"Apr 5, 2024",frontMatter:{slug:"/programming-language-theory/names-scopes-bindings",id:"names-scopes-bindings",title:"Names, Scopes, Bindings",description:"Names, Scopes, Bindings"},sidebar:"sidebar",previous:{title:"Parsing",permalink:"/cs-notes/programming-language-theory/parsing"},next:{title:"Semantic Analysis",permalink:"/cs-notes/programming-language-theory/semantic-analysis"}},c={},l=[{value:"Binding Time",id:"binding-time",level:3},{value:"Object Lifetime &amp; Storage Management",id:"object-lifetime--storage-management",level:3},{value:"Scope Rules",id:"scope-rules",level:3},{value:"Static Scope",id:"static-scope",level:4},{value:"Declare vs Define",id:"declare-vs-define",level:5},{value:"Dynamic Scope",id:"dynamic-scope",level:4}];function d(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Main Source :"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Book chapter 3"})}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Emphasized again, programming languages are made to enable programmer to create program for computer easily. One benefits of programming language is abstraction. It is the concept of hiding unnecessary details and focusing on essential concept."}),"\n",(0,a.jsxs)(n.p,{children:["Computer stores data in some memory cell referenced with memory address. When making program, obviously it will involve manipulating data. One abstraction regarding data is, the simplification of accessing them. Programmers don't need to know the memory address of certain data, they can instead use ",(0,a.jsx)(n.strong,{children:"variables"})," to represent data."]}),"\n",(0,a.jsx)(n.p,{children:"Variable in programming language are identifier that are associated with names. Names are made mnemonic and descriptive for ease of use. Not only variable, but names are associated with other abstraction, such as function, class in OOP, types, etc."}),"\n",(0,a.jsx)(n.p,{children:"This topic discusses how names are identified, managed, and referenced in programming languages."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Names"})," : Refer to identifiers used to represent variables, functions, classes, modules, or other entities in a program."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Bindings"})," : Binding is the association of a name and the actual object it represents. Binding needs to be established so that names can be used interchangeably with the actual object. For example, a function may be associated with a memory address where it exists, so that the program could invoke or execute the function when needed."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Scopes"})," : Scope define the regions or portions of a program where names are valid and can be accessed. For example, in many programming languages, defining a variable inside a function would make it inaccessible outside it (the variable is local to the function)."]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsx)(n.p,{children:'Although "object" have different meaning in OOP, they are typically used when referring to something that has a name.'})}),"\n",(0,a.jsx)(n.h3,{id:"binding-time",children:"Binding Time"}),"\n",(0,a.jsx)(n.p,{children:"Binding time refers to the time binding decisions are made. Binding decisions is not only associating names with memory addresses, but includes determining the types of variables, resolving references to external entities, and allocating resources."}),"\n",(0,a.jsx)(n.p,{children:"Allocating resources is considered as a binding, because this involves binding particular memory, file handles, or network connections to a program that needs it."}),"\n",(0,a.jsx)(n.p,{children:"Types of binding time :"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Language design time"})," : This may include the decision from the language developer about variable scoping rules, type systems, etc."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Language implementation time"})," : Such as the development of compiler (e.g., how should it manages memory)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Program writing time"})," : The programmers creating variables or choosing certain algorithm or data structures."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Compile time"})," : Occur during compilation time, such as syntax analysis or type checking."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Link time"})," : Linking is the process of connecting external files or libraries to create an executable program. Binding decision in here may involve resolving references to external symbols or functions."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Load time"})," : Occur when the program is loaded into memory for execution. The operating system may handle activities such as dynamic memory allocation."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Runtime"})," : When the program is running, it may make dynamic memory allocations through mechanisms like ",(0,a.jsx)(n.code,{children:"malloc()"})," or ",(0,a.jsx)(n.code,{children:"new"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"object-lifetime--storage-management",children:"Object Lifetime & Storage Management"}),"\n",(0,a.jsx)(n.p,{children:"The lifecycle of object :"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Creation of objects"}),", involves allocating memory to store its data and initializing its state."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Creation of bindings"}),", where names or identifiers are associated with the actual data."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Usage"}),", actual usage when object are referenced in the program."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Deactivation of bindings"}),", when binding becomes invalid, may occur when variable is out of scope."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Destruction of bindings"}),", when binding is deactivated, any resources associated with the binding may be released or freed."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Destruction of objects"}),", when the actual object is destructed and the system reclaim its memory."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["We call the duration or existence of an object or a variable accessible within a program as its ",(0,a.jsx)(n.strong,{children:"lifetime"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"During its lifetime, there are three mechanisms to allocate storage for an object."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/operating-system/memory-management#stack-allocation",children:"Stack allocation"})})," : Memory is allocated in a ",(0,a.jsx)(n.a,{href:"/data-structures-and-algorithms/stack",children:"stack data structure"}),". It is used for storing subroutines call as well as local variables within them. They are fast, efficient, and handled automatically (in a sense) by the compiler."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/operating-system/memory-management#dynamic-allocation",children:"Heap allocation"})})," : Also known as dynamic allocation, in which objects are allocated and deallocated at runtime. It is typically managed manually by programmers, although mechanism like ",(0,a.jsx)(n.a,{href:"/operating-system/memory-management#automatic-memory-management",children:"garbage collection"})," allows it to be automatic."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Static allocation"})," : Static allocation is used for objects with a fixed size and a lifetime that spans the entire program's execution. It could be variable placed in global scope (typically any region outside block or function) or initializing variable with ",(0,a.jsx)(n.code,{children:"static"})," keyword in some programming languages. Object allocated statically has a fixed and reserved place in the program memory, making it accessible anywhere and anytime in the program."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"scope-rules",children:"Scope Rules"}),"\n",(0,a.jsx)(n.p,{children:"Scope rules are the rules about visibility and accessibility of variables, functions, and other identifiers within a program. They determine where and for how long an identifier can be referenced or used."}),"\n",(0,a.jsx)(n.h4,{id:"static-scope",children:"Static Scope"}),"\n",(0,a.jsxs)(n.p,{children:["We call the languages that determine scope of an identifier in compile-time based on the lexical structure of the program as ",(0,a.jsx)(n.strong,{children:"static scope"})," or ",(0,a.jsx)(n.strong,{children:"lexical scope"}),". Example of statically scoped languages are C, C++, Java, Python, and most programming languages in general."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, below are code taken from ",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scope",children:"Wikipedia"}),". The lexical structure of program refers to the arrangement of its code into blocks, functions, and other nested structures. Each block or function introduces a new scope."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"program A;\nvar I:integer;\n    K:char;\n\n    procedure B;\n    var K:real;\n        L:integer;\n\n        procedure C;\n        var M:real;\n        begin\n         (*scope A+B+C*)\n        end;\n\n     (*scope A+B*)\n    end;\n\n (*scope A*)\nend.\n"})}),"\n",(0,a.jsxs)(n.p,{children:["When a variable is declared within a block or subroutine, its scope is limited to that block or subroutine and any nested blocks or subroutines within it. When a variable is referenced within a nested subroutine, the compiler or interpreter first searches for its declaration within the nested subroutine's scope. If the variable is not found, it continues the search in the enclosing (parent) scope and proceeds up the lexical chain until the declaration is found or until the global scope is reached. The process of resolving variable binding (finding out which variable does a name belong to) in nested scopes is called ",(0,a.jsx)(n.strong,{children:"static chains"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.img,{alt:"Static chains",src:i(76650).Z+"",width:"466",height:"402"}),(0,a.jsx)(n.br,{}),"\n","Source : Book page 120"]}),"\n",(0,a.jsxs)(n.p,{children:["When multiple declaration are found, the nearest declaration are typically bound, this is called the ",(0,a.jsx)(n.strong,{children:"nearest declaration rule"}),". We call a situation in which a variable declaration in an inner scope has the same name as a variable declared in an outer scope, temporarily hiding the outer binding as ",(0,a.jsx)(n.strong,{children:"shadowing"}),". When there is shadowing, we also say the scope has a ",(0,a.jsx)(n.strong,{children:"hole"})," in it."]}),"\n",(0,a.jsx)(n.h5,{id:"declare-vs-define",children:"Declare vs Define"}),"\n",(0,a.jsxs)(n.p,{children:["Some programming languages have a strict requirement for declaring entities before they are used. For example, languages like C and C++ require a ",(0,a.jsx)(n.strong,{children:"forward declaration"})," when forward referencing a function or a structure. The use of forward declaration is helpful for compiler when defining a recursive subroutine or types."]}),"\n",(0,a.jsxs)(n.p,{children:['Declaration refers to the introduction of a name and its scope, while definition "defines" the actual thing that a name is bound to. For example, ',(0,a.jsx)(n.code,{children:"int x;"})," is declaring a name ",(0,a.jsx)(n.code,{children:"x"})," and associating it with ",(0,a.jsx)(n.code,{children:"int"})," type within the current scope, while ",(0,a.jsx)(n.code,{children:"int x = 42;"})," not only declaring but also specifying actual value and allocating memory for ",(0,a.jsx)(n.code,{children:"x"}),"."]}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["Note that ",(0,a.jsx)(n.code,{children:"int"})," is a primitive type, so memory allocation actually happens at declaration."]})}),"\n",(0,a.jsxs)(n.p,{children:["When making a recursive type like a ",(0,a.jsx)(n.a,{href:"/data-structures-and-algorithms/linked-list",children:"linked list"})," in C, we will need to declare the type first before defining it."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"struct Node; // Declaration\n\nstruct Node { // Definition, it defines that struct Node has int data and another struct Node\n    int data;\n    struct Node; // Can't use if not declared\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"dynamic-scope",children:"Dynamic Scope"}),"\n",(0,a.jsxs)(n.p,{children:["On the other hand, ",(0,a.jsx)(n.strong,{children:"dynamic scope"})," language resolve variables binding at runtime. When a variable is referenced, the program searches for the most recent binding of the variable, starting from the current execution context and moving up the call stack."]}),"\n",(0,a.jsx)(n.p,{children:"The nature of binding resolution during runtime introduces challenges for compilers, where they analyze and translate source code with binding information resolved statically. Dynamically scoped language are typically interpreted, because they evaluate expressions and resolve variable bindings dynamically as the program runs. Example of dynamically scoped language are old languages like Lisp and APL."}),"\n",(0,a.jsx)(n.p,{children:"For example, each recursive calls in a recursive function may introduce new bindings for variables. A compiler obviously cannot predict the number of recursive calls or the specific bindings that will be active at runtime. This is why interpreter is more suitable for dynamically scoped language as they execute program directly."}),"\n",(0,a.jsx)(n.p,{children:"Dynamic scoping can make code harder to understand. This is especially for programmer used to static scoping language. When defining a variable like this :"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"x: Int\n\nfunction f():\n    x = 3\n\nfunction g():\n    x: Int = 5\n    f()\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We may expect that ",(0,a.jsx)(n.code,{children:"x = 3"})," defines the declaration of global variable ",(0,a.jsx)(n.code,{children:"x"})," outside the function. When ",(0,a.jsx)(n.code,{children:"f"})," is not called from ",(0,a.jsx)(n.code,{children:"main"})," but in another function like ",(0,a.jsx)(n.code,{children:"g"}),", where it also defines another ",(0,a.jsx)(n.code,{children:"x"}),", then ",(0,a.jsx)(n.code,{children:"f"})," will instead modify ",(0,a.jsx)(n.code,{children:"x"})," inside ",(0,a.jsx)(n.code,{children:"g"}),". This occurs because the most recent binding is always the local variable."]}),"\n",(0,a.jsx)(n.p,{children:"One benefits of dynamic scope is that it allows us to temporarily change the behavior of code that uses some global variable."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"x: Int = 5\n\nfunction print(x):\n    print_console(x)\n\nfunction changeX(x):\n    x = 10\n\nprint(x) // Output: 5\n\nblock {\n    changeX(10)\n    print(x) // Output: 10\n}\n\nprint(x) // Output: 5\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"changeX"})," only change the ",(0,a.jsx)(n.code,{children:"x"})," inside ",(0,a.jsx)(n.code,{children:"block"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},76650:(e,n,i)=>{i.d(n,{Z:()=>a});const a=i.p+"assets/images/static-chains-8f295d3d6f115943c13300d19e074b7e.png"},11151:(e,n,i)=>{i.d(n,{Z:()=>o,a:()=>r});var a=i(67294);const s={},t=a.createContext(s);function r(e){const n=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);