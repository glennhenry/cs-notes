"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[2748],{16687:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>c});var a=i(85893),s=i(11151);const t={slug:"/compilers-and-programming-languages/functional-languages",id:"functional-languages",title:"Functional Languages",description:"Functional Languages"},r=void 0,o={id:"compilers-and-programming-languages/functional-languages/functional-languages",title:"Functional Languages",description:"Functional Languages",source:"@site/docs/compilers-and-programming-languages/16-functional-languages/functional-languages.md",sourceDirName:"compilers-and-programming-languages/16-functional-languages",slug:"/compilers-and-programming-languages/functional-languages",permalink:"/cs-notes/compilers-and-programming-languages/functional-languages",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/compilers-and-programming-languages/16-functional-languages/functional-languages.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1723455088e3,frontMatter:{slug:"/compilers-and-programming-languages/functional-languages",id:"functional-languages",title:"Functional Languages",description:"Functional Languages"},sidebar:"sidebar",previous:{title:"Compiler Optimization",permalink:"/cs-notes/compilers-and-programming-languages/compiler-optimization"},next:{title:"Logic Languages",permalink:"/cs-notes/compilers-and-programming-languages/logic-languages"}},l={},c=[{value:"Scheme",id:"scheme",level:3},{value:"Binding",id:"binding",level:4},{value:"Lists",id:"lists",level:4},{value:"Control Flow &amp; Assignment",id:"control-flow--assignment",level:4},{value:"Program as Data",id:"program-as-data",level:4},{value:"Monads",id:"monads",level:4},{value:"Trade-offs",id:"trade-offs",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Main Source:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Book 2 chapter 10"})}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["See also ",(0,a.jsx)(n.a,{href:"/computer-and-programming-fundamentals/declarative-functional-programming#functional-programming",children:"functional programming"}),"."]})}),"\n",(0,a.jsx)(n.h3,{id:"scheme",children:"Scheme"}),"\n",(0,a.jsx)(n.p,{children:"Scheme is an interpreted, functional programming language in the Lisp family."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"REPL"}),": In Scheme, users runs program by interacting with the interpreter directly by manually typing expressions into the standard input. The interpreter continuously reads these expressions, evaluates them, and prints the results back to the user in a loop known as the ",(0,a.jsx)(n.strong,{children:"read-eval-print loop (REPL)"}),". We can also run a program through input file using the ",(0,a.jsx)(n.code,{children:"load"})," function (e.g., ",(0,a.jsx)(n.code,{children:'load "program_name"'}),")."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Prefix Notation"}),": Expression is written in ",(0,a.jsx)(n.a,{href:"/compilers-and-programming-languages/control-flow#expression-evaluation",children:"prefix notation"}),", with input ",(0,a.jsx)(n.code,{children:"(+ 3 4)"}),", the interpreter prints ",(0,a.jsx)(n.code,{children:"7"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Assignment"}),": We can assign variable like below."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:'(define x 42)\n(define y "foo")\n(define z \'(1 2 3))\n'})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Dynamic Typing"}),": Scheme checks type in runtime, incompatible operation between types will result an error in runtime instead of compile-time. ",(0,a.jsx)(n.code,{children:'(if (> a 0) (+ 2 3) (+ 2 "foo"))'})," if ",(0,a.jsx)(n.code,{children:"a"})," is less than or equal to 0, this expression evaluates to adding number with a string (",(0,a.jsx)(n.code,{children:'2 + "foo"'})," in infix notation), which is incompatible."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Type Predicates"}),": Type predicates are functions to check the type of a value, returning ",(0,a.jsx)(n.code,{children:"#t"})," (true) or ",(0,a.jsx)(n.code,{children:"#f"})," (false). For example, ",(0,a.jsx)(n.code,{children:"(number? x)"})," and ",(0,a.jsx)(n.code,{children:"(boolean?) x"})," check if ",(0,a.jsx)(n.code,{children:"x"})," is ",(0,a.jsx)(n.code,{children:"number"})," or ",(0,a.jsx)(n.code,{children:"boolean"})," type, respectively."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Symbol"}),": Symbol is a data type for identifier in Scheme. We can define symbol using syntactic sugar ",(0,a.jsx)(n.code,{children:"'"})," followed by the symbol literal, such as ",(0,a.jsx)(n.code,{children:"(define my-symbol 'foo)"}),". Then, we can use ",(0,a.jsx)(n.code,{children:"my-symbol"})," variable or the actual symbol ",(0,a.jsx)(n.code,{children:"foo"})," as something that represent identifiers."]}),"\n",(0,a.jsxs)(n.p,{children:["The point of having symbol type is their efficiency on certain operation. They are ",(0,a.jsx)(n.em,{children:"interned"}),", meaning the same name are represented by the same object in a symbol table. This allows for comparing equality of two variable with ",(0,a.jsx)(n.code,{children:"eq?"})," operator to be more efficient than using pointer, because it simply checks whether the symbols are the same object."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Function"}),": Function is defined using ",(0,a.jsx)(n.code,{children:"define"})," keyword."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:"(define (add a b)\n    (+ a b))\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Function can also be defined using lambda expression. ",(0,a.jsx)(n.code,{children:"lambda (a b) (+ a b)"})," is a function that takes two formal parameter ",(0,a.jsx)(n.code,{children:"a"})," and ",(0,a.jsx)(n.code,{children:"b"}),". The latter is the body of the lambda expression."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["Scheme doesn't allow extra parentheses, it uses them to isolate expression (called ",(0,a.jsx)(n.strong,{children:"S-expression syntax"}),"). The expression ",(0,a.jsx)(n.code,{children:"((+ 3 3))"})," can cause runtime error due to Scheme thinking it was a function which should take argument on the left."]})}),"\n",(0,a.jsx)(n.h4,{id:"binding",children:"Binding"}),"\n",(0,a.jsx)(n.p,{children:"We can create local binding within a specific scope to define variable or local function."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:"(let ((x 2)\n      (y 3))\n  (+ x y))    ; Returns 5\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"x"})," and ",(0,a.jsx)(n.code,{children:"y"})," is only valid inside the body of ",(0,a.jsx)(n.code,{children:"let"})," expression."]}),"\n",(0,a.jsx)(n.h4,{id:"lists",children:"Lists"}),"\n",(0,a.jsxs)(n.p,{children:["We can declare a list like ",(0,a.jsx)(n.code,{children:"(define my-list '(1 2 3 4))"}),". Scheme provides several built-in functions to manipulate list, such as ",(0,a.jsx)(n.code,{children:"car"})," to get the first element of the list, ",(0,a.jsx)(n.code,{children:"cdr"})," to get the last element of the list, and ",(0,a.jsx)(n.code,{children:"length"})," to get the number of elements in the list."]}),"\n",(0,a.jsx)(n.h4,{id:"control-flow--assignment",children:"Control Flow & Assignment"}),"\n",(0,a.jsx)(n.p,{children:"Selection control flow such as if-else statement:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:'(if (< x 10)\n    (display "x is less than 10")\n    (display "x is greater than or equal to 10"))\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Or using ",(0,a.jsx)(n.code,{children:"cond"})," to be able to specify multiple condition (if-elseif-else statement)."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:'(cond ((> x 10) (display "x is greater than 10"))\n      ((< x 10) (display "x is less than 10"))\n      (else (display "x is equal to 10")))\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"display"})," is a function to print."]})}),"\n",(0,a.jsx)(n.p,{children:"Iteration is done with recursion."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:"(define (count-down n)\n  (if (<= n 0)\n      'done\n      (begin\n        (display n)\n        (newline)\n        (count-down (- n 1)))))\n\n(count-down 5)   ;\n"})}),"\n",(0,a.jsx)(n.p,{children:'This function outputs "5 4 3 2 1" (each in newline). It recursively counts down from a given number until it reaches zero.'}),"\n",(0,a.jsx)(n.h4,{id:"program-as-data",children:"Program as Data"}),"\n",(0,a.jsx)(n.p,{children:"Scheme typically represent program as data in data structure like list. Expressions are nested within parentheses, a program represented as a list consists of nested lists, with each list representing an expression or a subexpression."}),"\n",(0,a.jsx)(n.p,{children:"With this following program."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:"(define (add x y)\n  (+ x y))\n\n(display (add 3 4))\n"})}),"\n",(0,a.jsx)(n.p,{children:"We can represent it in list structure."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:"'((define (add x y)\n    (+ x y))\n  (display (add 3 4)))\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Since Scheme treats its own program as data that can be manipulated, transformed, and evaluated dynamically at runtime, it allows for easier metaprogramming. The property of a language that represents program code as data is called ",(0,a.jsx)(n.strong,{children:"homoiconicity"}),", enabling tasks such as code generation, code analysis, and program transformation."]}),"\n",(0,a.jsx)(n.h4,{id:"monads",children:"Monads"}),"\n",(0,a.jsxs)(n.p,{children:["Functional programming always favor program without side effect. However, the use of I/O feature such as ",(0,a.jsx)(n.code,{children:"read"})," (read user input) or ",(0,a.jsx)(n.code,{children:"display"})," (print to console) that interacts with external world may be a source of side effects."]}),"\n",(0,a.jsx)(n.p,{children:"We can model I/O as streams, which are unbounded-length lists generated lazily. This means that values are computed as they are needed, rather than all at once. It allows for better control over when and how the side effects occur. Furthermore, it ensures that program is properly ordered, by computing only what is needed at a given time. Only when a specific value is needed, such as when an output is required, is the corresponding prompt or input evaluated to produce the necessary result."}),"\n",(0,a.jsxs)(n.p,{children:["This style of modeling I/O system as a stream becomes the foundational model called ",(0,a.jsx)(n.strong,{children:"monad"})," (a more general concept) in language like Haskell. Monad is an abstraction that encapsulate a value to a sequence of computations with effects."]}),"\n",(0,a.jsx)(n.h3,{id:"trade-offs",children:"Trade-offs"}),"\n",(0,a.jsxs)(n.p,{children:["The principle in functional programming that favor immutability and no side effect is achieved through doing transformations and operations on new values instead on existing values. This also means that more objects will be allocated in memory. It will make manual memory management complex, thus functional language typically rely on ",(0,a.jsx)(n.a,{href:"/computer-and-programming-fundamentals/memory#garbage-collection",children:"garbage collection"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Immutable data structures may require more memory allocation and copying, which can make the program less efficient. On the other side, the property of immutability and no side effect make the program much more predictable, easier to debug, and readable. Furthermore, with the guarantee of data being immutable, it becomes easier to reason about and safely execute code in parallel."}),"\n",(0,a.jsx)(n.p,{children:"A programmer who is used to OOP or imperative languages may face a steep learning curve when trying to learn a pure functional programming language. It can be less intuitive to deal with I/O operations without mutable state or side effect."}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsx)(n.p,{children:"A mutable state means it can be potentially modified by any number of entities, which can make it harder to find the actual source of modification and reason about the behavior of the program."})})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>o,a:()=>r});var a=i(67294);const s={},t=a.createContext(s);function r(e){const n=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);