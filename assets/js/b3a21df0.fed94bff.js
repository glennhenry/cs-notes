"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[3321],{45681:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>n,metadata:()=>o,toc:()=>c});var r=i(85893),s=i(11151);const n={slug:"/computer-graphics/textures-part-1",id:"textures-part-1",title:"Textures (Part 1)",description:"Textures (Part 1)"},a="Textures (Part 1)",o={id:"computer-graphics/textures-part-1/textures-part-1",title:"Textures (Part 1)",description:"Textures (Part 1)",source:"@site/docs/computer-graphics/09-textures-part-1/textures-part-1.md",sourceDirName:"computer-graphics/09-textures-part-1",slug:"/computer-graphics/textures-part-1",permalink:"/cs-notes/computer-graphics/textures-part-1",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/computer-graphics/09-textures-part-1/textures-part-1.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1708424103,formattedLastUpdatedAt:"Feb 20, 2024",frontMatter:{slug:"/computer-graphics/textures-part-1",id:"textures-part-1",title:"Textures (Part 1)",description:"Textures (Part 1)"},sidebar:"sidebar",previous:{title:"Surfaces",permalink:"/cs-notes/computer-graphics/surfaces"},next:{title:"Textures (Part 2)",permalink:"/cs-notes/computer-graphics/textures-part-2"}},l={},c=[{value:"Texture Filtering",id:"texture-filtering",level:3},{value:"Nearest Neighbor Filtering",id:"nearest-neighbor-filtering",level:3},{value:"Bilinear Filtering",id:"bilinear-filtering",level:3},{value:"Bicubic Filtering",id:"bicubic-filtering",level:3},{value:"Texture Flickering",id:"texture-flickering",level:3},{value:"Mipmapping",id:"mipmapping",level:3},{value:"Trilinear Filtering",id:"trilinear-filtering",level:3},{value:"Anisotropic Filtering",id:"anisotropic-filtering",level:3},{value:"Texture Tiling",id:"texture-tiling",level:3}];function h(e){const t={a:"a",br:"br",h1:"h1",h3:"h3",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"textures-part-1",children:"Textures (Part 1)"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsxs)(t.strong,{children:["Main Source : ",(0,r.jsx)(t.a,{href:"https://youtu.be/Yjv6hc4Zqjk",children:"Intro to Graphics 13 - Textures"})]})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Texture"})," refers to the surface characteristics of an object that are used to create its visual appearance. Texture can be thought of as a pattern or a image that is applied to the surface of a 3D model to create the appearance of different materials or surfaces, such as wood, metal, fabric, or skin."]}),"\n",(0,r.jsxs)(t.p,{children:["The smallest unit of information is called pixel, in texture we call this ",(0,r.jsx)(t.strong,{children:"texel."})," The process of accessing a specific texel in a texture map to determine the color or other properties of a surface at a specific point are called ",(0,r.jsx)(t.strong,{children:"Texture Sampling"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Textures are typically created as 2D images, and they can be applied to the surface of a 3D model using a process called ",(0,r.jsx)(t.strong,{children:"texture mapping"}),". In texture mapping, the coordinate in texture images is called ",(0,r.jsx)(t.strong,{children:"Texture Space"})," while the 3D model is caled ",(0,r.jsx)(t.strong,{children:"Object Space"}),". Texture also consider object transformation, if the object is transformed (rotated, scaled, or translated), the texture will also be transformed with it."]}),"\n",(0,r.jsx)(t.h3,{id:"texture-filtering",children:"Texture Filtering"}),"\n",(0,r.jsx)(t.p,{children:"We have a texture and we want to map it to a point, we take a texel in the texture space and map it to the object. In many cases, the texture coordinates do not align exactly with the texels in the texture map."}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.img,{alt:"A point inside a triangle is pointing to specific texels",src:i(89165).Z+"",width:"442",height:"191"}),(0,r.jsx)(t.br,{}),"\n","Source : ",(0,r.jsx)(t.a,{href:"https://youtu.be/Yjv6hc4Zqjk?t=1345",children:"https://youtu.be/Yjv6hc4Zqjk?t=1345"})]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Texture Filtering"})," is the process of interpolating between adjacent texels in a texture map to create a smooth appearance when the texture is applied to a 3D object. Texture is not directly mapped but it is just an approximation of the appearance of a surface."]}),"\n",(0,r.jsx)(t.p,{children:"There are some technique to address this issue :"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Nearest Neighbor Filtering"}),"\n",(0,r.jsx)(t.li,{children:"Bilinear Filtering"}),"\n",(0,r.jsx)(t.li,{children:"Bicubic Filtering"}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.img,{alt:"A comparison between nearest showing pixelated color, bilinear showing blurry pixelated color, and bicubic is very blurry without being pixelated",src:i(42303).Z+"",width:"853",height:"282"}),(0,r.jsx)(t.br,{}),"\n","Source : ",(0,r.jsx)(t.a,{href:"https://www.researchgate.net/figure/Interpolation-methods-Nearest-neighbour-interpolation-left-assigns-the-value-of-the_fig7_341509407",children:"https://www.researchgate.net/figure/Interpolation-methods-Nearest-neighbour-interpolation-left-assigns-the-value-of-the_fig7_341509407"})]}),"\n",(0,r.jsx)(t.h3,{id:"nearest-neighbor-filtering",children:"Nearest Neighbor Filtering"}),"\n",(0,r.jsxs)(t.p,{children:["With nearest neighbor filtering, the ",(0,r.jsx)(t.strong,{children:"texel closest to the texture coordinate"})," is selected and used as the texture color for the pixel. This is easiest and fastest filtering but results in a blocky or pixelated appearance, as the edges between adjacent texels are clearly visible."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"Picking the nearest color between red, yellow, green, magenta with the yellow being closest",src:i(58440).Z+"",width:"812",height:"594"})}),"\n",(0,r.jsx)(t.h3,{id:"bilinear-filtering",children:"Bilinear Filtering"}),"\n",(0,r.jsxs)(t.p,{children:["With bilinear filtering, the ",(0,r.jsx)(t.strong,{children:"four nearest texels"})," surrounding the texture coordinate are sampled and their colors are blended together using linear interpolation to produce the final color of the pixel. This method produces a smoother appearance than nearest neighbor filtering."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.img,{alt:"A pixel is filtered from four nearest texels and distance from all point is calculated",src:i(72177).Z+"",width:"470",height:"233"}),(0,r.jsx)(t.br,{}),"\n","Source : ",(0,r.jsx)(t.a,{href:"https://youtu.be/Yjv6hc4Zqjk?t=1457",children:"https://youtu.be/Yjv6hc4Zqjk?t=1457"}),", ",(0,r.jsx)(t.a,{href:"https://youtu.be/Yjv6hc4Zqjk?t=1741",children:"https://youtu.be/Yjv6hc4Zqjk?t=1741"})]}),"\n",(0,r.jsx)(t.h3,{id:"bicubic-filtering",children:"Bicubic Filtering"}),"\n",(0,r.jsxs)(t.p,{children:["With bicubic filtering, a ",(0,r.jsx)(t.strong,{children:"4x4 matrix of the closest texels"})," surrounding the texture coordinate is sampled, and the color of the pixel is calculated using a cubic polynomial function that takes into account the colors and positions of the surrounding texels."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.img,{alt:"A pixel is filtered from 16 nearest texels",src:i(10673).Z+"",width:"149",height:"184"}),(0,r.jsx)(t.br,{}),"\n","Source : ",(0,r.jsx)(t.a,{href:"https://youtu.be/Yjv6hc4Zqjk?t=2135",children:"https://youtu.be/Yjv6hc4Zqjk?t=2135"})]}),"\n",(0,r.jsx)(t.h3,{id:"texture-flickering",children:"Texture Flickering"}),"\n",(0,r.jsx)(t.p,{children:"When an object is small, the texels in the texture map become larger relative to the size of the object, making individual texels more visible and causing the collide with other. In other word the texels is too big to fit in to each pixel."}),"\n",(0,r.jsx)(t.p,{children:"In the image below, the closer texture looks okay, but further away you will see it become noised."}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.img,{alt:"A plane with noised texture in far sight",src:i(51146).Z+"",width:"352",height:"266"}),(0,r.jsx)(t.br,{}),"\n","Source : ",(0,r.jsx)(t.a,{href:"https://youtu.be/Yjv6hc4Zqjk?t=2458",children:"https://youtu.be/Yjv6hc4Zqjk?t=2458"}),"\nUsing bilinear filtering"]}),"\n",(0,r.jsx)(t.p,{children:"When we move the camera the texture sampled will change, if texels is larger compared to pixel, the texels mapped can change color frequenly making it looks like flickering or shimmering."}),"\n",(0,r.jsx)(t.p,{children:"The solution for this would to take more texel color into consideration and interpolate them."}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.img,{alt:"Two brick texture, one is sampled in the divider and another is sampled in the orange area",src:i(58770).Z+"",width:"371",height:"447"}),(0,r.jsx)(t.br,{}),"\n","Source : ",(0,r.jsx)(t.a,{href:"https://youtu.be/Yjv6hc4Zqjk?t=2664",children:"https://youtu.be/Yjv6hc4Zqjk?t=2664"})]}),"\n",(0,r.jsx)(t.h3,{id:"mipmapping",children:"Mipmapping"}),"\n",(0,r.jsxs)(t.p,{children:["Another way to solve texture flicker issue is to use mipmapping. It\u2019s a technique to make a lower resolution texture which are precomputed from texture maps. The texture are progressively smaller versions of the texture map and is called ",(0,r.jsx)(t.strong,{children:"mipmap level"})," which are usually halved from the previous."]}),"\n",(0,r.jsx)(t.p,{children:"The graphics hardware selects the appropriate level from the mipmap pyramid based on the distance between the object and the camera."}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.img,{alt:"Mipmapping comparison with level 0 being the highest resolution and level 7 being the lowest resolution making it looks blurry",src:i(12741).Z+"",width:"506",height:"300"}),(0,r.jsx)(t.br,{}),"\n","Source : ",(0,r.jsx)(t.a,{href:"https://youtu.be/Yjv6hc4Zqjk?t=2974",children:"https://youtu.be/Yjv6hc4Zqjk?t=2974"})]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.img,{alt:"Comparison between without mipmapping showing a plane textures colliding with each other and with mipmapping creates a smoother plane textures",src:i(71465).Z+"",width:"444",height:"127"}),(0,r.jsx)(t.br,{}),"\n","Source : ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Mipmap",children:"https://en.wikipedia.org/wiki/Mipmap"})]}),"\n",(0,r.jsx)(t.h3,{id:"trilinear-filtering",children:"Trilinear Filtering"}),"\n",(0,r.jsxs)(t.p,{children:["Sometimes the mipmap level can be too high or too low, so if we use bilinear filter in each texture, an another linear interpolation is done between them creating a new texture filter called ",(0,r.jsx)(t.strong,{children:"Trilinear Filter"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.img,{alt:"Showing two level of mipmapping both with bilinear filter combined to make trilinear filter",src:i(9283).Z+"",width:"288",height:"285"}),(0,r.jsx)(t.br,{}),"\n","Source : ",(0,r.jsx)(t.a,{href:"https://youtu.be/Yjv6hc4Zqjk?t=3340",children:"https://youtu.be/Yjv6hc4Zqjk?t=3340"})]}),"\n",(0,r.jsx)(t.h3,{id:"anisotropic-filtering",children:"Anisotropic Filtering"}),"\n",(0,r.jsx)(t.p,{children:"While filtering texture for surfaces that are viewed at oblique angles, such as the surface of a road or a tiled floor, we may oversampled the required texture. This makes further away textuers appear to be blurry."}),"\n",(0,r.jsx)(t.p,{children:"Anisotropic Filtering instead try to only sample the required texture by making a more smaller texel which improve the approximation."}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.img,{alt:"Anisotropic filtering make a smaller filter to texture compared to mipmap taking unnecesarry texel",src:i(81081).Z+"",width:"347",height:"202"}),(0,r.jsx)(t.br,{}),"\n","Source : ",(0,r.jsx)(t.a,{href:"https://youtu.be/Yjv6hc4Zqjk?t=3526",children:"https://youtu.be/Yjv6hc4Zqjk?t=3526"})]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.img,{alt:"Comparison between trilinear showing blurry brick textured plane and anisotropic showing a smoother texture",src:i(49220).Z+"",width:"678",height:"322"}),(0,r.jsx)(t.br,{}),"\n","Source : ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Anisotropic_filtering",children:"https://en.wikipedia.org/wiki/Anisotropic_filtering"})]}),"\n",(0,r.jsx)(t.h3,{id:"texture-tiling",children:"Texture Tiling"}),"\n",(0,r.jsx)(t.p,{children:"Texture may have limited amount of texels that it doesn\u2019t fulfill to map all object surfaces. Texture Tiling is the process of making texture sufficient for mapping to object. Some texture tiling method include :"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Repeat"})," : Texture is repeated seamlessly in both directions when the texture coordinates extend beyond the edges of the texture map. This creates a repeating pattern across the surface of the object."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Mirrored Repeat"})," : Same as repeat, but it alternates between mirroring the texture horizontally and vertically each time it repeats."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Clamp to Edge"})," : The texture coordinates are clamped to the edges of the texture map when they extend beyond the boundaries of the texture map. This creates a image color border around the edges of the texture."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Clamp to Border"})," : Same as clamp to edge but instead uses a user-defined solid border color."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.img,{alt:"Comparison of texture tiling",src:i(70936).Z+"",width:"480",height:"108"}),(0,r.jsx)(t.br,{}),"\n","Source : ",(0,r.jsx)(t.a,{href:"https://community.khronos.org/t/how-to-get-gl-clamp-to-border-effect/104085",children:"https://community.khronos.org/t/how-to-get-gl-clamp-to-border-effect/104085"})]})]})}function p(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},49220:(e,t,i)=>{i.d(t,{Z:()=>r});const r=i.p+"assets/images/anisotropic-filtering-comparison-8a2e69375eedff160e2120e2712663eb.png"},81081:(e,t,i)=>{i.d(t,{Z:()=>r});const r=i.p+"assets/images/anisotropic-filtering-59419343a4638cb1c35e827bbff2fed4.png"},10673:(e,t,i)=>{i.d(t,{Z:()=>r});const r=i.p+"assets/images/bicubic-filtering-e1ddfb4d7573325a1a18dcb1ca1933dd.png"},72177:(e,t,i)=>{i.d(t,{Z:()=>r});const r=i.p+"assets/images/bilinear-filtering-9a591d8cce99a4f13cfa288e641f8bb7.png"},71465:(e,t,i)=>{i.d(t,{Z:()=>r});const r=i.p+"assets/images/mipmapping-comparison-91d076110f2715c4c600beea2b29bc27.png"},12741:(e,t,i)=>{i.d(t,{Z:()=>r});const r=i.p+"assets/images/mipmapping-e0ed1128b795fc12cb226ecfa5cc0173.png"},58440:(e,t,i)=>{i.d(t,{Z:()=>r});const r=i.p+"assets/images/nearest-filtering-0d71bb39edd401fe99c37868add5f0b3.png"},89165:(e,t,i)=>{i.d(t,{Z:()=>r});const r=i.p+"assets/images/texture-filtering-fe22995b13f4687f4f232633b8870464.png"},58770:(e,t,i)=>{i.d(t,{Z:()=>r});const r=i.p+"assets/images/texture-flickering-problem-c909782e292ce90cc88c9485c96f5e55.png"},51146:(e,t,i)=>{i.d(t,{Z:()=>r});const r=i.p+"assets/images/texture-flickering-e3b4aa9e0143bc70e1a68c1d95ca0947.png"},70936:(e,t,i)=>{i.d(t,{Z:()=>r});const r=i.p+"assets/images/texture-tiling-1722083ddce837ad6cc9fb6c76c2c8ce.png"},42303:(e,t,i)=>{i.d(t,{Z:()=>r});const r=i.p+"assets/images/textures-filtering-types-3775b0ed753e704fdf1e982286904f88.png"},9283:(e,t,i)=>{i.d(t,{Z:()=>r});const r=i.p+"assets/images/trilinear-filter-c7fb935a6ec2004ab330e23cc86f6a62.png"},11151:(e,t,i)=>{i.d(t,{Z:()=>o,a:()=>a});var r=i(67294);const s={},n=r.createContext(s);function a(e){const t=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(n.Provider,{value:t},e.children)}}}]);