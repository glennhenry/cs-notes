"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[1056],{28453:(e,t,r)=>{r.d(t,{R:()=>a,x:()=>u});var n=r(96540);const i={},s=n.createContext(i);function a(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function u(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(s.Provider,{value:t},e.children)}},31429:(e,t,r)=>{r.d(t,{A:()=>n});const n=r.p+"assets/images/priority-queue-e2ed55a86613a59bc438f4081262f4be.png"},74717:(e,t,r)=>{r.d(t,{A:()=>n});const n=r.p+"assets/images/queue-of-people-1e133335c4e894636195353e7bb5f5f5.webp"},74913:(e,t,r)=>{r.d(t,{A:()=>n});const n=r.p+"assets/images/queue-data-structure-6caeb08a79f00991940dbe7f253dc072.png"},79161:(e,t,r)=>{r.d(t,{A:()=>n});const n=r.p+"assets/images/double-ended-queue-21289e343d9652aef142d2955a2ce722.jpg"},95380:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>o,contentTitle:()=>u,default:()=>c,frontMatter:()=>a,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"data-structures-and-algorithms/queue/queue","title":"Queue","description":"Queue","source":"@site/docs/data-structures-and-algorithms/05-queue/queue.md","sourceDirName":"data-structures-and-algorithms/05-queue","slug":"/data-structures-and-algorithms/queue","permalink":"/cs-notes/data-structures-and-algorithms/queue","draft":false,"unlisted":false,"editUrl":"https://github.com/glennhenry/cs-notes/tree/main/docs/data-structures-and-algorithms/05-queue/queue.md","tags":[],"version":"current","lastUpdatedBy":"glennhenry","lastUpdatedAt":1723455088000,"frontMatter":{"slug":"/data-structures-and-algorithms/queue","id":"queue","title":"Queue","description":"Queue"},"sidebar":"sidebar","previous":{"title":"Stack","permalink":"/cs-notes/data-structures-and-algorithms/stack"},"next":{"title":"Hash Table","permalink":"/cs-notes/data-structures-and-algorithms/hash-table"}}');var i=r(74848),s=r(28453);const a={slug:"/data-structures-and-algorithms/queue",id:"queue",title:"Queue",description:"Queue"},u=void 0,o={},l=[{value:"Queue Operation",id:"queue-operation",level:3},{value:"Circular Queue",id:"circular-queue",level:3},{value:"Priority Queue",id:"priority-queue",level:3}];function d(e){const t={a:"a",admonition:"admonition",br:"br",h3:"h3",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Main Source:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Queue"})," is a data structure where the elements behave like a literal queue. Queue follows the ",(0,i.jsx)(t.strong,{children:"First-In-First-Out (FIFO)"})," principle, which mean the ",(0,i.jsx)(t.strong,{children:"first element to be removed is the first one added"}),". In contrast, ",(0,i.jsx)(t.a,{href:"/data-structures-and-algorithms/stack",children:"stack data structure"})," supports the ",(0,i.jsx)(t.strong,{children:"Last-In-First-Out (LIFO)"})," principle, which mean the ",(0,i.jsx)(t.strong,{children:"first element to be removed is the last element added"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Just like a literal queue, the elements are organized in a sequence, and the oldest element is always at the front, while the newest element is at the rear."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"Queue of people shopping",src:r(74717).A+"",width:"765",height:"323"}),(0,i.jsx)(t.br,{}),"\n","Source: ",(0,i.jsx)(t.a,{href:"https://www.alamy.com/people-waiting-in-long-queue-shopping-people-in-supermarket-daily-grocery-purchase-image243232560.html",children:"https://www.alamy.com/people-waiting-in-long-queue-shopping-people-in-supermarket-daily-grocery-purchase-image243232560.html"})," (with modification)"]}),"\n",(0,i.jsx)(t.h3,{id:"queue-operation",children:"Queue Operation"}),"\n",(0,i.jsx)(t.p,{children:"Following the FIFO principles, we can remove element in the front (also called head) and add element in the rear (also called back or tail) of the queue."}),"\n",(0,i.jsx)(t.p,{children:"There are two main operation in queue data structure:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Enqueue"}),": Adds an element to the rear of the queue."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Dequeue"}),": Removes the element from the front of the queue."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"Queue data structure operation",src:r(74913).A+"",width:"546",height:"183"}),(0,i.jsx)(t.br,{}),"\n","Source: ",(0,i.jsx)(t.a,{href:"https://www.geeksforgeeks.org/queue-data-structure/",children:"https://www.geeksforgeeks.org/queue-data-structure/"})]}),"\n",(0,i.jsxs)(t.p,{children:["A queue data structure can be implemented efficiently using ",(0,i.jsx)(t.a,{href:"/data-structures-and-algorithms/linked-list#doubly-linked-list",children:"doubly linked list"}),", this is because doubly linked list behavior aligns with queue operation. Doubly linked list has a head and a tail, enqueuing an element, or adding element to the rear of the queue is just inserting element in the tail. Dequeuing an element, or removing an element from the front of the queue is just a linked list deletion in the head. Inserting or deleting element in the head or tail of a linked list can be done in constant time."]}),"\n",(0,i.jsxs)(t.p,{children:["Using doubly linked list, we can even create ",(0,i.jsx)(t.strong,{children:"double ended queue"}),", which is a queue data structure that supports enqueue and dequeue in the front or the rear of the queue."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"Double ended queue",src:r(79161).A+"",width:"685",height:"542"}),(0,i.jsx)(t.br,{}),"\n","Source: ",(0,i.jsx)(t.a,{href:"https://www.geeksforgeeks.org/implementation-deque-using-doubly-linked-list/",children:"https://www.geeksforgeeks.org/implementation-deque-using-doubly-linked-list/"})]}),"\n",(0,i.jsx)(t.h3,{id:"circular-queue",children:"Circular Queue"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Circular Queue"}),", also known as a ",(0,i.jsx)(t.strong,{children:"circular buffer"}),", is a variation of the queue data structure where the element are stored circularly, the last element is connected to the first element, forming a loop. Similar to traditional queue, it follows the FIFO principle, we can only enqueue in the rear and dequeue in the front."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"Circular queue",src:r(99602).A+"",width:"1350",height:"631"}),(0,i.jsx)(t.br,{}),"\n","Source: ",(0,i.jsx)(t.a,{href:"https://www.geeksforgeeks.org/introduction-to-circular-queue/",children:"https://www.geeksforgeeks.org/introduction-to-circular-queue/"})]}),"\n",(0,i.jsx)(t.p,{children:"The circular nature of circular queue enables continuous enqueue and dequeue operations. When we ran out of space in the queue (when rear pointer touch front pointer), the enqueue operation will overwrite anything in the front of the queue. This is useful for scenario where we need to store data in a queue-like structure, but we don't want it to take up to many spaces, so that we will overwrite the oldest data."}),"\n",(0,i.jsx)(t.h3,{id:"priority-queue",children:"Priority Queue"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Priority Queue"})," is a data structure that stores a collection of elements, each associated with a priority value (e.g., larger number have larger priority). Unlike a regular queue, where elements are processed in a first-in-first-out (FIFO) manner, a priority queue retrieves elements based on their priority."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"Priority queue",src:r(31429).A+"",width:"600",height:"291"}),(0,i.jsx)(t.br,{}),"\n","Source: ",(0,i.jsx)(t.a,{href:"https://www.javatpoint.com/ds-priority-queue",children:"https://www.javatpoint.com/ds-priority-queue"})]}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["Priority queue is conceptually different with ",(0,i.jsx)(t.a,{href:"/data-structures-and-algorithms/heap",children:"heap"}),", a priority queue is just a concept where each element has some priority. Heap is often used to implement a priority queue, it is a specific implementation of priority queue using ",(0,i.jsx)(t.a,{href:"/data-structures-and-algorithms/tree#binary-tree",children:"binary tree"}),"."]})})]})}function c(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},99602:(e,t,r)=>{r.d(t,{A:()=>n});const n=r.p+"assets/images/circular-queue-3fd9bdaadecad93a76d2410c63d931d1.png"}}]);