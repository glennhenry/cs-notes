"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[2750],{3905:(t,e,r)=>{r.d(e,{Zo:()=>u,kt:()=>k});var a=r(67294);function n(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function i(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,a)}return r}function o(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?i(Object(r),!0).forEach((function(e){n(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function s(t,e){if(null==t)return{};var r,a,n=function(t,e){if(null==t)return{};var r,a,n={},i=Object.keys(t);for(a=0;a<i.length;a++)r=i[a],e.indexOf(r)>=0||(n[r]=t[r]);return n}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(a=0;a<i.length;a++)r=i[a],e.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(t,r)&&(n[r]=t[r])}return n}var c=a.createContext({}),l=function(t){var e=a.useContext(c),r=e;return t&&(r="function"==typeof t?t(e):o(o({},e),t)),r},u=function(t){var e=l(t.components);return a.createElement(c.Provider,{value:e},t.children)},p="mdxType",d={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},g=a.forwardRef((function(t,e){var r=t.components,n=t.mdxType,i=t.originalType,c=t.parentName,u=s(t,["components","mdxType","originalType","parentName"]),p=l(r),g=n,k=p["".concat(c,".").concat(g)]||p[g]||d[g]||i;return r?a.createElement(k,o(o({ref:e},u),{},{components:r})):a.createElement(k,o({ref:e},u))}));function k(t,e){var r=arguments,n=e&&e.mdxType;if("string"==typeof t||n){var i=r.length,o=new Array(i);o[0]=g;var s={};for(var c in e)hasOwnProperty.call(e,c)&&(s[c]=e[c]);s.originalType=t,s[p]="string"==typeof t?t:n,o[1]=s;for(var l=2;l<i;l++)o[l]=r[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,r)}g.displayName="MDXCreateElement"},21502:(t,e,r)=>{r.r(e),r.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var a=r(87462),n=(r(67294),r(3905));const i={slug:"/data-structures-and-algorithms/backtracking",id:"backtracking",title:"Backtracking",description:"Backtracking"},o=void 0,s={unversionedId:"data-structures-and-algorithms/backtracking/backtracking",id:"data-structures-and-algorithms/backtracking/backtracking",title:"Backtracking",description:"Backtracking",source:"@site/docs/data-structures-and-algorithms/17-backtracking/backtracking.md",sourceDirName:"data-structures-and-algorithms/17-backtracking",slug:"/data-structures-and-algorithms/backtracking",permalink:"/cs-notes/data-structures-and-algorithms/backtracking",draft:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/data-structures-and-algorithms/17-backtracking/backtracking.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1700814284,formattedLastUpdatedAt:"Nov 24, 2023",frontMatter:{slug:"/data-structures-and-algorithms/backtracking",id:"backtracking",title:"Backtracking",description:"Backtracking"},sidebar:"sidebar",previous:{title:"Traversal",permalink:"/cs-notes/data-structures-and-algorithms/traversal"},next:{title:"Greedy",permalink:"/cs-notes/data-structures-and-algorithms/greedy"}},c={},l=[{value:"Backtracking vs Brute Force",id:"backtracking-vs-brute-force",level:3},{value:"Solving Maze",id:"solving-maze",level:3}],u={toc:l},p="wrapper";function d(t){let{components:e,...i}=t;return(0,n.kt)(p,(0,a.Z)({},u,i,{components:e,mdxType:"MDXLayout"}),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Main Source :")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},(0,n.kt)("a",{parentName:"strong",href:"https://en.wikipedia.org/wiki/Backtracking"},"Backtracking - Wikipedia")))),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Backtracking")," is algorithmic technique that involves doing certain steps then undoing that steps if it turns out to be incorrect. It is commonly used in a complex problem that require you to adhere to specific constraint. For example, solving a Sudoku puzzle involves constraints such as filling in all empty cells with unique numbers in each row and column."),(0,n.kt)("p",null,"Backtracking explores all possible solution by trying out different choices at each step. When it does a certain step, it checks if the step we took is valid according to the constraints. If it is valid, we will continue with that step, else, we will undo that step and try out different choice. The behavior of backtracking algorithms makes it result in a high time complexity (e.g., polynomial, factorial, or even higher)."),(0,n.kt)("p",null,"Backtracking typically uses ",(0,n.kt)("a",{parentName:"p",href:"/data-structures-and-algorithms/recursion"},"recursion")," and traverse the possible solution in ",(0,n.kt)("a",{parentName:"p",href:"/data-structures-and-algorithms/traversal#depth-first-search-dfs"},"depth-first manner"),". The space complexity of backtracking algorithms can also be significant, especially when the depth of the search tree is large."),(0,n.kt)("h3",{id:"backtracking-vs-brute-force"},"Backtracking vs Brute Force"),(0,n.kt)("p",null,"Backtracking approach in solving problem differ with the ",(0,n.kt)("a",{parentName:"p",href:"/computer-and-programming-fundamentals/computer-and-programming-terminology"},"brute force")," approach. In brute force, we mindlessly try all possible combination. In the case of solving Sudoku, we would fill out all the cell with number 1, and then try again with one cell being number 2, and so on."),(0,n.kt)("p",null,"On the other hand, backtracking takes into account problem constraints and uses them to efficiently explore the solution space. In the case of solving Sudoku, we would add a constraint such as, not using numbers that are already used in the same grid. Backtracking also involve undoing some steps, instead of starting from zero, we would undo the invalid step and continue from there. This additional characteristics make backtracking faster than a typical brute force solution."),(0,n.kt)("h3",{id:"solving-maze"},"Solving Maze"),(0,n.kt)("p",null,"Consider a maze with some wall obstacle in it."),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Solving maze",src:r(58503).Z,width:"984",height:"520"}),(0,n.kt)("br",{parentName:"p"}),"\n","Source : ",(0,n.kt)("a",{parentName:"p",href:"https://brilliant.org/wiki/depth-first-search-dfs/"},"https://brilliant.org/wiki/depth-first-search-dfs/")),(0,n.kt)("p",null,"A pseudocode to solve it using backtracking :"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"function solve(row, col):\n    if (row, col) is the goal:\n        return true\n\n    if (row, col) is a valid position in the maze and not a wall:\n        Mark (row, col) as part of the solution\n\n        // Try moving in all possible directions: up, down, left, right\n        if solveMaze(row - 1, col) is true:   // Try moving up\n            return true\n        if solveMaze(row + 1, col) is true:   // Try moving down\n            return true\n        if solveMaze(row, col - 1) is true:   // Try moving left\n            return true\n        if solveMaze(row, col + 1) is true:   // Try moving right\n            return true\n\n        // If none of the directions lead to the goal, backtrack and mark the cell as invalid\n        Mark (row, col) as not part of the solution\n        return false\n\n    return false\n\n// Start solving the maze from the top-left corner (0, 0)\nsolveMaze(0, 0)\n")),(0,n.kt)("p",null,"This backtracking solution uses depth-first search (DFS) to traverse the maze. The constraint is quite simple, basically we must navigate to the exit while avoiding wall obstacles."))}d.isMDXComponent=!0},58503:(t,e,r)=>{r.d(e,{Z:()=>a});const a=r.p+"assets/images/maze-solve-54efd184bb285fcf7183af37f756b075.gif"}}]);