"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[5857],{3905:(e,a,t)=>{t.d(a,{Zo:()=>l,kt:()=>u});var n=t(67294);function s(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function r(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach((function(a){s(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function m(e,a){if(null==e)return{};var t,n,s=function(e,a){if(null==e)return{};var t,n,s={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||(s[t]=e[t]);return s}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var p=n.createContext({}),o=function(e){var a=n.useContext(p),t=a;return e&&(t="function"==typeof e?e(a):r(r({},a),e)),t},l=function(e){var a=o(e.components);return n.createElement(p.Provider,{value:a},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},h=n.forwardRef((function(e,a){var t=e.components,s=e.mdxType,i=e.originalType,p=e.parentName,l=m(e,["components","mdxType","originalType","parentName"]),d=o(t),h=s,u=d["".concat(p,".").concat(h)]||d[h]||c[h]||i;return t?n.createElement(u,r(r({ref:a},l),{},{components:t})):n.createElement(u,r({ref:a},l))}));function u(e,a){var t=arguments,s=a&&a.mdxType;if("string"==typeof e||s){var i=t.length,r=new Array(i);r[0]=h;var m={};for(var p in a)hasOwnProperty.call(a,p)&&(m[p]=a[p]);m.originalType=e,m[d]="string"==typeof e?e:s,r[1]=m;for(var o=2;o<i;o++)r[o]=t[o];return n.createElement.apply(null,r)}return n.createElement.apply(null,t)}h.displayName="MDXCreateElement"},44454:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>p,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>m,toc:()=>o});var n=t(87462),s=(t(67294),t(3905));const i={slug:"/deep-learning/diffusion/diffusion-model",id:"diffusion-model",title:"Diffusion Model",description:"Diffusion Model"},r=void 0,m={unversionedId:"deep-learning/diffusion/diffusion-model/diffusion-model",id:"deep-learning/diffusion/diffusion-model/diffusion-model",title:"Diffusion Model",description:"Diffusion Model",source:"@site/docs/deep-learning/15-diffusion/01-diffusion-model/diffusion-model.md",sourceDirName:"deep-learning/15-diffusion/01-diffusion-model",slug:"/deep-learning/diffusion/diffusion-model",permalink:"/cs-notes/deep-learning/diffusion/diffusion-model",draft:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/deep-learning/15-diffusion/01-diffusion-model/diffusion-model.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1697368199,formattedLastUpdatedAt:"Oct 15, 2023",frontMatter:{slug:"/deep-learning/diffusion/diffusion-model",id:"diffusion-model",title:"Diffusion Model",description:"Diffusion Model"},sidebar:"sidebar",previous:{title:"Vision Transformers",permalink:"/cs-notes/deep-learning/transformers/vision-transformers"},next:{title:"Stable Diffusion",permalink:"/cs-notes/deep-learning/diffusion/stable-diffusion"}},p={},o=[{value:"Denoising Diffusion Model",id:"denoising-diffusion-model",level:2},{value:"Denoising Diffusion Probabilistic Model (DDPM)",id:"denoising-diffusion-probabilistic-model-ddpm",level:3},{value:"Forward Process",id:"forward-process",level:4},{value:"Reverse Process",id:"reverse-process",level:4},{value:"Training Objective",id:"training-objective",level:4},{value:"Denoising Diffusion Implicit Models (DDIM)",id:"denoising-diffusion-implicit-models-ddim",level:3},{value:"Conditional &amp; Unconditional Generation",id:"conditional--unconditional-generation",level:3},{value:"Score-Based Diffusion Model",id:"score-based-diffusion-model",level:2},{value:"Latent Diffusion Model (LDM)",id:"latent-diffusion-model-ldm",level:2}],l={toc:o},d="wrapper";function c(e){let{components:a,...i}=e;return(0,s.kt)(d,(0,n.Z)({},l,i,{components:a,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Main Source :")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},(0,s.kt)("a",{parentName:"strong",href:"https://en.wikipedia.org/wiki/Diffusion_model"},"Wikipedia Diffusion model"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},(0,s.kt)("a",{parentName:"strong",href:"https://youtu.be/fbLgFrlTnGU?si=tR6le4piBvVpeR_9"},"What are Diffusion Models? - Ari Seff"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},(0,s.kt)("a",{parentName:"strong",href:"https://www.assemblyai.com/blog/diffusion-models-for-machine-learning-introduction/"},"Introduction to Diffusion Models for Machine Learning - AssemblyAI")))),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Diffusion Model")," is a class of generative model, meaning it generates new data by learning the distribution of given dataset and then sample it. Diffusion model is typically used for tasks including image generation, image denoising, generating high-resolution image, and etc."),(0,s.kt)("p",null,"Diffusion model is inspired by the concept of ",(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Diffusion"},"diffusion")," in physics, which is a stochastic phenomenon where particles spread out from an area of high concentration to an area of low concentration, eventually leading to a uniform distribution. The underlying principles and equations of diffusion in physics provide a mathematical foundation that is adapted and applied to model to generates data."),(0,s.kt)("p",null,"The idea of diffusion model is, we model the target image (the target image we want to generate) as a data distribution (called target distribution), and then the model will aim to transform a simple base distribution, typically a Gaussian distribution, into the target distribution through an iterative diffusion process."),(0,s.kt)("video",{width:"720",height:"360",controls:!0},(0,s.kt)("source",{src:"https://learnopencv.com/wp-content/uploads/2023/02/denoising-diffusion-probabilistic-models_flower_inference_2.mp4",type:"video/mp4"})),(0,s.kt)("p",null,"Source : ",(0,s.kt)("a",{parentName:"p",href:"https://learnopencv.com/denoising-diffusion-probabilistic-models/"},"https://learnopencv.com/denoising-diffusion-probabilistic-models/")),(0,s.kt)("h2",{id:"denoising-diffusion-model"},"Denoising Diffusion Model"),(0,s.kt)("p",null,"There are many variation of diffusion model, each with their own concept, ",(0,s.kt)("strong",{parentName:"p"},"Denoising Diffusion Model")," is the type of diffusion model that uses the diffusion concept."),(0,s.kt)("h3",{id:"denoising-diffusion-probabilistic-model-ddpm"},"Denoising Diffusion Probabilistic Model (DDPM)"),(0,s.kt)("p",null,"Diffusion model consist of two steps, the forward process that gradually add noise to the image, and the reverse process that tries to reverse the process or remove the noise to generate clean samples."),(0,s.kt)("h4",{id:"forward-process"},"Forward Process"),(0,s.kt)("p",null,"In Diffusion model, the noising process is modeled using a ",(0,s.kt)("a",{parentName:"p",href:"/machine-learning/reinforcement-learning/markov-models#markov-chain"},(0,s.kt)("strong",{parentName:"a"},"Markov chain")),". Markov chain is a mathematical model that assumes the future state of a system only depends on current step. In other word, current step depends only on the previous step. The key idea behind using a Markov chain in diffusion models is to describe the evolution of the system's state as a stochastic process."),(0,s.kt)("p",null,"We will add noise to the image gradually, the process will be divided into discrete time steps. Connecting the Markov chain with diffusion model, the distribution of noise at some time step ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"t")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"t")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6151em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"t")))))," only depends on previous time step ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"t"),(0,s.kt)("mo",{parentName:"mrow"},"\u2212"),(0,s.kt)("mn",{parentName:"mrow"},"1")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"t-1")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6984em",verticalAlign:"-0.0833em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.kt)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"1"))))),". Following the calculation in Markov chain, current step distribution will be calculated by the product of each previously conditional step."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Forward process notation",src:t(40666).Z,width:"370",height:"250"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://youtu.be/fbLgFrlTnGU?si=tR6le4piBvVpeR_9&t=109"},"https://youtu.be/fbLgFrlTnGU?si=tR6le4piBvVpeR_9&t=109")),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"The forward process is fixed, doesn't have learnable parameters.")),(0,s.kt)("p",null,"The noise of the image will be modeled using a ",(0,s.kt)("strong",{parentName:"p"},"Gaussian (normal) distribution"),". A Gaussian distribution is characterized by its mean (",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"\u03bc")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mu")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"\u03bc"))))),") and variance (",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("msup",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msup"},"\u03c3"),(0,s.kt)("mn",{parentName:"msup"},"2"))),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\sigma^2")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8141em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"\u03c3"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))))))),"), which determine the central tendency and spread of the distribution, respectively."),(0,s.kt)("p",null,"In the context of diffusion model, the type of Gaussian distribution used is the ",(0,s.kt)("strong",{parentName:"p"},"diagonal Gaussian distribution"),". The variance, denoted as ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"\u03b2")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\beta")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05278em"}},"\u03b2"))))),", varies at each time step and is constrained to be within the range of 0 and 1. The lower variance implies that the diffusion or transformation of the distribution occurs more gradually and with smaller perturbations, which may help us on the reverse process."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Gaussian distribution",src:t(43753).Z,width:"490",height:"103"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://youtu.be/fbLgFrlTnGU?si=mN1d8DKDP9vYJjQ0&t=129"},"https://youtu.be/fbLgFrlTnGU?si=mN1d8DKDP9vYJjQ0&t=129")),(0,s.kt)("p",null,"As we repeatedly apply the forward diffusion process, mathematically speaking, the covariance matrix will tend to become more and more like an identity matrix. In other word, the injected noise will become less correlated or becomes more random and less predictable. The overall distribution of noise becomes more uniform."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Getting closer to identity matrix",src:t(71216).Z,width:"471",height:"192"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://youtu.be/fbLgFrlTnGU?si=C8gzMh3VVKSUXqBg&t=163"},"https://youtu.be/fbLgFrlTnGU?si=C8gzMh3VVKSUXqBg&t=163")),(0,s.kt)("h4",{id:"reverse-process"},"Reverse Process"),(0,s.kt)("p",null,"The reverse process will also be modeled using Markov chain, the noise will be assumed as a ",(0,s.kt)("strong",{parentName:"p"},"unimodal diagonal Gaussian distribution")," (the formula above in the image), which takes current state (",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("msub",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msub"},"x"),(0,s.kt)("mi",{parentName:"msub"},"t"))),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x_t")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.5806em",verticalAlign:"-0.15em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.2806em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"t")))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,s.kt)("span",{parentName:"span"})))))))))),") and current time step (",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"t")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"t")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6151em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"))))),") as input."),(0,s.kt)("p",null,"In the reverse process of a diffusion model, the calculation involves inferring the previous step given the current step. This is done by applying the conditional distributions at each time step in reverse order and multiplying them with the Gaussian noise distribution, denoted as ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"p"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("msub",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msub"},"x"),(0,s.kt)("mi",{parentName:"msub"},"T")),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"p(x_T)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3283em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.13889em"}},"T")))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,s.kt)("span",{parentName:"span"})))))),(0,s.kt)("span",{parentName:"span",className:"mclose"},")"))))),", which was generated during the forward process. By gradually decreasing the noise, we successfully generated new samples. The inference process is where the process is made learnable or adjustable."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Reverse process notation",src:t(18178).Z,width:"462",height:"340"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://youtu.be/fbLgFrlTnGU?si=v6ixlxk-gmWiHtDW&t=279"},"https://youtu.be/fbLgFrlTnGU?si=v6ixlxk-gmWiHtDW&t=279")),(0,s.kt)("p",null,"In the implementation of reverse process, there are two parameters, the mean (",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"\u03bc")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mu")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"\u03bc"))))),") and the variance ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u03a3")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\Sigma")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6833em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"\u03a3")))))," of the Gaussian distribution. The variance is made fixed and only the mean is made learnable, to stabilize the learning process."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Reverse process implementation",src:t(34532).Z,width:"524",height:"110"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://youtu.be/fbLgFrlTnGU?si=o0xlAFVkGm6B4nHr&t=651"},"https://youtu.be/fbLgFrlTnGU?si=o0xlAFVkGm6B4nHr&t=651")),(0,s.kt)("h4",{id:"training-objective"},"Training Objective"),(0,s.kt)("p",null,"The forward and reverse process can be understood as process that transform data or distribution (the input image) in two different directions. The forward process involves adding noise that will make the data distribution approach uniform distribution, which help to simplify complex data. The reverse process involves transforming the data back to its original distribution. This is done by approximating the unnoised data, by doing this, we effectively generate new data points during this process."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"The objective of diffusion model",src:t(46722).Z,width:"283",height:"291"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://youtu.be/fbLgFrlTnGU?si=lOk5eb9Au4EJumjW&t=376"},"https://youtu.be/fbLgFrlTnGU?si=lOk5eb9Au4EJumjW&t=376")," (with modification)"),(0,s.kt)("p",null,"The process and objective of diffusion model is similar to ",(0,s.kt)("a",{parentName:"p",href:"/deep-learning/variational-autoencoder"},(0,s.kt)("strong",{parentName:"a"},"variational autoencoder (VAE)")),". In VAE, the encoder takes the input data and maps it to a lower-dimensional representation called the ",(0,s.kt)("strong",{parentName:"p"},"latent space"),". This latent space serves as a compressed representation that captures the essential information and underlying structure present in the input data. The decoder takes the latent space and sample from it, to generate new data samples. The objective is to approximate the true data distribution from the sampled distribution."),(0,s.kt)("p",null,'The similar objective can be applied to diffusion model, "Given transformed data, how to untransform it?". The primary aim of a diffusion model is to enhance the inference process, particularly by focusing on the reverse process that involves computing the preceding state of the Markov chain.'),(0,s.kt)("p",null,"The training objective can be summarized with the following formula :"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Training objective formula",src:t(25423).Z,width:"795",height:"57"}),(0,s.kt)("br",{parentName:"p"}),"\n","Source : ",(0,s.kt)("a",{parentName:"p",href:"https://youtu.be/fbLgFrlTnGU?si=D6pH6EyDnxSz0j1P&t=458"},"https://youtu.be/fbLgFrlTnGU?si=D6pH6EyDnxSz0j1P&t=458")," (with modification)"),(0,s.kt)("p",null,"The ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"log"),(0,s.kt)("mo",{parentName:"mrow"},"\u2061"),(0,s.kt)("msub",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msub"},"p"),(0,s.kt)("mi",{parentName:"msub"},"\u03b8")),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mi",{parentName:"mrow"},"x"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\log p_{\\theta}(x)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mop"},"lo",(0,s.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3361em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.02778em"}},"\u03b8"))))),(0,s.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,s.kt)("span",{parentName:"span"})))))),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.kt)("span",{parentName:"span",className:"mclose"},")")))))," represent the likelihood of the original data, it must be greater or equal to the first term subtracted by second term. The first term is the ",(0,s.kt)("strong",{parentName:"p"},"reconstruction term"),", which is the comparison of generated data and the original data. The second term is the ",(0,s.kt)("strong",{parentName:"p"},"KL divergence")," measures the difference of probability distribution between the target distribution (input data) and the learned distribution (generated distribuion)."),(0,s.kt)("h3",{id:"denoising-diffusion-implicit-models-ddim"},"Denoising Diffusion Implicit Models (DDIM)"),(0,s.kt)("p",null,"The type of denoising diffusion model previously we talked about uses the probabilistic Markov chain as the framework. However, it is slow.... instead DDIM use denoiser..."),(0,s.kt)("h3",{id:"conditional--unconditional-generation"},"Conditional & Unconditional Generation"),(0,s.kt)("p",null,"abcdef"),(0,s.kt)("h2",{id:"score-based-diffusion-model"},"Score-Based Diffusion Model"),(0,s.kt)("p",null,"uses score function"),(0,s.kt)("h2",{id:"latent-diffusion-model-ldm"},"Latent Diffusion Model (LDM)"),(0,s.kt)("p",null,"uses ",(0,s.kt)("a",{parentName:"p",href:"/deep-learning/variational-autoencoder"},"variational autoencoder (VAE)")),(0,s.kt)("hr",null),(0,s.kt)("p",null,"The entire diffusion topics is based on the fast.ai part 2 course, with addition from other sources."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},(0,s.kt)("a",{parentName:"strong",href:"https://course.fast.ai/Lessons/part2.html"},"fast.ai Part 2 course")))),(0,s.kt)("p",null,"this note should include the general principle of how diffusion model works, the next notes should explain it in more detailed along with the explanation about the method and technique used."),(0,s.kt)("p",null,"what to explain in diffusion :"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Diffusion method"),(0,s.kt)("li",{parentName:"ul"},"Denoising Diffusion Probabilistic Models (DDPM)"),(0,s.kt)("li",{parentName:"ul"},"Denoising Diffusion Implicit Models (DDIM)"),(0,s.kt)("li",{parentName:"ul"},"conditional and unconditional diffusion"),(0,s.kt)("li",{parentName:"ul"},"sampler"),(0,s.kt)("li",{parentName:"ul"},"CLIP"),(0,s.kt)("li",{parentName:"ul"},"a"),(0,s.kt)("li",{parentName:"ul"},"b"),(0,s.kt)("li",{parentName:"ul"},"c\nthe last 3: stable diffusion, dall-e, and midjourney will explain what diffusion model technique they specifically uses, it can be thought as the application of diffusion model."),(0,s.kt)("li",{parentName:"ul"},"stable diffusion"),(0,s.kt)("li",{parentName:"ul"},"dall-e"),(0,s.kt)("li",{parentName:"ul"},"midjourney")))}c.isMDXComponent=!0},71216:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/approach-identity-matrix-2336ab708059a75b31a755e0dad9c4f5.png"},40666:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/forward-process-notation-508aafbe19bb9f1418392575f213a423.png"},43753:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/gaussian-distribution-9569cf4b790dadd74f4101bcfe2bae0b.png"},46722:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/objective-57e94625624526004f3b851095df306f.png"},34532:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/reverse-process-implementation-c4884f9c757dba8b0d036e36237361c9.png"},18178:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/reverse-process-notation-fa196f341c9afbfd2b8202827e0b3ec0.png"},25423:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/training-formula-17beda6f8e60e6a73cc78b5ecc67d695.png"}}]);