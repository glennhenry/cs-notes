"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[7542],{62991:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>h});var t=n(85893),r=n(11151);const i={slug:"/operating-system/inter-process-communication",id:"inter-process-communication",title:"Inter-process Communication",description:"Inter-process Communication"},o=void 0,a={id:"operating-system/inter-process-communication/inter-process-communication",title:"Inter-process Communication",description:"Inter-process Communication",source:"@site/docs/operating-system/08-inter-process-communication/inter-process-communication.md",sourceDirName:"operating-system/08-inter-process-communication",slug:"/operating-system/inter-process-communication",permalink:"/cs-notes/operating-system/inter-process-communication",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/operating-system/08-inter-process-communication/inter-process-communication.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1712660846,formattedLastUpdatedAt:"Apr 9, 2024",frontMatter:{slug:"/operating-system/inter-process-communication",id:"inter-process-communication",title:"Inter-process Communication",description:"Inter-process Communication"},sidebar:"sidebar",previous:{title:"System Call",permalink:"/cs-notes/operating-system/system-call"},next:{title:"Memory Management",permalink:"/cs-notes/operating-system/memory-management"}},c={},h=[{value:"IPC Mechanism",id:"ipc-mechanism",level:3},{value:"Shared Memory",id:"shared-memory",level:4},{value:"Message Passing",id:"message-passing",level:4},{value:"RPC",id:"rpc",level:3}];function m(e){const s={a:"a",admonition:"admonition",br:"br",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Main Source :"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Inter-process_communication",children:"Inter-process communication - Wikipedia"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.a,{href:"https://www.linkedin.com/pulse/interprocess-communicationipc-using-shared-memory-pratik-parvati",children:"Interprocess communication(IPC) using shared memory by Pratik Parvati - Linkedin blog"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Remote_procedure_call",children:"Remote procedure call - Wikipedia"})})}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Inter-process Communication (IPC)"})," is the mechanism used to communicate between processes."]}),"\n",(0,t.jsx)(s.p,{children:"Processes are isolated from one another, meaning they cannot directly access each other's memory. This isolation ensures that one process cannot corrupt or interfere with the resources of another process."}),"\n",(0,t.jsxs)(s.p,{children:["IPC enables processes to share data and coordinate actions in a controlled manner. IPC uses ",(0,t.jsx)(s.a,{href:"/operating-system/multithreading#synchronization-primitives",children:"various synchronization primitives"})," to avoid conflicts and ensure proper sequencing of operations."]}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsx)(s.p,{children:"Although they are for process communication, it may be used to communicate between thread if they are running in separate processes. If threads were to communicate between the same process, typically they would directly access and communicate with each other through shared variables or data structures."})}),"\n",(0,t.jsx)(s.h3,{id:"ipc-mechanism",children:"IPC Mechanism"}),"\n",(0,t.jsx)(s.p,{children:"There are two main technique to communicate, by utilizing shared memory, or passing messages."}),"\n",(0,t.jsx)(s.h4,{id:"shared-memory",children:"Shared Memory"}),"\n",(0,t.jsxs)(s.p,{children:["In ",(0,t.jsx)(s.strong,{children:"shared memory"}),", a portion of memory is allocated and made accessible to multiple processes for read and write. However, this communication mechanism may require ",(0,t.jsx)(s.a,{href:"/operating-system/multithreading#thread-synchronization",children:"additional synchronization technique"})," to prevent ",(0,t.jsx)(s.a,{href:"/operating-system/multithreading#multithreading-problems",children:"concurrency issues"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["Sharing memory is possible through ",(0,t.jsx)(s.a,{href:"/operating-system/memory-management#virtual-addressing",children:"virtual memory mapping"}),". When a process is created, they are given some memory addresses space, which is the region of memory they have access to read/write. Behind the scene, the memory is not an actual physical memory, they are just some range of addresses that maps to the actual memory, which is called ",(0,t.jsx)(s.strong,{children:"virtual memory address"}),". When the process accesses the virtual memory space, the OS will translate the memory they are referring to the actual memory address located in the physical memory."]}),"\n",(0,t.jsx)(s.p,{children:'For example, when a process want to access some data in the address "0x05", the actual data located on the physical memory may not be in that address. It could exist on address "0x08", or "0xFF", or any other address. This is why the memory address is called virtual, because the process treat the memory as if it\'s their own memory, but it is not.'}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.img,{alt:"Virtual memory",src:n(99865).Z+"",width:"250",height:"395"}),(0,t.jsx)(s.br,{}),"\n","Source : ",(0,t.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Virtual_memory",children:"https://en.wikipedia.org/wiki/Virtual_memory"})]}),"\n",(0,t.jsx)(s.p,{children:"The same concept applies for shared memory, where there are several processes each with their own isolated virtual memory. When a process want to share memory, the OS will allocate some shared memory somewhere. After that, the process will attach to it, meaning the process will be given some range of address on their virtual address that it can use to access the shared data. Essentially, the OS maps the shared memory to the virtual memory owned by the process."}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.img,{alt:"Shared memory",src:n(73942).Z+"",width:"751",height:"352"}),(0,t.jsx)(s.br,{}),"\n","Source : ",(0,t.jsx)(s.a,{href:"https://www.linkedin.com/pulse/interprocess-communicationipc-using-shared-memory-pratik-parvati",children:"https://www.linkedin.com/pulse/interprocess-communicationipc-using-shared-memory-pratik-parvati"})]}),"\n",(0,t.jsx)(s.p,{children:'The shared memory is located in a single place somewhere in the physical memory, but each process access it as if it\'s located on their memory space. For example, process A may own its shared memory in the address "0x60000" to "0x80000", while the process B own its shared memory in address "0x70000" to "0x90000".'}),"\n",(0,t.jsx)(s.p,{children:"After all the mapping, the process can now read/write to the shared memory as usual."}),"\n",(0,t.jsx)(s.h4,{id:"message-passing",children:"Message Passing"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Message Passing"}),' is an act of communication between processes or thread without using shared memory, it is inherently associated with "message".']}),"\n",(0,t.jsx)(s.p,{children:"Message passing can be synchronous or asynchronous. In the synchronous model, the sender process blocks until the message is received by the recipient process. In the asynchronous model, the sender process continues execution immediately after sending the message, without waiting for a response from the recipient. The recipient process can receive the message at a later time."}),"\n",(0,t.jsx)(s.p,{children:"Some example of message passing :"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Pipes"})," : Pipes are a form of ",(0,t.jsx)(s.a,{href:"/operating-system/inter-process-communication",children:"inter-process communication (IPC)"})," that allows the output of one process to be used as the input of another process. In a pipe, data flows in a unidirectional manner from the writer process to the reader process. Pipes can be either named or unnamed, with unnamed pipes typically used for communication between related processes (e.g., parent-child processes)."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Sockets"})," : Sockets are a communication endpoint that enables bidirectional communication between processes over a network. They can be used for IPC within the same machine (domain sockets) or across different machines (network sockets)."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.a,{href:"/backend-development/message-broker",children:"Message Queues"})})," : Message queues is where processes exchange messages through a shared ",(0,t.jsx)(s.a,{href:"/data-structures-and-algorithms/queue",children:"queue"})," in the operating system. Each message has a specific format and is placed into the queue by the sending process. The receiving process can then retrieve messages from the queue in a first-in-first-out (FIFO) order."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Channels"})," : Channels is a higher-level concept for message passing. Channels typically provide a set of operations, such as sending and receiving messages, and may incorporate synchronization mechanisms like blocking or non-blocking operations. Channels can be implemented using various underlying mechanisms, including shared memory, pipes, or sockets."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.img,{alt:"Message passing",src:n(79503).Z+"",width:"379",height:"205"}),(0,t.jsx)(s.br,{}),"\n","Source : ",(0,t.jsx)(s.a,{href:"https://beingintelligent.com/difference-between-shared-memory-and-message-passing-process-communication.html",children:"https://beingintelligent.com/difference-between-shared-memory-and-message-passing-process-communication.html"})]}),"\n",(0,t.jsx)(s.h3,{id:"rpc",children:"RPC"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Remote Procedure Call (RPC)"})," is an IPC that specifically facilitates communication between processes or programs running on different computers or networked systems. RPC typically used for system that adopts the client-server architecture. It is an architecture where exist a client, someone who request something, and the server, the entity that respond to the request."]}),"\n",(0,t.jsx)(s.p,{children:"The primary purpose of RPC is to request a server to execute a particular instruction for you. In RPC, when you make a request, you would send a message containing a procedure or function including its parameter to the server. The server will receive the message and will execute the procedure. After that, the server will send back the result to us."}),"\n",(0,t.jsx)(s.p,{children:"The server will know how to execute the procedure through a defined interface. The client specifies the available procedures or functions that the client can invoke on the server. The interface defines the method signatures, input parameters, and return types of these procedures."}),"\n",(0,t.jsxs)(s.p,{children:["The difference between RPC with ",(0,t.jsx)(s.a,{href:"/computer-networking/http-https",children:"HTTP requests"})," is, HTTP is a general communication protocol, while RPC is a specific communication that lets you execute a procedure and get its result back from a server. In fact, RPC can use HTTP protocol under the hood. RPC is typically used in distributed computing, it enables applications to run something on remote systems as if it's running on user's machine."]}),"\n",(0,t.jsx)(s.admonition,{type:"tip",children:(0,t.jsxs)(s.p,{children:["See also ",(0,t.jsx)(s.a,{href:"/backend-development/rpc",children:"RPC"})]})})]})}function d(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},79503:(e,s,n)=>{n.d(s,{Z:()=>t});const t=n.p+"assets/images/message-passing-2aa51aaf5dd6d447bf1a3f5185fc2d9e.png"},73942:(e,s,n)=>{n.d(s,{Z:()=>t});const t=n.p+"assets/images/shared-memory-a3d9259b9113403da5b30c81a6ac5778.png"},99865:(e,s,n)=>{n.d(s,{Z:()=>t});const t=n.p+"assets/images/virtual-memory-1017d602d84e88174b3904422a75eafa.png"},11151:(e,s,n)=>{n.d(s,{Z:()=>a,a:()=>o});var t=n(67294);const r={},i=t.createContext(r);function o(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);