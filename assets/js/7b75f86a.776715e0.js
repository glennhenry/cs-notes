"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[809],{78237:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var i=t(85893),r=t(11151);const o={slug:"/backend-development/rpc",id:"rpc",title:"RPC",description:"RPC"},s=void 0,a={id:"backend-development/rpc/rpc",title:"RPC",description:"RPC",source:"@site/docs/backend-development/06-rpc/rpc.md",sourceDirName:"backend-development/06-rpc",slug:"/backend-development/rpc",permalink:"/cs-notes/backend-development/rpc",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/backend-development/06-rpc/rpc.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1706968494,formattedLastUpdatedAt:"Feb 3, 2024",frontMatter:{slug:"/backend-development/rpc",id:"rpc",title:"RPC",description:"RPC"},sidebar:"sidebar",previous:{title:"GraphQL",permalink:"/cs-notes/backend-development/graphql"},next:{title:"Webhook",permalink:"/cs-notes/backend-development/webhook"}},c={},l=[{value:"RPC",id:"rpc",level:3},{value:"RPC Process",id:"rpc-process",level:4},{value:"gRPC",id:"grpc",level:3},{value:"Protocol Buffers",id:"protocol-buffers",level:4}];function d(e){const n={a:"a",br:"br",code:"code",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Main Source :"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://youtu.be/MdaGuP6-bKs?si=dG0FRHjE415_s9no",children:"What is RPC? - Valentin Despa"})})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://youtu.be/gnchfOojMk4?si=JaNEHWB8mTH6j4ot",children:"What is RPC? gRPC Introduction - ByteByteGo"})})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"rpc",children:"RPC"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Remote Procedure Call (RPC)"})," is a communication protocol that allows a computer program to run procedule on a remote server. By procedure, it is a sequence of instruction that such as codes, it will be executed as if it were a local function call."]}),"\n",(0,i.jsx)(n.p,{children:"Function invocation can be achieved through a contract called IDL (Interface Definition Language) or a schema definition. This definition is used to specify which function or procedures that can be called remotely. The IDL is designed to be language-agnostic, this mean even if the client requested a function call on a server that uses different programming language, the server still know what to do."}),"\n",(0,i.jsx)(n.h4,{id:"rpc-process",children:"RPC Process"}),"\n",(0,i.jsx)(n.p,{children:"The RPC framework will generate language-specific code for the client and the server to use to communicate. The function or procedure used may also include argument to pass additional data."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Serialization"})," : Serialization is the process of transforming data into something that can be transmitted over the network. The RPC framework will generate code following the IDL definition and will serialize the code into format like ",(0,i.jsx)(n.a,{href:"/frontend-web-development/json",children:"JSON"}),", ",(0,i.jsx)(n.a,{href:"/digital-media-processing/xml",children:"XML"}),", or Protocol Buffers. The generated code is called ",(0,i.jsx)(n.strong,{children:"client stub"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The serialized request will be transmitted over the network using protocol like ",(0,i.jsx)(n.a,{href:"/computer-networking/tcp-protocol",children:"TCP"})," or ",(0,i.jsx)(n.a,{href:"/computer-networking/udp",children:"UDP"})," and the server will receive it."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Deserialization"})," : The RPC framework in the server will deserialize the data received and transform it into the language the server use, this is called ",(0,i.jsx)(n.strong,{children:"stub decoding"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Execution & Responses"})," : The server will execute the function with its parameters and will generate the response. The response can be the result data or an error information including its error code and message. The response will be sent to the client following the similar step that includes serialization and deserialization as before."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.img,{alt:"RPC Process",src:t(85232).Z+"",width:"442",height:"423"}),(0,i.jsx)(n.br,{}),"\n","Source : ",(0,i.jsx)(n.a,{href:"https://www.javatpoint.com/what-is-rpc-in-operating-system",children:"https://www.javatpoint.com/what-is-rpc-in-operating-system"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["RPC provide a way for client to communicate with the server with code or function call instead of communicating by specifying specific operation like GET or POST request in ",(0,i.jsx)(n.a,{href:"/backend-development/rest-api",children:"REST API"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"grpc",children:"gRPC"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Google Remote Procedure Call (gRPC)"})," is an implementation of RPC that can run in any environment. gRPC utilize ",(0,i.jsx)(n.a,{href:"/computer-networking/http-https#http2",children:"HTTP/2"})," as the transport protocol, it gained performance advantages of HTTP/2 including multiplexing, single TCP connection, and concurrent request."]}),"\n",(0,i.jsx)(n.h4,{id:"protocol-buffers",children:"Protocol Buffers"}),"\n",(0,i.jsx)(n.p,{children:"gRPC uses protocol buffers as the default Interface Definition Language (IDL) for data serialization and deserialization. Protocol buffers is a binary serialization format developed by Google designed to be language-agnostic which mean it can be used by any language."}),"\n",(0,i.jsx)(n.p,{children:"The protocol buffer is what makes RPC able to bridge between the difference of the language used, it provide a contract for both client and server language."}),"\n",(0,i.jsx)(n.p,{children:"Here is an example of protobuf message definition :"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:"message Person {\n  string name = 1;\n  int32 age = 2;\n  repeated string emails = 3;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the example, we are defining a ",(0,i.jsx)(n.code,{children:"Person"})," type of message. It has 3 fields and each of it has unique field number as identifier. The ",(0,i.jsx)(n.code,{children:"repeated"})," keyword indicate it can have multiple values."]}),"\n",(0,i.jsx)(n.p,{children:"When the client make an gRPC call, the function executed will be serialized into binary format based on the protobuf definition and will be transmitted over the network. On the receiving end, it will be deserialized with the same definition."}),"\n",(0,i.jsxs)(n.p,{children:["For example, the ",(0,i.jsx)(n.code,{children:"Person"})," type defined above can be generated in kotlin code :"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"data class Person(\n    val name: String,\n    val age: Int,\n    val emails: List<String>\n)\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},85232:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/rpc-process-70ef10419090331fb29cd88a9e87de0a.png"},11151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>s});var i=t(67294);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);