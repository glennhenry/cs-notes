"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[4981],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>d});var r=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=r.createContext({}),c=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),h=c(a),u=n,d=h["".concat(l,".").concat(u)]||h[u]||p[u]||i;return a?r.createElement(d,o(o({ref:t},m),{},{components:a})):r.createElement(d,o({ref:t},m))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:n,o[1]=s;for(var c=2;c<i;c++)o[c]=a[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}u.displayName="MDXCreateElement"},4465:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=a(87462),n=(a(67294),a(3905));const i={slug:"/computer-and-programming-fundamentals/data-structures-and-algorithms",id:"data-structures-and-algorithms",title:"Data Structures & Algorithms",description:"Data Structures & Algorithms"},o=void 0,s={unversionedId:"computer-and-programming-fundamentals/data-structures-and-algorithms/data-structures-and-algorithms",id:"computer-and-programming-fundamentals/data-structures-and-algorithms/data-structures-and-algorithms",title:"Data Structures & Algorithms",description:"Data Structures & Algorithms",source:"@site/docs/computer-and-programming-fundamentals/09-data-structures-and-algorithms/data-structures-and-algorithms.md",sourceDirName:"computer-and-programming-fundamentals/09-data-structures-and-algorithms",slug:"/computer-and-programming-fundamentals/data-structures-and-algorithms",permalink:"/cs-notes/computer-and-programming-fundamentals/data-structures-and-algorithms",draft:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/computer-and-programming-fundamentals/09-data-structures-and-algorithms/data-structures-and-algorithms.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1699874418,formattedLastUpdatedAt:"Nov 13, 2023",frontMatter:{slug:"/computer-and-programming-fundamentals/data-structures-and-algorithms",id:"data-structures-and-algorithms",title:"Data Structures & Algorithms",description:"Data Structures & Algorithms"},sidebar:"sidebar",previous:{title:"Programming Concepts",permalink:"/cs-notes/computer-and-programming-fundamentals/programming-concepts"},next:{title:"Imperative & Procedural Programming",permalink:"/cs-notes/computer-and-programming-fundamentals/imperative-procedural-programming"}},l={},c=[{value:"Algorithm",id:"algorithm",level:3},{value:"Basic Type of Algorithm",id:"basic-type-of-algorithm",level:4},{value:"Algorithm Complexity",id:"algorithm-complexity",level:4},{value:"Big-O Notation",id:"big-o-notation",level:5},{value:"Example",id:"example",level:4},{value:"Data Structures",id:"data-structures",level:3}],m={toc:c},h="wrapper";function p(e){let{components:t,...i}=e;return(0,n.kt)(h,(0,r.Z)({},m,i,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h3",{id:"algorithm"},"Algorithm"),(0,n.kt)("p",null,"An algorithm is a set of step-by-step instructions or rules to solve a specific problem or perform a particular task. Computer works by executing instruction, an algorithm in computer programming act as the building block of a program."),(0,n.kt)("p",null,"Algorithm is really just an instruction to solve a problem, it is also not specific to computer. For example, cooking a food can be formulated in set of instruction, it may include instruction starting from preparing the ingredients, combining the ingredients, heating the pan, inserting the ingredients, and so on."),(0,n.kt)("h4",{id:"basic-type-of-algorithm"},"Basic Type of Algorithm"),(0,n.kt)("p",null,"There are many types of algorithm that are frequently used in computer programming to solve a certain task. The two basic type of algorithm are ",(0,n.kt)("strong",{parentName:"p"},"sort")," and ",(0,n.kt)("strong",{parentName:"p"},"search"),", they are the most intuitive algorithm and commonly used real-life."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Sorting"),' : Sorting algorithms are used to arrange a collection of elements in a specific order. Element can be sorted in ascending (increasing) or descending (decreasing) order. For instance, your computer may sort file on a folder by its name in ascending order. A file name contains alphabet character, the smallest alphabet character is "a" and the largest alphabet character is "z". Sorting in ascending order involve comparing each alphabet in the file name, the file name with smaller alphabet should be placed first before the larger alphabet.'),(0,n.kt)("p",{parentName:"li"},"There are many kinds of sorting algorithm, each with its own characteristics and efficiency. Example of sorting algorithm includes bubble sort, insertion sort, and selection sort."),(0,n.kt)("p",{parentName:"li"},(0,n.kt)("img",{alt:"Bubble sort algorithm",src:a(85709).Z,width:"608",height:"535"}),(0,n.kt)("br",{parentName:"p"}),"\n","Source : ",(0,n.kt)("a",{parentName:"p",href:"https://emre.me/algorithms/sorting-algorithms/"},"https://emre.me/algorithms/sorting-algorithms/"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Searching")," : Searching algorithms are used to find the presence or location of a specific element within a collection of elements. For example, in real-life, we may try to find a document within a filling cabinet. We will take the document and check if it's the one we are looking for, if yes, we will take it and if not, we will put it back and take another document."),(0,n.kt)("p",{parentName:"li"},"The common searching algorithm are the ",(0,n.kt)("strong",{parentName:"p"},"linear search")," and the ",(0,n.kt)("strong",{parentName:"p"},"binary search"),", they are used to find the location of specific element in some collection. The linear search is a very intuitive algorithm that sequentially checks each element in a collection until a match is found or the end of the collection is reached. The binary search instead is a more efficient algorithm, however, it is only appliable for sorted collection."),(0,n.kt)("p",{parentName:"li"},"Below is the comparison for linear and binary search."),(0,n.kt)("p",{parentName:"li"},(0,n.kt)("img",{alt:"Comparison of linear or sequential and binary search",src:a(2328).Z,width:"640",height:"426"}),(0,n.kt)("br",{parentName:"p"}),"\n","Source : ",(0,n.kt)("a",{parentName:"p",href:"https://tenor.com/view/binary-search-sequence-search-gif-20595028"},"https://tenor.com/view/binary-search-sequence-search-gif-20595028")),(0,n.kt)("p",{parentName:"li"},"In the GIF above, we are looking to find the location of specific element, which is 37, in a group of numbers. The steps indicate the number of time we access or check a number."),(0,n.kt)("p",{parentName:"li"},"The linear or sequential search begins from the left and sequentially check if it's the element we are looking for. The search will continue until we find the element. As seen in the GIF, in this case, the linear search takes more step than the binary search."),(0,n.kt)("p",{parentName:"li"},"The binary search algorithm assume that the collection of numbers is sorted, whether in ascending or descending order, but from now on, we will assume the collection is sorted in ascending order. In a sorted collection, the elements on the left is always smaller than the elements on the right, and vice versa. The idea is, if we managed to find a smaller number than the number we are looking for, because the numbers are sorted, then there is no way that the element would be in the left of the smaller number. Therefore, we don't need to search the portion of the collection preceding the smaller number, instead we can just eliminate that range and focuses to search on the other range."),(0,n.kt)("p",{parentName:"li"},"As seen in the GIF, we started the search in the middle, while it is possible to start at the 3/4 or 1/4 of the elements, there is no assurance that doing so would result in a more significant range reduction."))),(0,n.kt)("h4",{id:"algorithm-complexity"},"Algorithm Complexity"),(0,n.kt)("p",null,"We can decide which algorithm is better than which by comparing the efficiency. The efficiency of an algorithm is typically measured by ",(0,n.kt)("strong",{parentName:"p"},"time and space complexity"),". Time and space complexity refers to the amount of time and amount of memory or storage required by the algorithm to run."),(0,n.kt)("h5",{id:"big-o-notation"},"Big-O Notation"),(0,n.kt)("p",null,"The time and space complexity is typically measured by the dimension of the input, they are denoted by the ",(0,n.kt)("strong",{parentName:"p"},"Big-O notation"),". The big-O notation describe the efficiency of algorithms in terms of their growth rates as the input size increases."),(0,n.kt)("p",null,"Some example of big-O notation :"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"O(1) - Constant Complexity")," : A constant time complexity indicates that the algorithm will always run in the same time regardless of how many inputs are given. Similarly, a constant space complexity indicates the algorithm will always use the same amount of memory for any input.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"O(log n) - Logarithmic Complexity")," : A logarithmic complexity indicates the time or space complexity grows logarithmically with the input size.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"O(n) - Linear Time Complexity")," : A logarithmic complexity indicates the time or space complexity grows linearly with the input size, there is a proportional relationship between the algorithm's resource usage and the input size."))),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Big-O graph",src:a(64517).Z,width:"800",height:"556"}),(0,n.kt)("br",{parentName:"p"}),"\n","Source : ",(0,n.kt)("a",{parentName:"p",href:"https://www.freecodecamp.org/news/all-you-need-to-know-about-big-o-notation-to-crack-your-next-coding-interview-9d575e7eec4/"},"https://www.freecodecamp.org/news/all-you-need-to-know-about-big-o-notation-to-crack-your-next-coding-interview-9d575e7eec4/")),(0,n.kt)("h4",{id:"example"},"Example"),(0,n.kt)("p",null,"For example, in the linear search, when we start searching from the left, there is a chance that the element we are looking for is at the rightmost, therefore we have to check each element in the collection. This is the ",(0,n.kt)("strong",{parentName:"p"},"worst case scenario")," of the linear search, the time complexity is O(n) or it will be proportional to the size of the input which is the number of elements in the collection being searched."),(0,n.kt)("p",null,"On the other hand, the linear search algorithm require no extra memory, making the space complexity is O(1)."),(0,n.kt)("h3",{id:"data-structures"},"Data Structures"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Data Structures")," are specialized formats of storage used to store data efficiently. Each data structure has different characteristics that are suited for different kinds of tasks, and these characteristics correspond to the algorithm's time and space complexity."),(0,n.kt)("p",null,"Here are commonly used data structures :"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Array")," : Array is a data structure where a collection of elements is grouped together within a contiguous block of memory, where each element is next to each other. Each element in the array has its own position, called ",(0,n.kt)("strong",{parentName:"p"},"index")," and it starts from 0. To access specific element in the array, we need to know its index. The time complexity to access a single element will be in O(1) time, this is because no matter the size of the array size is, we will always access it the same way.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Stack"),' : Stack is a data structure where the elements are stacked on top of each other. It follows the Last-In-First-Out (LIFO) principle, where element can be added or removed only from the top of the stack. The operation of adding element is often called "push" and the operation of removing element is called "pop". The time complexity to add or remove element is also O(1), no matter the size, the operation will always be the same.')),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Hash Table")," : Hash table is a data structure where we access element based on a unique identifier called ",(0,n.kt)("strong",{parentName:"p"},"key"),". An element is a set of key-value pair, the key is the identifier and the value is the actual value associated with it."),(0,n.kt)("p",{parentName:"li"},"Under the hood, hash table uses an array to store the element. An array has a constant time complexity to access an element, however, in some cases the index of the element we are looking for is not known. Sometimes, the index of the element also changes overtime when we remove an element from the array."),(0,n.kt)("p",{parentName:"li"},"The idea of hash table is, we do not directly use index to access an element, we instead use a key as a unique identifier that will never change and always known by the programmer. To determine in which position of the array would the element be stored, hash table takes the key and input it in function called ",(0,n.kt)("strong",{parentName:"p"},"hash function"),". The hash function is a mathematical function that takes input and output a ",(0,n.kt)("strong",{parentName:"p"},"hash code"),", which is an integer value that can be used as the index of the element in the array. The array used in hash table is typically fixed in size, the hash function will be configured such that it will always return a value in the range of the array size."),(0,n.kt)("p",{parentName:"li"},"So, to add an element to a hash table, we will need a key and the value which is the element we are going to store. Hash table does the same way to access the element, given a key, transform it into hash code from the hash function, then use the result to access the element from the array. The hash function typically has a constant time complexity, making it a very efficient data structure to quickly access element."),(0,n.kt)("p",{parentName:"li"},"However, in some cases, the hash function may return the same hash code for different key, this is called ",(0,n.kt)("strong",{parentName:"p"},"collision")," and it's a common problem in hash table. Technique such as ",(0,n.kt)("strong",{parentName:"p"},"chaining")," is employed to mitigate this problem."),(0,n.kt)("p",{parentName:"li"},(0,n.kt)("img",{alt:"Array, stack, and hash table data structures",src:a(39182).Z,width:"666",height:"525"}),(0,n.kt)("br",{parentName:"p"}),"\n","Source : ",(0,n.kt)("a",{parentName:"p",href:"https://www.geeksforgeeks.org/when-to-use-array-over-a-list/"},"array"),", ",(0,n.kt)("a",{parentName:"p",href:"https://www.trivusi.web.id/2022/07/struktur-data-stack.html"},"stack"),", ",(0,n.kt)("a",{parentName:"p",href:"https://khalilstemmler.com/blogs/data-structures-algorithms/hash-tables/"},"hash table")))),(0,n.kt)("admonition",{type:"tip"},(0,n.kt)("p",{parentName:"admonition"},"Refer to ",(0,n.kt)("a",{parentName:"p",href:"/data-structures-and-algorithms"},"data structures and algorithm")," for more detailed explanation")))}p.isMDXComponent=!0},64517:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/big-o-5e49068ce5dba82787ed6d6e1cb6362e.png"},85709:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/bubble-sort-9533859cbbcdd7ada8860908da1394c2.gif"},39182:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/data-structure-1638a4ecb8648574d44717d29f91c866.png"},2328:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/search-algorithm-comparison-39acddd07ad4ba584d6aee2e8c46b9e5.gif"}}]);