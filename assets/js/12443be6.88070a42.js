"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[5358],{6812:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>c});var a=i(85893),r=i(11151);const t={slug:"/software-engineering/build-and-package-management",id:"build-and-package-management",title:"Build & Package Management",description:"Build & Package Management"},s=void 0,o={id:"software-engineering/build-and-package-management/build-and-package-management",title:"Build & Package Management",description:"Build & Package Management",source:"@site/docs/software-engineering/15-build-and-package-management/build-and-package-management.md",sourceDirName:"software-engineering/15-build-and-package-management",slug:"/software-engineering/build-and-package-management",permalink:"/cs-notes/software-engineering/build-and-package-management",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/software-engineering/15-build-and-package-management/build-and-package-management.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1708956183,formattedLastUpdatedAt:"Feb 26, 2024",frontMatter:{slug:"/software-engineering/build-and-package-management",id:"build-and-package-management",title:"Build & Package Management",description:"Build & Package Management"},sidebar:"sidebar",previous:{title:"Software Debugging",permalink:"/cs-notes/software-engineering/software-debugging"},next:{title:"Version Control",permalink:"/cs-notes/software-engineering/version-control"}},l={},c=[{value:"Package Management",id:"package-management",level:3},{value:"Libraries",id:"libraries",level:4},{value:"Linking",id:"linking",level:4},{value:"Dependency",id:"dependency",level:4},{value:"Package Manager",id:"package-manager",level:4},{value:"Semantic Versioning",id:"semantic-versioning",level:4},{value:"Software Build",id:"software-build",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Main Source :"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Library_(computing)",children:"Library (computing) - Wikipedia"})})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Package_manager",children:"Package manager - Wikipedia"})})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Software_repository",children:"Software repository - Wikipedia"})})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"https://semver.org/",children:"Semantic Versioning 2.0"})})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Software_build",children:"Software build - Wikipedia"})})}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"package-management",children:"Package Management"}),"\n",(0,a.jsx)(n.h4,{id:"libraries",children:"Libraries"}),"\n",(0,a.jsx)(n.p,{children:"While developing software, developers often use libraries made by other developers. This is to reduce the time spent to develop basic functionalities, so they can focus on business requirement."}),"\n",(0,a.jsxs)(n.p,{children:["When we say libraries, they are not limited to code made by others. It is really any piece of code that used to build a complete software. They can be code provided by the language itself (often called standard library), code made by others, or even your own function. A code doesn't need to be complex in order to be called a library. Even an ",(0,a.jsx)(n.code,{children:"addTwo"})," function can be considered as library. In summary, libraries are reusable code that provide specific functionality to solve common problems."]}),"\n",(0,a.jsx)(n.p,{children:"The simplest way of programming a software is, to include all the source code in a single file. Obviously this is not ideal, especially for larger and more complex projects. Another way is to separate them to multiple files, it is more realistic."}),"\n",(0,a.jsx)(n.h4,{id:"linking",children:"Linking"}),"\n",(0,a.jsxs)(n.p,{children:["When using library, functions, classes, or variables are scattered around the source code (i.e., in another file). In order to connect them together, a program called ",(0,a.jsx)(n.strong,{children:"linker"})," will link together all the libraries used. The linking process is done during compilation process and doesn't require developer intervention. The only think that the linker need is associated library, which must exist in our source code."]}),"\n",(0,a.jsx)(n.p,{children:"There are two types of library based on how they are linked :"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Static or archive library"})," : This is a type of libraries that are combined into a single file. It contains pre-compiled code, functions, classes, or variables that can be linked directly into an executable at compile time. When a static library is linked, the linker copies the pre-compiled code from the library into the final executable. This means that the compiled code from the library becomes a part of the executable. Static libraries are identified by ",(0,a.jsx)(n.code,{children:".a"})," format on Unix or ",(0,a.jsx)(n.code,{children:".lib"})," format on Windows."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Dynamic or shared library"})," : This library also contains pre-compiled code, but they are linked and loaded at runtime. Instead of copying the code into our executable, the linker creates references to the functions, classes, or variables in the dynamic library. This can reduce the size of our executable, but it requires the library to be present in the system. Dynamic libraries are identified by ",(0,a.jsx)(n.code,{children:".so"})," format on Unix or ",(0,a.jsx)(n.code,{children:".dll"})," format on Windows."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Pre-compiled library like static and dynamic is called ",(0,a.jsx)(n.strong,{children:"binary library"}),". On the other hand, if the library is still in the form of source code, then it is ",(0,a.jsx)(n.strong,{children:"source library"}),"."]}),"\n",(0,a.jsx)(n.h4,{id:"dependency",children:"Dependency"}),"\n",(0,a.jsx)(n.p,{children:"After using many libraries, managing them can be complex. It's worth noting than others library can depend on another, if we use library A, it may depend on library B and C, and each of them may depend on another. If one of the libraries need to be updated, we will need to download them again manually."}),"\n",(0,a.jsxs)(n.p,{children:["One of the scariest problem of managing library is, if one of them depend on the other. Library has specific version, some of them may use the ",(0,a.jsx)(n.a,{href:"#semantic-versioning",children:"semantic versioning"}),". The problem arise when different libraries have conflicting version requirements for their dependencies. This situation, known as ",(0,a.jsx)(n.strong,{children:"dependency version conflicts"}),", can create a complex puzzle to solve."]}),"\n",(0,a.jsx)(n.p,{children:"For example, we are using library A and C. Library A requires the version 1.2.0 of library B, while library C requires the newer version of library B, which is version 2.0.0. So, which version should we use? The problem is, it is possible that library B in the version 2.0.0 changes the behavior of some function that exist in version 1.2.0, which is used by library A."}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["The ability of a newer version of a library to be used with a previous version, specifically when there are breaking changes that affect the behavior or API of the library, is called ",(0,a.jsx)(n.strong,{children:"backward compatible"}),"."]})}),"\n",(0,a.jsxs)(n.p,{children:["Furthermore, in another scenario, what if library A depends on library B, but library B also depends on library A, creating a ",(0,a.jsx)(n.strong,{children:"circular dependency"}),". Circular dependencies can occur when integrating libraries that were not originally designed to depend on each other. We can call all this problem ",(0,a.jsx)(n.strong,{children:"dependency hell"}),", where software can't work because of its dependencies."]}),"\n",(0,a.jsx)(n.h4,{id:"package-manager",children:"Package Manager"}),"\n",(0,a.jsxs)(n.p,{children:["All the problem can be handled (not solved) by ",(0,a.jsx)(n.strong,{children:"package manager"}),", a specialized software that automates the process of installing, upgrading, configuring, or removing libraries."]}),"\n",(0,a.jsx)(n.p,{children:"The functions of package manager :"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Managing dependencies"})," : Package manager typically works with a configuration file, containing what are the dependencies needed for the project. If we want to use others library, we would add the identifier for the library and specify its version we want to use."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Dependency Installation"})," : Libraries are typically put on centralized code repository, which package managers can retrieve from. Example of them are Maven for Java, PyPI for Python, and NuGet for .NET."]}),"\n",(0,a.jsx)(n.p,{children:"To actually install library, we need to tell the package manager to retrieve the package. This is done by executing commands provided by the package manager in the command line. They will handle the necessary steps to download, extract, and install the package files, including any additional resources or configurations, similarly for deletion or removal. The package manager also keep tracks the version we are using, and we can use another command to update the package to the latest version."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Dependency Resolution"})," : Package manager analyze each dependency of different packages. They examine the version requirements and constraints specified by each package and attempt to find a compatible set of versions that satisfy all dependencies. It can construct a ",(0,a.jsx)(n.a,{href:"/data-structures-and-algorithms/graph",children:"directed graph"})," to represent the dependency structure. It then uses algorithm such as ",(0,a.jsx)(n.a,{href:"/data-structures-and-algorithms/cycle-detection",children:"cycle detection"})," and ",(0,a.jsx)(n.a,{href:"/data-structures-and-algorithms/topological-sort",children:"topological sort"})," to identify circular dependencies and determine the correct order to install dependencies."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Dependency Locking"})," : To ensure consistency between dependencies, package managers often generate lock files. These lock files capture the exact versions of the installed packages, including their dependencies. Lock files ensure that dependency version doesn't change suddenly."]}),"\n",(0,a.jsx)(n.p,{children:"Over time, new versions of packages may be released. Without locking the version, it is possible that the package manager accidentally update the package, which may introduce compatibility issue with the existing dependencies."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["An example of package manager is ",(0,a.jsx)(n.a,{href:"/frontend-web-development/npm",children:"npm"}),", which is the default package manager for ",(0,a.jsx)(n.a,{href:"/frontend-web-development/node-js",children:"Node.js"})," projects."]})}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsx)(n.p,{children:"Using package manager doesn't mean it will solve every dependency issues. Conflicting issue, such as one requiring newer version that is not compatible with older version may not be solvable by nature, and require human intervention. What package manager guarantee is, it helps us to automate and handle issue that are solvable."})}),"\n",(0,a.jsx)(n.h4,{id:"semantic-versioning",children:"Semantic Versioning"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Semantic Versioning (SemVer)"})," is a versioning scheme used to assign meaningful version numbers to software packages. It is a set of rules and guidelines that helps developers and users understand the nature of changes in a release and determine compatibility with other versions."]}),"\n",(0,a.jsx)(n.p,{children:"The format of the version in SemVer is x.y.z, for example, 1.2.4. It consists of three parts:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"MAJOR (e.g., 1.y.z)"})," : Indicates significant changes that may introduce breaking changes or incompatible API modifications compared to previous versions."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"MINOR (e.g., x.2.z)"})," : Represents added functionality or features in a backward-compatible manner. It indicates that new features have been introduced, but existing APIs remain compatible with previous versions. Typically, a dependency is kept at highest minor version, unless it is possible to update to the major version."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"PATCH (e.g., x.y.3)"})," : The patch version number is incremented for backward-compatible bug fixes, patches, or updates that do not introduce any new features."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"In addition, we can provide additional information to the version :"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Pre-release Version"})," : Denoted by appending a hyphen followed by a series of alphanumeric identifiers (e.g., 1.2.3-alpha.1). Pre-release versions are used for releases that are not yet considered stable or production-ready. They can include alpha, beta, RC (release candidate), or any custom identifiers."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Build Metadata"})," : Additional information about the version and is denoted by appending a plus sign to the pre-release or patch version followed by arbitrary identifiers (e.g., 1.0.0-alpha+001)."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"software-build",children:"Software Build"}),"\n",(0,a.jsxs)(n.p,{children:["In order to run a program, it needs to be compiled, or converted into machine code, which can be executed by computers. The general process of converting source code into executable is called ",(0,a.jsx)(n.strong,{children:"build"}),". The build process is typically automated by build tools."]}),"\n",(0,a.jsx)(n.p,{children:"A build process includes :"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Compilation"})," : Translating human-readable source code into machine-readable code, or intermediate language in the case of ",(0,a.jsx)(n.a,{href:"/computer-and-programming-fundamentals/interpreter",children:"interpreted languages"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Dependency Resolution"}),": Identifies and resolves the dependencies required by the software project. Ensures that the necessary external libraries, frameworks, or modules are available and compatible with the project. Some build tools such as Gradle includes a package manager for this."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Quality Assurance"})," : During build process, code quality is tested. This includes doing automated unit tests or analyzing code with integrated static analyzer tools."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Code Packaging"})," : Packages the necessary files and resources into a distributable format. This may involve creating an executable file, a library, an archive, or a deployable package, depending on the nature of the project."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Deployment"})," : In some cases, the build process includes deploying the software to a specific environment, such as a production server, a testing environment, or a cloud platform."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["More specifically, a build process produces a ",(0,a.jsx)(n.strong,{children:"software artifact"}),", which is a general concept that refers to any output or result of the software development process. An artifact can be executable, which contains all the necessary instruction, packaged with dependencies for end-user to execute."]}),"\n",(0,a.jsxs)(n.p,{children:["A build process can be ",(0,a.jsx)(n.strong,{children:"full"})," or ",(0,a.jsx)(n.strong,{children:"incremental"}),". A full build involves building the entire software project from scratch, while incremental build only builds the portions of the software project that have changed since the last build."]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>o,a:()=>s});var a=i(67294);const r={},t=a.createContext(r);function s(e){const n=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);