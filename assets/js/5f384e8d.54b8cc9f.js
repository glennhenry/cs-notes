"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[18],{93922:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var n=a(85893),i=a(11151);const s={slug:"/programming-language-theory/data-abstraction",id:"data-abstraction",title:"Data Abstraction",description:"Data Abstraction"},r=void 0,o={id:"programming-language-theory/data-abstraction/data-abstraction",title:"Data Abstraction",description:"Data Abstraction",source:"@site/docs/programming-language-theory/11-data-abstraction/data-abstraction.md",sourceDirName:"programming-language-theory/11-data-abstraction",slug:"/programming-language-theory/data-abstraction",permalink:"/cs-notes/programming-language-theory/data-abstraction",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/programming-language-theory/11-data-abstraction/data-abstraction.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1714543168e3,frontMatter:{slug:"/programming-language-theory/data-abstraction",id:"data-abstraction",title:"Data Abstraction",description:"Data Abstraction"},sidebar:"sidebar",previous:{title:"Subroutines",permalink:"/cs-notes/programming-language-theory/subroutines"},next:{title:"Functional Languages",permalink:"/cs-notes/programming-language-theory/functional-languages"}},c={},l=[{value:"Encapsulation &amp; Inheritance",id:"encapsulation--inheritance",level:3},{value:"Modules",id:"modules",level:4},{value:"Classes",id:"classes",level:4},{value:"Initialization &amp; Finalization",id:"initialization--finalization",level:3},{value:"Constructor &amp; Destructor",id:"constructor--destructor",level:4},{value:"Initialization &amp; Constructor",id:"initialization--constructor",level:4},{value:"Dynamic Method Binding",id:"dynamic-method-binding",level:3},{value:"Abstract Class",id:"abstract-class",level:4},{value:"Multiple Inheritance",id:"multiple-inheritance",level:4}];function d(e){const t={a:"a",admonition:"admonition",br:"br",code:"code",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Main Source :"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.strong,{children:"Book chapter 9"})}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Data abstraction"})," is the concept of abstracting data types. For example, a data type could be made to store unique set of values. The idea is to make that data type abstract, defined through an interface, which will be concretely implemented. Concrete implementation could have various way to implement that data type with its own advantages and trade-offs. From a simple array that perform ",(0,n.jsx)(t.a,{href:"/data-structures-and-algorithms/search#linear-search",children:"linear search"}),", using a ",(0,n.jsx)(t.a,{href:"/data-structures-and-algorithms/tree#binary-search-tree",children:"binary search tree"}),", or a hash set, which is implemented using ",(0,n.jsx)(t.a,{href:"/data-structures-and-algorithms/hash-table#hash-function",children:"hash function"})," to produce unique code for each element."]}),"\n",(0,n.jsx)(t.p,{children:"In programming, module is a unit of code organization that groups related code together. It is typically used to abstract away the functionality of piece of code. In some languages, module is treated as a type and as a manager."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Module-as-a-type, modules themselves can have defined attributes or fields, methods, and behavior."}),"\n",(0,n.jsx)(t.li,{children:"Module-as-a-manager, they act as a manager or controller for a set of related components or functionalities."}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["The idea of modules evolves into class and object in ",(0,n.jsx)(t.a,{href:"/computer-and-programming-fundamentals/object-oriented-programming",children:"OOP"}),", which are added with more functionality such as inheritance and polymorphism."]}),"\n",(0,n.jsx)(t.admonition,{type:"tip",children:(0,n.jsxs)(t.p,{children:["See ",(0,n.jsx)(t.a,{href:"/computer-and-programming-fundamentals/object-oriented-programming#concepts",children:"object-oriented programming"})," for OOP concepts."]})}),"\n",(0,n.jsx)(t.h3,{id:"encapsulation--inheritance",children:"Encapsulation & Inheritance"}),"\n",(0,n.jsx)(t.h4,{id:"modules",children:"Modules"}),"\n",(0,n.jsx)(t.p,{children:"In older languages like Modula, Clu, and Euclid (they are called module-based language), the concept of a module is used for encapsulation, grouping related data and operations together. They also allow portions of the module to be designated as private or public. Modules are then exported and imported into separate files for actual use."}),"\n",(0,n.jsx)(t.p,{children:"In modern languages, these have evolved into object and classes, namespaces, packages, or even just modules but with more modern features."}),"\n",(0,n.jsx)(t.h4,{id:"classes",children:"Classes"}),"\n",(0,n.jsx)(t.p,{children:"Classes are included with inheritance, allowing us to make new class that inherit the attributes and methods of another class. Inheritance will form a hierarchical structure and allows for the creation of specialized classes that inherit and build upon the functionality of more generic or abstract classes."}),"\n",(0,n.jsxs)(t.p,{children:["With inheritance being present, a new visibility modifier called ",(0,n.jsx)(t.code,{children:"protected"}),", which is less restrictive than ",(0,n.jsx)(t.code,{children:"private"})," but more restrictive than ",(0,n.jsx)(t.code,{children:"public"})," modifier. It allows class members to be visible to the class and its descendants (subclasses). In language like Java, the ",(0,n.jsx)(t.code,{children:"protected"})," keyword is extended such that class members can be visible within the entire package or namespace in which the class is declared."]}),"\n",(0,n.jsx)(t.p,{children:"Different language has different way of managing visibility. In C++, the rules for visibility modifier in inheritance as follows."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Public Inheritance"})," : When a derived class inherits publicly from a base class, public members of the base class remain public in the derived class, protected members of the base class become protected in the derived class, and private members of the base class are not accessible directly in the derived class."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Protected Inheritance"})," : In protected inheritance, public and protected members of the base class become protected in the derived class. Private members of the base class are not accessible directly in the derived class."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Private Inheritance"})," : With private inheritance, all members of the base class become private in the derived class. This means that public and protected members of the base class are not accessible outside the derived class."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Illustration :"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"class Base {\npublic:\n    int publicVar;     // Public member\nprotected:\n    int protectedVar;  // Protected member\nprivate:\n    int privateVar;    // Private member\n};\n\nclass DerivedPublic : public Base {\n    // publicVar is still public in DerivedPublic\n    // protectedVar becomes protected in DerivedPublic\n    // privateVar is not directly accessible in DerivedPublic\n};\n\nclass DerivedProtected : protected Base {\n    // publicVar becomes protected in DerivedProtected\n    // protectedVar becomes protected in DerivedProtected\n    // privateVar is not directly accessible in DerivedProtected\n};\n\nclass DerivedPrivate : private Base {\n    // publicVar becomes private in DerivedPrivate\n    // protectedVar becomes private in DerivedPrivate\n    // privateVar is not directly accessible in DerivedPrivate\n};\n"})}),"\n",(0,n.jsx)(t.h3,{id:"initialization--finalization",children:"Initialization & Finalization"}),"\n",(0,n.jsx)(t.h4,{id:"constructor--destructor",children:"Constructor & Destructor"}),"\n",(0,n.jsxs)(t.p,{children:["In OOP, constructor is the mechanism to initialize object, that is to allocate memory, setting default values, or doing other initial setup. Constructor can have different names, takes the different number of arguments, and be in many forms. If using a constructor in derived class, the base class needs to be initialized as well. With constructor initializing object, there is also ",(0,n.jsx)(t.strong,{children:"destructors"}),", which is a method called when an object is destroyed."]}),"\n",(0,n.jsx)(t.p,{children:"It can be illustrated in C++ :"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"\nclass Base {\npublic:\n    Base(int value) {} // constructor\n    ~Base() {} // destructor\n};\n\nclass Derived : public Base {\npublic:\n    Derived(int derived_value) : Base(derived_value) {}\n    ~Derived() {}\n};\n"})}),"\n",(0,n.jsx)(t.p,{children:"In C++, base class constructors are invoked before the derived class constructor, whereas destructors are called from the derived class to the base class. When a constructor is called on a derived class, the compiler traverses up the class hierarchy, invoking constructors from top to bottom, while the reverse order applies for destructors. It ensures that an object is properly initialized by initializing the highest-level object first, and it guarantees that objects are properly destroyed by destroying the lowest-level object first."}),"\n",(0,n.jsx)(t.h4,{id:"initialization--constructor",children:"Initialization & Constructor"}),"\n",(0,n.jsxs)(t.p,{children:["When initializing an object variable, we are implicitly calling the class constructor. For example, with an initialization of ",(0,n.jsx)(t.code,{children:"foo a"}),", we are creating an object named ",(0,n.jsx)(t.code,{children:"a"})," of type ",(0,n.jsx)(t.code,{children:"foo"})," using the default constructor of the class ",(0,n.jsx)(t.code,{children:"foo"}),". Because we are not giving arguments, the compiler will call constructor which doesn't take any argument. If we don't have the default constructor, the compiler will generate one for us, unless we have other constructor, then it will be a semantic error."]}),"\n",(0,n.jsxs)(t.p,{children:["So, saying ",(0,n.jsx)(t.code,{children:"foo a"})," is shorthand of ",(0,n.jsx)(t.code,{children:"foo::foo()"})," (accessing the namespace with ",(0,n.jsx)(t.code,{children:"foo::"})," then calling the constructor ",(0,n.jsx)(t.code,{children:"foo()"}),"). ",(0,n.jsx)(t.code,{children:"foo a(2, 'c')"})," is shorthand of ",(0,n.jsx)(t.code,{children:"foo::foo(int, char)"}),", the constructor for ",(0,n.jsx)(t.code,{children:"foo"})," which takes ",(0,n.jsx)(t.code,{children:"int"})," and ",(0,n.jsx)(t.code,{children:"char"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["When we say ",(0,n.jsx)(t.code,{children:"foo a(b)"}),", where ",(0,n.jsx)(t.code,{children:"b"})," is another object of ",(0,n.jsx)(t.code,{children:"foo"}),", we are invoking the copy constructor of the class ",(0,n.jsx)(t.code,{children:"foo"})," to create a new object ",(0,n.jsx)(t.code,{children:"b"})," by making a copy of ",(0,n.jsx)(t.code,{children:"a"}),". The copy constructor is a special constructor that takes a reference to an object of the same class as its parameter. It is used to create a new object by copying the state of an existing object."]}),"\n",(0,n.jsx)(t.p,{children:"In contrast to default constructor, a copy constructor look like this :"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"foo(const foo& other) {}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["So, a ",(0,n.jsx)(t.code,{children:"foo a(b)"})," is same as ",(0,n.jsx)(t.code,{children:"foo::foo(foo&)"}),". This applies not only when the argument is of the same class foo but also when the argument is an object of another class that can be implicitly converted to foo or matches a constructor overload."]}),"\n",(0,n.jsx)(t.h3,{id:"dynamic-method-binding",children:"Dynamic Method Binding"}),"\n",(0,n.jsxs)(t.p,{children:["Inheritance allow for ",(0,n.jsx)(t.a,{href:"/programming-language-theory/data-types#polymorphism",children:"subtype polymorphism"}),", in which we are able to use any method, either from superclass or subclass based on the type of object we are operating on."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"class Base {\npublic:\n    virtual void someMethod() {\n        std::cout << \"Base\" << '\\n';\n    }\n};\n\nclass Derived : public Base {\npublic:\n    void someMethod() override {\n        std::cout << \"Base\" << '\\n';\n    }\n};\n\nint main() {\n    Base* obj = new Derived();  // Pointer of type base class pointing to derived class object\n    obj->someMethod();  // Calls the overridden method in the derived class\n    delete obj;\n    return 0;\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["In this C++ code, we are making a pointer of type base class, but it actually points to a subclass ",(0,n.jsx)(t.code,{children:"Derived"}),". This is possible since ",(0,n.jsx)(t.code,{children:"Derived"})," is just the subclass of ",(0,n.jsx)(t.code,{children:"Base"})," As a result, calling ",(0,n.jsx)(t.code,{children:"someMethod"})," on ",(0,n.jsx)(t.code,{children:"obj"})," would call ",(0,n.jsx)(t.code,{children:"someMethod"})," inside ",(0,n.jsx)(t.code,{children:"Derived"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["Dynamic method binding is made possible in C++ through ",(0,n.jsx)(t.code,{children:"virtual"})," keyword. ",(0,n.jsx)(t.code,{children:"virtual"})," denotes a method that can be overridden by derived classes (where the most derived class overriding is chosen) and a dynamic dispatch should be used to determine the appropriate implementation at runtime. The ",(0,n.jsx)(t.code,{children:"override"})," denotes a method is overriding a method of subclass (although it is not required, just for readability)."]}),"\n",(0,n.jsxs)(t.p,{children:["Under the hood, the compiler is making a ",(0,n.jsx)(t.strong,{children:"virtual table (vtable)"})," to keep track method binding for each class."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.img,{alt:"vtable in C++",src:a(31970).Z+"",width:"492",height:"483"}),(0,n.jsx)(t.br,{}),"\n","Source : ",(0,n.jsx)(t.a,{href:"https://www.learncpp.com/cpp-tutorial/the-virtual-table/",children:"https://www.learncpp.com/cpp-tutorial/the-virtual-table/"})]}),"\n",(0,n.jsx)(t.p,{children:"Essentially, it's an array of function pointers where each entry corresponds to a virtual function in the class. The vtable is generated at compile-time, storing the addresses of the actual function implementations for each virtual function. The compiler also generates a hidden pointer field in the class that points to the address of the table. A separate table and inherited pointer will be created for derived class."}),"\n",(0,n.jsx)(t.h4,{id:"abstract-class",children:"Abstract Class"}),"\n",(0,n.jsxs)(t.p,{children:["With ",(0,n.jsx)(t.code,{children:"virtual"})," keyword, we can also make a class abstract, meaning it can't be instantiated directly and is designed to be used as a base class for concrete classes. A class is abstract when there is at least one abstract method. In C++, making a class abstract is done by assigning any method to 0 like ",(0,n.jsx)(t.code,{children:"virtual void pureVirtualFunction() = 0"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["In language like Java and C#, marking a class as abstract is simpler, it is done by labeling the class and method with ",(0,n.jsx)(t.code,{children:"abstract"})," keyword."]}),"\n",(0,n.jsx)(t.h4,{id:"multiple-inheritance",children:"Multiple Inheritance"}),"\n",(0,n.jsxs)(t.p,{children:["Multiple inheritance is known to cause a problem called ",(0,n.jsx)(t.strong,{children:"diamond problem"}),". It is an ambiguity that arise when two base classes of a derived class share a common base class, and they both override a common method or field."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.img,{alt:"Diamond problem",src:a(23594).Z+"",width:"218",height:"323"}),(0,n.jsx)(t.br,{}),"\n","Source : ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Multiple_inheritance",children:"https://en.wikipedia.org/wiki/Multiple_inheritance"})]}),"\n",(0,n.jsx)(t.p,{children:"C++ mitigate this issue by virtual inheritance."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"class BaseClass {\n};\n\nclass DerivedClass1 : public virtual BaseClass {\n};\n\nclass DerivedClass2 : public virtual BaseClass {\n};\n\nclass Diamond : public DerivedClass1, public DerivedClass2 {\n};\n"})}),"\n",(0,n.jsxs)(t.p,{children:["In this example, both ",(0,n.jsx)(t.code,{children:"DerivedClass1"})," and ",(0,n.jsx)(t.code,{children:"DerivedClass2"})," inherit virtually from ",(0,n.jsx)(t.code,{children:"BaseClass"})," using the virtual keyword. Using this, a shared base class for both class is constructed only once to avoid duplicate member issues."]}),"\n",(0,n.jsxs)(t.p,{children:["Then, ",(0,n.jsx)(t.code,{children:"Diamond"})," inherits from both ",(0,n.jsx)(t.code,{children:"DerivedClass1"})," and ",(0,n.jsx)(t.code,{children:"DerivedClass2"}),". With virtual inheritance, there is only one instance of ",(0,n.jsx)(t.code,{children:"BaseClass"})," in ",(0,n.jsx)(t.code,{children:"Diamond"}),", preventing the diamond problem."]})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},23594:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/diamond-780cff13c8d90e1cb6a9046c6e64d63f.png"},31970:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/vtable-e0c83cbd2b257d7c73b4592ff4a5b688.png"},11151:(e,t,a)=>{a.d(t,{Z:()=>o,a:()=>r});var n=a(67294);const i={},s=n.createContext(i);function r(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);