"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[2146],{50614:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var s=t(85893),i=t(11151);const a=t.p+"assets/medias/find-9cf53fe4ccb1d364480b13127de4b1b5.mp4",r={slug:"/data-structures-and-algorithms/union-find",id:"union-find",title:"Union Find",description:"Union Find"},o=void 0,l={id:"data-structures-and-algorithms/union-find/union-find",title:"Union Find",description:"Union Find",source:"@site/docs/data-structures-and-algorithms/25-union-find/union-find.mdx",sourceDirName:"data-structures-and-algorithms/25-union-find",slug:"/data-structures-and-algorithms/union-find",permalink:"/cs-notes/data-structures-and-algorithms/union-find",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/data-structures-and-algorithms/25-union-find/union-find.mdx",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1704711613,formattedLastUpdatedAt:"Jan 8, 2024",frontMatter:{slug:"/data-structures-and-algorithms/union-find",id:"union-find",title:"Union Find",description:"Union Find"},sidebar:"sidebar",previous:{title:"Shortest Path",permalink:"/cs-notes/data-structures-and-algorithms/shortest-path"},next:{title:"Topological Sort",permalink:"/cs-notes/data-structures-and-algorithms/topological-sort"}},h={},d=[{value:"Operation",id:"operation",level:3},{value:"Find",id:"find",level:4},{value:"Union",id:"union",level:4}];function c(e){const n={a:"a",annotation:"annotation",br:"br",code:"code",h3:"h3",h4:"h4",img:"img",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Main Source :"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Disjoint-set_data_structure",children:"Disjoint-set data structure - Wikipedia"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://youtu.be/ayW5B2W9hfo?si=pf1XvhDNEkhI2Nm8",children:"Union Find in 5 minutes \u2014 Data Structures & Algorithms - Potato Coders"})})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Union Find"}),", also called ",(0,s.jsx)(n.strong,{children:"disjoint-set"}),", is a data structure that help solving connectivity problem. It maintains a collection of disjoint sets, which is a collection of ",(0,s.jsx)(n.a,{href:"/data-structures-and-algorithms/set",children:"sets"})," where no two sets have any elements in common. In other word, it stores a collection of elements, where each collection doesn't contain an element that other collection has."]}),"\n",(0,s.jsx)(n.h3,{id:"operation",children:"Operation"}),"\n",(0,s.jsx)(n.p,{children:"Apart from being data structure, it also provides a way to determine whether two elements belong to the same set and allows us to merge two sets containing some elements into a single set."}),"\n",(0,s.jsxs)(n.p,{children:["Union find organizes its sets in a ",(0,s.jsx)(n.a,{href:"/data-structures-and-algorithms/tree",children:"tree-like structure"}),", where each node represents an element, the root is called the ",(0,s.jsx)(n.strong,{children:"representative element"}),", which serves as the identifier or representative for the entire set. This identifier will help us to determine whether two elements belong to the same set easily. The idea is, if two elements belong to the same set, their root node must be the same."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Union find",src:t(58487).Z+"",width:"636",height:"317"})}),"\n",(0,s.jsx)(n.p,{children:"Terminology :"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parent"})," : The root node, which is the representative element of the set."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Size"})," : The number of elements or nodes in the set represented by a particular node."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rank"})," : The height of a node or the longest path from the node to a leaf."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The size and rank is used to which one should be the representative, as the representative should be the one which has the most information."}),"\n",(0,s.jsx)(n.h4,{id:"find",children:"Find"}),"\n",(0,s.jsxs)(n.p,{children:["Given a node, ",(0,s.jsx)(n.code,{children:"Find"})," is a function that should return the representative. The ",(0,s.jsx)(n.code,{children:"Find"})," function is ",(0,s.jsx)(n.a,{href:"/data-structures-and-algorithms/recursion",children:"recursive"}),", it will find the parent of some node, the parent of that node again, up to the root node."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function Find(x):\n    if x.parent != x:\n        x.parent = Find(x.parent)\n        return x.parent\n    else:\n        return x\n"})}),"\n",(0,s.jsx)(n.p,{children:"In union find initialization, each element's representative is itself. When we merge element together, one of the element will become the representative, but the representative itself will still have its own representative as itself, only the other element's representative will change. The characteristics of representative's parent being itself serve as the base case for the Find recursive function."}),"\n",(0,s.jsx)("video",{width:"695",height:"392",controls:!0,children:(0,s.jsx)("source",{src:a})}),"\n",(0,s.jsx)(n.h4,{id:"union",children:"Union"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Union"})," function takes two element and merge them together."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function Union(x, y):\n    rootOfX = Find(x)\n    rootOfY = Find(y)\n\n    if rootOfX == rootOfY:\n        return\n\n    if rootOfX.rank < rootOfY.rank:\n        rootOfX.parent = rootOfY\n\n    rootOfY.parent = rootOfX\n    if rootOfX.rank == rootOfY.rank:\n        rootOfX.rank = rootOfX.rank + 1\n"})}),"\n",(0,s.jsx)(n.p,{children:"We will first find the root of x and y. If their root or representative are the same, it means they belong to the same set and no further operation is needed."}),"\n",(0,s.jsxs)(n.p,{children:["If they are in different set, we will need to decide how should we attach the tree. Should we attach x to the y or the y to the x? The decision should be attaching the smaller tree to the larger tree. How large a tree is can be determined using ",(0,s.jsx)(n.strong,{children:"size"})," or ",(0,s.jsx)(n.strong,{children:"rank"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"If they have equal rank, one root is chosen arbitrarily, and its rank is increased by one. We don't increase rank if we attach x to y or y to x, because by attaching it, the tree depth won't be increased (remember the definition of rank and the rules of attached tree should be smaller)."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"Union",src:t(25727).Z+"",width:"622",height:"249"}),(0,s.jsx)(n.br,{}),"\n","Source : ",(0,s.jsx)(n.a,{href:"https://youtu.be/ayW5B2W9hfo?si=76W-GO9H-hEy-Xk1&t=205",children:"https://youtu.be/ayW5B2W9hfo?si=76W-GO9H-hEy-Xk1&t=205"})]}),"\n",(0,s.jsxs)(n.p,{children:["The union doesn't do much apart from assigning parent, its complexity come from the ",(0,s.jsx)(n.code,{children:"Find"})," function. The ",(0,s.jsx)(n.code,{children:"Find"})," function itself has the time complexity of ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mi,{children:"O"}),(0,s.jsx)(n.mo,{stretchy:"false",children:"("}),(0,s.jsx)(n.mi,{children:"log"}),(0,s.jsx)(n.mo,{children:"\u2061"}),(0,s.jsx)(n.mi,{children:"n"}),(0,s.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(\\log n)"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,s.jsx)(n.span,{className:"mopen",children:"("}),(0,s.jsxs)(n.span,{className:"mop",children:["lo",(0,s.jsx)(n.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,s.jsx)(n.span,{className:"mclose",children:")"})]})})]}),", where ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{children:"n"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"})]})})]})," is the number of element exist in the tree. The union find data structure doesn't use extra memory for its operation, its space complexity is simply ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mi,{children:"O"}),(0,s.jsx)(n.mo,{stretchy:"false",children:"("}),(0,s.jsx)(n.mi,{children:"n"}),(0,s.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(n)"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,s.jsx)(n.span,{className:"mopen",children:"("}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,s.jsx)(n.span,{className:"mclose",children:")"})]})})]})," for storing all the ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{children:"n"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"})]})})]})," elements."]})]})}function m(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},58487:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/images/union-find-d148041dcc09a03e434bb2c440c5272c.png"},25727:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/images/union-01d7677dbf2db5f66a39999c5b5441c6.png"},11151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>r});var s=t(67294);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);