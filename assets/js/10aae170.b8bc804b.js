"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[7897],{9406:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>i,default:()=>d,frontMatter:()=>t,metadata:()=>l,toc:()=>h});var a=n(85893),r=n(11151);const t={slug:"/data-structures-and-algorithms/divide-and-conquer",id:"divide-and-conquer",title:"Divide And Conquer",description:"Divide And Conquer"},i=void 0,l={id:"data-structures-and-algorithms/divide-and-conquer/divide-and-conquer",title:"Divide And Conquer",description:"Divide And Conquer",source:"@site/docs/data-structures-and-algorithms/15-divide-and-conquer/divide-and-conquer.md",sourceDirName:"data-structures-and-algorithms/15-divide-and-conquer",slug:"/data-structures-and-algorithms/divide-and-conquer",permalink:"/cs-notes/data-structures-and-algorithms/divide-and-conquer",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/data-structures-and-algorithms/15-divide-and-conquer/divide-and-conquer.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1708786431,formattedLastUpdatedAt:"Feb 24, 2024",frontMatter:{slug:"/data-structures-and-algorithms/divide-and-conquer",id:"divide-and-conquer",title:"Divide And Conquer",description:"Divide And Conquer"},sidebar:"sidebar",previous:{title:"Recursion",permalink:"/cs-notes/data-structures-and-algorithms/recursion"},next:{title:"Traversal",permalink:"/cs-notes/data-structures-and-algorithms/traversal"}},o={},h=[{value:"Merge Sort",id:"merge-sort",level:3},{value:"Quick Sort",id:"quick-sort",level:3}];function c(e){const s={a:"a",annotation:"annotation",br:"br",code:"code",h3:"h3",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Main Source :"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:(0,a.jsx)(s.strong,{children:(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm",children:"Divide-and-conquer algorithm - Wikipedia"})})}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.strong,{children:"Divide and Conquer"})," is a problem-solving strategy that uses ",(0,a.jsx)(s.a,{href:"/data-structures-and-algorithms/recursion",children:"recursion"})," and involves breaking down a complex problem into smaller, more manageable subproblems, solving them independently, and then combining the solutions to solve the original problem."]}),"\n",(0,a.jsx)(s.p,{children:"Divide and conquer involves three steps :"}),"\n",(0,a.jsxs)(s.ol,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Divide / Split"})," : The problem is divided into smaller, more easily solvable subproblems. This can be achieved by breaking the input into smaller chunks or dividing it into multiple parts."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Conquer"})," : Each subproblem is solved independently. This can be applying the same divide and conquer strategy recursively to further break down the subproblems until they become simple enough to be solved directly."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Combine / Merge"})," : The solutions to the subproblems are combined or merged to obtain the solution to the original problem. This step involves aggregating the results from the conquered subproblems and transforming them into a solution for the overall problem."]}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.img,{alt:"Divide and conquer",src:n(70676).Z+"",width:"663",height:"286"}),(0,a.jsx)(s.br,{}),"\n","Source : ",(0,a.jsx)(s.a,{href:"https://data-notes.co/divide-and-conquer-algorithms-b135681d08fc",children:"https://data-notes.co/divide-and-conquer-algorithms-b135681d08fc"})]}),"\n",(0,a.jsx)(s.h3,{id:"merge-sort",children:"Merge Sort"}),"\n",(0,a.jsxs)(s.p,{children:["Merge sort is a ",(0,a.jsx)(s.a,{href:"/data-structures-and-algorithms/sorting",children:"sorting algorithm"})," that follows divide and conquer strategy to sort a collection of elements."]}),"\n",(0,a.jsx)(s.p,{children:"The idea is, sorting a large array must involve a lot of comparison, which result in a harder problem. Merge sort divides the array into smaller subarrays, sorting them individually, and then merging the sorted subarrays, which effectively reduces the number of comparisons needed."}),"\n",(0,a.jsx)(s.p,{children:"Here is the pseudocode :"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{children:"MergeSort(arr):\n    if length of arr <= 1:\n        return arr\n\n    mid = length of arr // 2\n    left = arr[0:mid]\n    right = arr[mid:end]\n\n    left = MergeSort(left)\n    right = MergeSort(right)\n\n    return Merge(left, right)\n\nMerge(left, right):\n    result = empty array\n\n    while left is not empty and right is not empty:\n        if left[0] <= right[0]:\n            append left[0] to result\n            remove left[0] from left\n        else:\n            append right[0] to result\n            remove right[0] from right\n\n    append remaining elements of left to result\n    append remaining elements of right to result\n\n    return result\n"})}),"\n",(0,a.jsx)(s.p,{children:"The algorithm starts by dividing the input array into two equal-sized subarrays (or approximately equal-sized if the array size is odd). This process continues until the array contains only one element or empty. Once the subarrays are small enough, the algorithm starts sorting them by comparing each other and placing them in correct order in the temporary array (result array), this process also merge the two subarray."}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.img,{alt:"Merge sort GIF",src:n(29412).Z+"",width:"300",height:"180"}),(0,a.jsx)(s.br,{}),"\n","Source : ",(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Merge_sort",children:"https://en.wikipedia.org/wiki/Merge_sort"})," (with speed modification)"]}),"\n",(0,a.jsxs)(s.p,{children:["Merge sort results in best, average, and worst-case of ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsxs)(s.mrow,{children:[(0,a.jsx)(s.mi,{children:"O"}),(0,a.jsx)(s.mo,{stretchy:"false",children:"("}),(0,a.jsx)(s.mi,{children:"n"}),(0,a.jsx)(s.mi,{children:"log"}),(0,a.jsx)(s.mo,{children:"\u2061"}),(0,a.jsx)(s.mi,{children:"n"}),(0,a.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(n \\log n)"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,a.jsx)(s.span,{className:"mopen",children:"("}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,a.jsxs)(s.span,{className:"mop",children:["lo",(0,a.jsx)(s.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,a.jsx)(s.span,{className:"mclose",children:")"})]})})]})," time complexity. This is because the algorithm divides the array into halves recursively (",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsxs)(s.mrow,{children:[(0,a.jsx)(s.mi,{children:"log"}),(0,a.jsx)(s.mo,{children:"\u2061"}),(0,a.jsx)(s.mi,{children:"n"})]}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\log n"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,a.jsxs)(s.span,{className:"mop",children:["lo",(0,a.jsx)(s.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"n"})]})})]})," term), and the merging step takes linear time (",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsx)(s.mrow,{children:(0,a.jsx)(s.mi,{children:"n"})}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.4306em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"n"})]})})]})," term) proportional to the size of the subarrays being merged."]}),"\n",(0,a.jsxs)(s.p,{children:["The memory required for merge sort is ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsxs)(s.mrow,{children:[(0,a.jsx)(s.mi,{children:"O"}),(0,a.jsx)(s.mo,{stretchy:"false",children:"("}),(0,a.jsx)(s.mi,{children:"n"}),(0,a.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(n)"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,a.jsx)(s.span,{className:"mopen",children:"("}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,a.jsx)(s.span,{className:"mclose",children:")"})]})})]}),", this is because it requires additional space to store the temporary subarrays during the merging process."]}),"\n",(0,a.jsx)(s.h3,{id:"quick-sort",children:"Quick Sort"}),"\n",(0,a.jsxs)(s.p,{children:["Quick sort is another sorting algorithm that follows the divide and conquer strategy. Quick sort selects an element (called ",(0,a.jsx)(s.strong,{children:"pivot"}),"), and then it partitions or reorders the array based on that element. The reordering involves dividing the array into two subarrays, one containing elements smaller than or equal to the pivot, and the other containing elements greater than the pivot."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{children:"QuickSort(arr, low, high):\n    if low < high:\n        pivotIndex = Partition(arr, low, high)\n        QuickSort(arr, low, pivotIndex - 1)\n        QuickSort(arr, pivotIndex + 1, high)\n\nPartition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n\n    for j = low to high - 1:\n        if arr[j] <= pivot:\n            i = i + 1\n            Swap(arr, i, j)\n\n    Swap(arr, i+1, high)\n    return i + 1\n\nSwap(arr, i, j):\n    temp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = temp\n"})}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.code,{children:"low"})," and ",(0,a.jsx)(s.code,{children:"high"})," represent the range of the array. The ",(0,a.jsx)(s.code,{children:"Partition"})," function takes the range of the array and returns the pivot index that represents the final position of the pivot element after partitioning. ",(0,a.jsx)(s.code,{children:"Partition"})," function selects a pivot element (in this case the last element) and rearranges the subarray such that elements smaller than or equal to the pivot are on the left, and elements greater than the pivot are on the right. After ",(0,a.jsx)(s.code,{children:"pivotIndex"})," is obtained, the algorithm recursively applies ",(0,a.jsx)(s.code,{children:"QuickSort"})," function on the subarrays to the left and right of the pivot until the entire array is sorted (when ",(0,a.jsx)(s.code,{children:"low"})," < ",(0,a.jsx)(s.code,{children:"high"}),")."]}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.img,{alt:"Quick sort GIF",src:n(83377).Z+"",width:"300",height:"180"}),(0,a.jsx)(s.br,{}),"\n","Source : ",(0,a.jsx)(s.a,{href:"https://en.m.wikipedia.org/wiki/File:Quicksort-example.gif",children:"https://en.m.wikipedia.org/wiki/File:Quicksort-example.gif"})," (with speed modification)"]}),"\n",(0,a.jsxs)(s.p,{children:["Quick sort achieves the same in the best and average scenario with merge sort, which is ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsxs)(s.mrow,{children:[(0,a.jsx)(s.mi,{children:"O"}),(0,a.jsx)(s.mo,{stretchy:"false",children:"("}),(0,a.jsx)(s.mi,{children:"n"}),(0,a.jsx)(s.mi,{children:"log"}),(0,a.jsx)(s.mo,{children:"\u2061"}),(0,a.jsx)(s.mi,{children:"n"}),(0,a.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(n \\log n)"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,a.jsx)(s.span,{className:"mopen",children:"("}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,a.jsxs)(s.span,{className:"mop",children:["lo",(0,a.jsx)(s.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,a.jsx)(s.span,{className:"mclose",children:")"})]})})]}),". The worst-case scenario results in ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsxs)(s.mrow,{children:[(0,a.jsx)(s.mi,{children:"O"}),(0,a.jsx)(s.mo,{stretchy:"false",children:"("}),(0,a.jsxs)(s.msup,{children:[(0,a.jsx)(s.mi,{children:"n"}),(0,a.jsx)(s.mn,{children:"2"})]}),(0,a.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(n^2)"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,a.jsx)(s.span,{className:"mopen",children:"("}),(0,a.jsxs)(s.span,{className:"mord",children:[(0,a.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,a.jsx)(s.span,{className:"msupsub",children:(0,a.jsx)(s.span,{className:"vlist-t",children:(0,a.jsx)(s.span,{className:"vlist-r",children:(0,a.jsx)(s.span,{className:"vlist",style:{height:"0.8141em"},children:(0,a.jsxs)(s.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,a.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsx)(s.span,{className:"mord mtight",children:"2"})})]})})})})})]}),(0,a.jsx)(s.span,{className:"mclose",children:")"})]})})]})," time complexity, when the pivot is consistently chosen poorly (e.g., already sorted array or sorted in reverse order). Quick sort has an advantage in terms of space complexity, requiring only ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsxs)(s.mrow,{children:[(0,a.jsx)(s.mi,{children:"O"}),(0,a.jsx)(s.mo,{stretchy:"false",children:"("}),(0,a.jsx)(s.mi,{children:"log"}),(0,a.jsx)(s.mo,{children:"\u2061"}),(0,a.jsx)(s.mi,{children:"n"}),(0,a.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(\\log n)"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,a.jsx)(s.span,{className:"mopen",children:"("}),(0,a.jsxs)(s.span,{className:"mop",children:["lo",(0,a.jsx)(s.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,a.jsx)(s.span,{className:"mclose",children:")"})]})})]})," memory, as the recursive calls are made on smaller subarrays."]})]})}function d(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},70676:(e,s,n)=>{n.d(s,{Z:()=>a});const a=n.p+"assets/images/divide-and-conquer-c4a95411bfad5a9c984b4d1821499c2a.png"},29412:(e,s,n)=>{n.d(s,{Z:()=>a});const a=n.p+"assets/images/merge-sort-68c5cbb7f1f233bce36ea7b69c877251.gif"},83377:(e,s,n)=>{n.d(s,{Z:()=>a});const a=n.p+"assets/images/quick-sort-4b63fe8b5f360c8a2500fd73ed86ec5e.gif"},11151:(e,s,n)=>{n.d(s,{Z:()=>l,a:()=>i});var a=n(67294);const r={},t=a.createContext(r);function i(e){const s=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(t.Provider,{value:s},e.children)}}}]);