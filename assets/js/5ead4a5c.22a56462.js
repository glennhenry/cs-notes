"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[8153],{67263:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});var a=i(85893),n=i(11151);const s={slug:"/database-system/database-optimization",id:"database-optimization",title:"Database Optimization",description:"Database Optimization"},o=void 0,r={id:"database-system/database-optimization/database-optimization",title:"Database Optimization",description:"Database Optimization",source:"@site/docs/database-system/08-database-optimization/database-optimization.md",sourceDirName:"database-system/08-database-optimization",slug:"/database-system/database-optimization",permalink:"/cs-notes/database-system/database-optimization",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/database-system/08-database-optimization/database-optimization.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1706698535,formattedLastUpdatedAt:"Jan 31, 2024",frontMatter:{slug:"/database-system/database-optimization",id:"database-optimization",title:"Database Optimization",description:"Database Optimization"},sidebar:"sidebar",previous:{title:"Logging & Recovery",permalink:"/cs-notes/database-system/logging-and-recovery"},next:{title:"Document",permalink:"/cs-notes/database-system/document"}},l={},d=[{value:"Index",id:"index",level:3},{value:"Query Optimization",id:"query-optimization",level:3},{value:"Query Plan",id:"query-plan",level:4},{value:"Join Ordering",id:"join-ordering",level:4},{value:"Cost Estimation",id:"cost-estimation",level:4},{value:"Caching",id:"caching",level:3},{value:"Partition",id:"partition",level:3}];function c(e){const t={a:"a",br:"br",code:"code",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Main Source :"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Query_optimization",children:"Query optimization - Wikipedia"})})}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"341-367"}),"\n",(0,a.jsx)(t.p,{children:"Query language, typically being a declarative language, allows it to make its own optimization. It is up to the database engine how will it perform the database operation. Query language doesn't rely on specific instruction from the programmer, this makes the compiler able to produce a highly optimized query in a controlled way."}),"\n",(0,a.jsx)(t.h3,{id:"index",children:"Index"}),"\n",(0,a.jsx)(t.p,{children:"aaa"}),"\n",(0,a.jsx)(t.h3,{id:"query-optimization",children:"Query Optimization"}),"\n",(0,a.jsx)(t.h4,{id:"query-plan",children:"Query Plan"}),"\n",(0,a.jsx)(t.p,{children:"It is possible for single query to have multiple valid execution plans, with different performance. For example, consider the following query :"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"SELECT *\nFROM table1\nJOIN table2 ON table1.id = table2.id\nWHERE table1.column = 'value'\n"})}),"\n",(0,a.jsx)(t.p,{children:"There are three ways to join both table :"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Nested Loop Join"})," : The optimizer scans each row from ",(0,a.jsx)(t.code,{children:"table1"})," and looks up matching rows in ",(0,a.jsx)(t.code,{children:"table2"}),". This plan is suitable when one table is significantly smaller, or when the join condition is selective, meaning it filters out a relatively small portion."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Hash Join"})," : The optimizer builds ",(0,a.jsx)(t.a,{href:"/data-structures-and-algorithms/hash-table",children:"hash tables"})," for both ",(0,a.jsx)(t.code,{children:"table1"})," and ",(0,a.jsx)(t.code,{children:"table2"}),". The hash table serves as a quick lookup for matching rows between two tables. Hash join can be more efficient when both tables are large and the join condition is not selective."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Merge Join"})," : Merge join efficiently merge the sorted data to perform the join. It scans the sorted tables simultaneously, comparing the values of the join columns. Merge join can be efficient when the data is already sorted and the join condition is not selective."]}),"\n"]}),"\n",(0,a.jsx)(t.h4,{id:"join-ordering",children:"Join Ordering"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Join Ordering"})," is the process of determining the order in which tables are joined in a database query. The goal of join ordering is to find the most efficient sequence of join operations that minimizes the overall cost of executing the query."]}),"\n",(0,a.jsx)(t.p,{children:"The query plan is represented as tree."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.img,{alt:"Query plan tree",src:i(99286).Z+"",width:"403",height:"257"}),(0,a.jsx)(t.br,{}),"\n","Source : ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Query_optimization",children:"https://en.wikipedia.org/wiki/Query_optimization"})]}),"\n",(0,a.jsxs)(t.p,{children:["Join order is determined using ",(0,a.jsx)(t.a,{href:"/data-structures-and-algorithms/dynamic-programming",children:"dynamic programming"})," algorithm pioneered by IBM's System R database. This algorithm works in two stages :"]}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Enumeration"})," : The optimizer generates all possible join order for the given tables."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Cost-Based Selection"})," : The algorithm estimates the cost of each generated join order and choose the best way."]}),"\n"]}),"\n",(0,a.jsx)(t.h4,{id:"cost-estimation",children:"Cost Estimation"}),"\n",(0,a.jsx)(t.p,{children:"A cost of query plan is estimated by several factors such as disk I/O operations, CPU time, connectivity (in the case of distributed systems), and selectivity and cardinality."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Selectivity"})," : refers to the proportion of rows in a table that satisfy a particular condition or predicate. Selectivity information helps the optimizer to plan and optimize query execution by estimating the number of rows that will be returned by a given query or predicate."]}),"\n",(0,a.jsx)(t.p,{children:"For example, if a predicate has a high selectivity, meaning it filters out a large portion of the rows, it might be advantageous to push the predicate closer to the data source to reduce the amount of data that needs to be processed."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Cardinality"})," : Cardinality is the number of distinct values or rows in a table or a column. Cardinality is important for estimating the number of rows that will be returned by a query or the number of distinct values that will be involved in a join."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"The information and metrics collected about the data and structure of a database is stored in a database statistics. These can be table, column, index statistics, which stores data types, size, cardinality, or any other metadata. Statistical summaries such as frequency and distribution of values can also be stored in a histogram."}),"\n",(0,a.jsx)(t.h3,{id:"caching",children:"Caching"}),"\n",(0,a.jsx)(t.h3,{id:"partition",children:"Partition"})]})}function h(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},99286:(e,t,i)=>{i.d(t,{Z:()=>a});const a=i.p+"assets/images/query-plan-tree-4845f57b2f227ee0cb6cdb7cc076a331.png"},11151:(e,t,i)=>{i.d(t,{Z:()=>r,a:()=>o});var a=i(67294);const n={},s=a.createContext(n);function o(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);