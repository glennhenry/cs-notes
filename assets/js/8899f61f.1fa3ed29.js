"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[7428],{835:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/resnet_architecture-b9df43210004aae1bc05119cbaff7543.png"},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var t=s(96540);const a={},i=t.createContext(a);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(i.Provider,{value:n},e.children)}},31004:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/vanishing-gradient-problem-2ba2369cb964b9c9f29d38ad5f17d9db.png"},46307:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/identity-function-2750780f5647d516afd595059166071f.png"},98986:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"deep-learning/resnet/resnet","title":"ResNet","description":"ResNet","source":"@site/docs/deep-learning/05-resnet/resnet.md","sourceDirName":"deep-learning/05-resnet","slug":"/deep-learning/resnet","permalink":"/cs-notes/deep-learning/resnet","draft":false,"unlisted":false,"editUrl":"https://github.com/glennhenry/cs-notes/tree/main/docs/deep-learning/05-resnet/resnet.md","tags":[],"version":"current","lastUpdatedBy":"glennhenry","lastUpdatedAt":1723455088000,"frontMatter":{"slug":"/deep-learning/resnet","id":"resnet","title":"ResNet","description":"ResNet"},"sidebar":"sidebar","previous":{"title":"CNN","permalink":"/cs-notes/deep-learning/cnn"},"next":{"title":"U-Net","permalink":"/cs-notes/deep-learning/u-net"}}');var a=s(74848),i=s(28453);const r={slug:"/deep-learning/resnet",id:"resnet",title:"ResNet",description:"ResNet"},l=void 0,c={},o=[{value:"The Problem",id:"the-problem",level:3},{value:"Residual Connection",id:"residual-connection",level:3},{value:"Identity Function",id:"identity-function",level:3},{value:"Residual Block",id:"residual-block",level:4}];function h(e){const n={a:"a",annotation:"annotation",br:"br",code:"code",h3:"h3",h4:"h4",img:"img",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",p:"p",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Main Source:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"https://youtu.be/o_3mboe1jYI?si=3i-uFFu0MD8UJoQu",children:"ResNet (actually) explained in under 10 minutes \u2014 rupert ai"})})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"https://youtu.be/nc7FzLiB_AY?si=4g1qmNPChEPZ4rj5",children:"What is ResNet? (with 3D Visualizations) \u2014 Prof. Ryan Ahmed"})})}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Residual Network (ResNet)"})," is a type of ",(0,a.jsx)(n.a,{href:"/deep-learning/neural-network",children:"neural network"})," developed to address the problem of training a very deep neural network (consist many hidden layers). It is to address the ",(0,a.jsx)(n.a,{href:"/deep-learning/neural-network#vanishing-gradient-problem",children:"vanishing gradient problem"}),", which occurs in the learning process of neural network, specifically in the backpropagation process."]}),"\n",(0,a.jsx)(n.h3,{id:"the-problem",children:"The Problem"}),"\n",(0,a.jsx)(n.p,{children:"The how wrong our model's predictions is calculated using a loss function. As usual, we want to minimize the loss function. Minimizing the loss function involves calculating the gradient of the loss function with respect to the parameters (such as weights) used in the prediction."}),"\n",(0,a.jsx)(n.p,{children:"Once the gradient is calculated, the network adjusts all of its parameters, including the preceding layers. The gradient of the preceding layer is calculated based on the subsequent layer using the chain rule aspect of backpropagation. In very deep networks, the gradient becomes smaller and smaller as we go into the first layer. When the gradient becomes small, it can slow down the learning process by only updating the parameters by a small amount."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.img,{alt:"Vanishing gradient problem",src:s(31004).A+"",width:"868",height:"564"}),(0,a.jsx)(n.br,{}),"\n","Source: ",(0,a.jsx)(n.a,{href:"https://botpenguin.com/glossary/vanishing-gradient-problem",children:"https://botpenguin.com/glossary/vanishing-gradient-problem"})]}),"\n",(0,a.jsx)(n.h3,{id:"residual-connection",children:"Residual Connection"}),"\n",(0,a.jsxs)(n.p,{children:["The idea of ResNet is to skip some layer in the network, this will prevent the gradient from vanishing. ResNet introduces ",(0,a.jsx)(n.strong,{children:"residual connection"}),", also known as ",(0,a.jsx)(n.strong,{children:"skip connections"}),". These connections bypass one or more layers and directly connect the output of one layer to the input of a later layer."]}),"\n",(0,a.jsx)(n.h3,{id:"identity-function",children:"Identity Function"}),"\n",(0,a.jsxs)(n.p,{children:["When we skipped a layer, for example, the output from layer 1 is sent directly to the input of layer 3. This makes us skipped some of the information that should be brought by the layer 2 before going to the layer 3. Skip connection uses comething called ",(0,a.jsx)(n.strong,{children:"identity function"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Identity function is used to capture and bring that lost information from layer 2 to the output of layer 1. It can be thought as a bridge that connect the previous layer to the next layer by combining the information lost from the skipped connections."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.img,{alt:"Identity function illustration",src:s(46307).A+"",width:"420",height:"237"}),(0,a.jsx)(n.br,{}),"\n","Source: ",(0,a.jsx)(n.a,{href:"https://towardsdatascience.com/residual-blocks-building-blocks-of-resnet-fd90ca15d6ec",children:"https://towardsdatascience.com/residual-blocks-building-blocks-of-resnet-fd90ca15d6ec"})]}),"\n",(0,a.jsxs)(n.p,{children:["In the image above, the output of previous layer is considered as ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsx)(n.mi,{children:"x"})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"x"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"x"})]})})]}),", it then bypass the next layer and goes into the ",(0,a.jsx)(n.code,{children:"+"})," symbol directly. If we consider the skipped layer as a function ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"f"}),(0,a.jsx)(n.mo,{stretchy:"false",children:"("}),(0,a.jsx)(n.mi,{children:"x"}),(0,a.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"f(x)"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.10764em"},children:"f"}),(0,a.jsx)(n.span,{className:"mopen",children:"("}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"x"}),(0,a.jsx)(n.span,{className:"mclose",children:")"})]})})]}),", which means it transform the previous layer's output ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsx)(n.mi,{children:"x"})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"x"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"x"})]})})]})," to a new output. The input of the next layer (",(0,a.jsx)(n.code,{children:"+"})," symbol) is produced from adding the first layer with the skipped layer. Basically it combine the output from the bypassing route (",(0,a.jsx)(n.strong,{children:"identity path"}),") with the route without bypassing (",(0,a.jsx)(n.strong,{children:"residual path"}),")."]}),"\n",(0,a.jsx)(n.p,{children:"When we skip some of the layer in ResNet, the output layer may receive raw output or less transformed input from the early layers that have skipped many intermediate layers. Typically, when calculating gradients, we consider all subsequent layers in the network, making it result in small gradients. This is when ResNet prevent vanishing gradient, by skipping certain layers, the gradient can become larger because we don't calculate them with respect to all subsequent layers."}),"\n",(0,a.jsxs)(n.p,{children:["For example, with the same illustration as the above image, normally the first layer's gradient is calculated with respect to function ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsx)(n.mi,{children:"f"})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"f"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.10764em"},children:"f"})]})})]})," which is the next layer, and then it is calculated with respect to ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsx)(n.mi,{children:"x"})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"x"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"x"})]})})]})," itself (chain rule). This what makes vanishing gradient occurs in deeper networks, the gradient will become smaller and small as we multiply them in chain rule."]}),"\n",(0,a.jsxs)(n.p,{children:["However, after skipping the second layer and sending its input directly to the input of third layer, we can calculate the gradient with respect to ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsx)(n.mi,{children:"x"})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"x"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"x"})]})})]})," directly, making the resulting gradient larger. We also add the result as if it passes the skipped layer, so that the skipped layer can still adjust its parameters."]}),"\n",(0,a.jsx)(n.h4,{id:"residual-block",children:"Residual Block"}),"\n",(0,a.jsxs)(n.p,{children:["Residual block is the building block of ResNet, it combines each individual layer that includes ",(0,a.jsx)(n.a,{href:"/deep-learning/cnn#convolution-1",children:"convolution layer"}),", ",(0,a.jsx)(n.a,{href:"/deep-learning/cnn#pooling-1",children:"pooling layer"}),", activation function, and any other layer with the skip connection."]}),"\n",(0,a.jsx)(n.p,{children:"This image below compare the normal network architecture with the ResNet-34 architecture, which is the variant of ResNet that consist of 34 layers."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.img,{alt:"ResNet architecture compared with plain network pass",src:s(835).A+"",width:"335",height:"846"}),(0,a.jsx)(n.br,{}),"\n","Source: ",(0,a.jsx)(n.a,{href:"https://towardsdatascience.com/understanding-and-visualizing-resnets-442284831be8",children:"https://towardsdatascience.com/understanding-and-visualizing-resnets-442284831be8"})]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}}}]);