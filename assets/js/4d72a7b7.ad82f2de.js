"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[501],{97066:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var n=a(85893),r=a(11151);const i={slug:"/software-engineering/layered",id:"layered",title:"Layered",description:"Layered"},s=void 0,o={id:"software-engineering/layered/layered",title:"Layered",description:"Layered",source:"@site/docs/software-engineering/11-layered/layered.md",sourceDirName:"software-engineering/11-layered",slug:"/software-engineering/layered",permalink:"/cs-notes/software-engineering/layered",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/software-engineering/11-layered/layered.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1710239970,formattedLastUpdatedAt:"Mar 12, 2024",frontMatter:{slug:"/software-engineering/layered",id:"layered",title:"Layered",description:"Layered"},sidebar:"sidebar",previous:{title:"Peer-to-Peer",permalink:"/cs-notes/software-engineering/peer-to-peer"},next:{title:"Other Architecture Patterns",permalink:"/cs-notes/software-engineering/other-architecture-patterns"}},l={},c=[{value:"Architecture",id:"architecture",level:3},{value:"Unidirectional Data Flow",id:"unidirectional-data-flow",level:4},{value:"Example",id:"example",level:3}];function d(e){const t={a:"a",br:"br",code:"code",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Main Source :"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Multitier_architecture",children:"Multitier architcture - Wikipedia"})})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"https://developer.android.com/topic/architecture",children:"Guide to app architecture - Android Developers"})})}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Layered architecture"}),", also known as ",(0,n.jsx)(t.strong,{children:"multitier"})," or ",(0,n.jsx)(t.strong,{children:"n-tier architecture"}),", is an architecture that organizes the system into distinct layers, each responsible for specific functionality."]}),"\n",(0,n.jsxs)(t.p,{children:["Layers are arranged in hierarchical, where layer are stacked on top of other layer, with higher layers depending on the services provided by lower layers. This architecture promotes ",(0,n.jsx)(t.a,{href:"/software-engineering/software-principles#separation-of-concerns-soc",children:"separation of concerns"})," and ",(0,n.jsx)(t.a,{href:"/software-engineering/modularization",children:"modularization"}),"."]}),"\n",(0,n.jsx)(t.h3,{id:"architecture",children:"Architecture"}),"\n",(0,n.jsx)(t.p,{children:"The architecture itself is flexible; it doesn't have to be two, three, or four layers. We can customize the architecture with as many layers as we want. Just note that having too few layers can result in a monolithic and tightly coupled system, where each component are too dependent on each other. On the other hand, having too many layers can introduce unnecessary complexity."}),"\n",(0,n.jsx)(t.p,{children:"One of the common layered architecture is the three-tier architecture, which divide the layers by three :"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Presentation / UI layer"})," : The topmost layer is responsible for handling user interactions and presenting information to the users. It typically includes components like user interfaces such as button, dialog, or web pages."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Domain layer"})," : This layer contains the core logic and functionality of the application. It's the layer that is responsible for processing and manages data, implements business rules, make decision based on input, and coordinates the application's behavior. It is independent of the user interface and data storage layers."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Data layer"})," : This layer is responsible for managing the storage and retrieval of data. It interacts with databases, file systems, or external services to persist and retrieve data for the application."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.img,{alt:"Layered architecture",src:a(98849).Z+"",width:"400",height:"358"}),(0,n.jsx)(t.br,{}),"\n","Source : ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Multitier_architecture#/media/File:Overview_of_a_three-tier_application_vectorVersion.svg",children:"https://en.wikipedia.org/wiki/Multitier_architecture#/media/File:Overview_of_a_three-tier_application_vectorVersion.svg"})]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.h4,{id:"unidirectional-data-flow",children:"Unidirectional Data Flow"}),"\n",(0,n.jsx)(t.p,{children:"Consider a music app, you are in the ranking page to see the topmost song this year. If the app uses a layered architecture, the typical data flow might look like :"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"User Interaction"}),' : The presentation layer presents UI such as a button, which might says "Top 10 songs". The user then click the button, triggering an event.']}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"UI State"})," : The presentation layer might keep track a UI state, which is the state of the UI. It may contain information, such as on what page is the user at right now, or what filtering option is currently applied."]}),"\n",(0,n.jsx)(t.p,{children:'Initially, the UI state describe that the user is still on the ranking page. When the event is triggered from the previous step (clicking the "Top 10 songs" button), the presentation layer updates the UI state to reflect the change in the user interface.'}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["The steps we just discussed is a form of ",(0,n.jsx)(t.strong,{children:"unidirectional data flow (UDF)"}),". UDF is a pattern typically used in layered architecture, where data flows in a single direction through the layers of the architecture, typically from the user interface to the data layer and back."]}),"\n",(0,n.jsxs)(t.p,{children:["UDF is typically associated with UI state, which as we talked about before, the state of the UI. The UI state will be updated upon the trigger of an event. Typically, the UI state is held by another entity in the presentation layer, which can be called as ",(0,n.jsx)(t.strong,{children:"state holder"})," or ",(0,n.jsx)(t.strong,{children:"UI controller"}),". They are entity that keeps track UI state, as well as manipulating or updating the state based on UI events."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.img,{alt:"A communication of UI and state holder",src:a(49810).Z+"",width:"467",height:"452"}),(0,n.jsx)(t.br,{}),"\n","Source : Inspired from ",(0,n.jsx)(t.a,{href:"https://developer.android.com/topic/architecture#ui-layer",children:"https://developer.android.com/topic/architecture#ui-layer"})]}),"\n",(0,n.jsx)(t.p,{children:"Depending on the interaction, the presentation layer doesn't need to communicate with the lower layer all the time. To continue with our example, checking the top 10 songs does indeed require interaction with the data layer because we are essentially retrieving data."}),"\n",(0,n.jsxs)(t.ol,{start:"3",children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Domain Layer"})," : Based on the event and UI state kept by state holder, it will make a request to the domain layer. The domain layer interprets the request and decide what should it do to fulfill the request. For example, determining whether the request can be fulfilled solely by querying the local database or if making a request to a remote server is necessary. We typically call local database or remote server as ",(0,n.jsx)(t.strong,{children:"data sources"}),", as they produce data for us to present in the UI."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Data Layer"})," : Data layer receive the request from the domain layer. The data layer can be abstracted with a ",(0,n.jsx)(t.strong,{children:"repository"}),". A repository is a pattern where we abstract away the underlying storage mechanism to access data sources. It acts as an intermediary between the domain layer and the data layer, providing a set of methods that the domain layer can use to interact with the data."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Data Retrieval"})," : After data is retrieved from the data layer, it is sent back to domain layer. The domain layer then applies required business logic, such as sorting or filtering the data based on the request made."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"UI Updated"})," : Domain sent the processed data to presentation layer. The state holder gets the data and update the UI state, reflecting a new UI where we can see the top 10 songs."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Full diagram of UDF",src:a(7612).Z+"",width:"599",height:"913"})}),"\n",(0,n.jsx)(t.p,{children:"The UDF pattern allows for organized data flow. Data flow, actions, or any updates can only happen in one-way manner. UI State can only be updated by the state holder based on the event the UI triggered. The data layer is abstracted with repository, which can be accessed by the domain layer."}),"\n",(0,n.jsx)(t.h3,{id:"example",children:"Example"}),"\n",(0,n.jsx)(t.p,{children:"A theoretical Kotlin code that follows layered architecture and UDF might look like this :"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:'fun main() {\n    val repository = Repository()\n    val domain = Domain(repository)\n    val uiState = StateHolder()\n    val screen = Screen(uiState)\n    val button = Button()\n    screen.render(button)\n\n    button.setOnClickListener {\n        val songs = domain.fetchData(uiState.sortSetting)\n        screen.displaySongs(songs)\n    }\n}\n\nclass StateHolder {\n    var sortSetting = "ascending"\n}\n\nclass Domain(private val repository: Repository) {\n    fun fetchData(sortSetting: String): List<String> {\n        if (sortSetting == "descending") {\n            repository.query("SELECT * ORDER BY DESC")\n        } else {\n            repository.query("SELECT * ORDER BY ASC")\n        }\n    }\n}\n\nclass Repository {\n    private val baseURL = "http://www.example.com"\n    private val remoteDataSource = HttpClient()\n    private val localDatabase = SQLiteDB()\n\n    fun query(q: String): List<String> {\n        val localData = localDatabase.query(q)\n        if (localData != null) {\n            return localData\n        } else {\n            val remoteData = remoteDataSource.requestTo(baseURL, "/data")\n            localDatabase.saveData(remoteData)\n            return remoteData\n        }\n    }\n}\n'})}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["The button listens for click and fetch for data from the domain layer, based on the current ",(0,n.jsx)(t.code,{children:"uiState"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:["The domain layer holds a repository, it will create the appropriate request to the data layer based on the ",(0,n.jsx)(t.code,{children:"sortSetting"})," parameter."]}),"\n",(0,n.jsx)(t.li,{children:"The data layer contains two data sources, a local database and remote data source, which is an HTTP client."}),"\n",(0,n.jsx)(t.li,{children:"When a query request is received, it initially retrieves the data from the local database. If the data is not null, meaning its available, it is immediately returned. Otherwise, the data must be obtained from a remote source. An HTTP request is made to a specific URL and endpoint, and the resulting data is saved to the local database. Finally, the retrieved data is returned to the domain layer."}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},7612:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/full-udf-c7783b8b74c5aa079c8111d314b8d52e.png"},98849:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/layered-architecture-ce82c26d56a78a079c7d3c8dda8ebbc9.png"},49810:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/udf-e496e523a2ac66a7139fa6473a6ff96b.png"},11151:(e,t,a)=>{a.d(t,{Z:()=>o,a:()=>s});var n=a(67294);const r={},i=n.createContext(r);function s(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);