"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[9237],{4460:(e,s,a)=>{a.r(s),a.d(s,{assets:()=>h,contentTitle:()=>r,default:()=>o,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var t=a(85893),n=a(11151);const i={slug:"/data-structures-and-algorithms/shortest-path",id:"shortest-path",title:"Shortest Path",description:"Shortest Path"},r=void 0,l={id:"data-structures-and-algorithms/shortest-path/shortest-path",title:"Shortest Path",description:"Shortest Path",source:"@site/docs/data-structures-and-algorithms/24-shortest-path/shortest-path.md",sourceDirName:"data-structures-and-algorithms/24-shortest-path",slug:"/data-structures-and-algorithms/shortest-path",permalink:"/cs-notes/data-structures-and-algorithms/shortest-path",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/data-structures-and-algorithms/24-shortest-path/shortest-path.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1703071515,formattedLastUpdatedAt:"Dec 20, 2023",frontMatter:{slug:"/data-structures-and-algorithms/shortest-path",id:"shortest-path",title:"Shortest Path",description:"Shortest Path"},sidebar:"sidebar",previous:{title:"Cycle Detection",permalink:"/cs-notes/data-structures-and-algorithms/cycle-detection"},next:{title:"Union Find",permalink:"/cs-notes/data-structures-and-algorithms/union-find"}},h={},c=[{value:"Dijkstra&#39;s Algorithm",id:"dijkstras-algorithm",level:3},{value:"Pathfinding",id:"pathfinding",level:3},{value:"A* Search",id:"a-search",level:4}];function m(e){const s={a:"a",annotation:"annotation",br:"br",code:"code",h3:"h3",h4:"h4",img:"img",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",msup:"msup",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,n.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Main Source :"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Shortest_path_problem",children:"Shortest path problem - Wikipedia"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm",children:"Dijkstra's algorithm - Wikipedia"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/A*_search_algorithm",children:"A* search algorithm - Wikipedia"})})}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Shortest Path"})," is the path between two vertices or nodes in a graph which has minimum total weight or cost among other possible path. A weight refers to a numerical value associated with a edge in a graph. It represents the effort required to traverse that path."]}),"\n",(0,t.jsx)(s.p,{children:"Shortest path is a common problem in graph theory and optimization. It is a common problem even in real life, where it is used to navigate or finding optimal route between locations."}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{alt:"Shortest path problem",src:a(19542).Z+"",width:"561",height:"373"})}),"\n",(0,t.jsx)(s.p,{children:"Here is an illustration, in the image above, we are supposed to start from node A and traverse to node F. There are total of three ways to get to node F, which are:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"A \u2192 C \u2192 F : (10 + 7 = 17)"}),"\n",(0,t.jsx)(s.li,{children:"A \u2192 B \u2192 D \u2192 F : (2 + 3 + 5 = 10)"}),"\n",(0,t.jsx)(s.li,{children:"A \u2192 B \u2192 E \u2192 F : (2 + 4 + 1 = 7)"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"While the first path visits the minimal nodes, it results in the highest cost. The problem become harder when we have a lot of paths, and each of the cost vary within the path. For example, one path may have larger cost at the start, but it may have a lower cost latter, leading to lower total cost overall."}),"\n",(0,t.jsx)(s.h3,{id:"dijkstras-algorithm",children:"Dijkstra's Algorithm"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Dijkstra's Algorithm"})," is a popular algorithm to find the shortest path between a source vertex to ",(0,t.jsx)(s.strong,{children:"all the other vertex"})," in a ",(0,t.jsx)(s.a,{href:"/data-structures-and-algorithms/graph#weighted",children:"weighted graph"}),". Dijkstra's algorithm works by exploring the graph from the source to each target, the cost of each traversal between nodes is kept track."]}),"\n",(0,t.jsx)(s.p,{children:"Dijkstra's algorithm explores the path systematically. When there are many possible paths, the algorithm prioritize the path with the currently minimum cost. It continues along this path before moving on to others. At the end, the algorithm will explore all the possible paths."}),"\n",(0,t.jsxs)(s.p,{children:["The systematic behavior of Dijkstra's algorithm is similar to ",(0,t.jsx)(s.a,{href:"/data-structures-and-algorithms/traversal#breadth-first-search-bfs",children:"BFS traversal"}),", it uses a ",(0,t.jsx)(s.a,{href:"/data-structures-and-algorithms/queue",children:"queue data structure"}),", specifically the ",(0,t.jsx)(s.a,{href:"/data-structures-and-algorithms/queue#priority-queue",children:"priority queue"}),", which is often implemented using ",(0,t.jsx)(s.a,{href:"/data-structures-and-algorithms/heap",children:"min-heap"})," to keep track of the path with the currently minimum cost. It is also considered as ",(0,t.jsx)(s.a,{href:"/data-structures-and-algorithms/greedy",children:"greedy algorithm"}),", because it traverses the optimal path first."]}),"\n",(0,t.jsx)(s.p,{children:"Here is the pseudocode :"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"function Dijkstra(graph, source):\n    visited = set()\n    distance = []\n    previous = []\n    heap = minHeap()\n\n    for each vertex v in graph:\n        distance[v] = infinity\n        previous[v] = undefined\n\n    distance[source] = 0\n    heap.add(source, 0)\n\n    while heap is not empty:\n        currentVertex = heap.poll()\n        if currentVertex is visited:\n            continue\n\n        visited.add(currentVertex)\n\n        for each neighbor of currentVertex:\n            if neighbor is visited:\n                continue\n\n            cost = distance[currentVertex] + weight(currentVertex, neighbor)\n\n            if cost < distance[neighbor]:\n                distance[neighbor] = cost\n                previous[neighbor] = currentVertex\n                heap.update(neighbor, cost)\n\n    return distance, previous\n"})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.img,{alt:"Dijkstra&#39;s algorithm GIF",src:a(63901).Z+"",width:"573",height:"504"}),(0,t.jsx)(s.br,{}),"\n","Source : ",(0,t.jsx)(s.a,{href:"https://blog.aos.sh/2018/02/24/understanding-dijkstras-algorithm/",children:"https://blog.aos.sh/2018/02/24/understanding-dijkstras-algorithm/"})]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["The ",(0,t.jsx)(s.code,{children:"distance"})," is an array to store the shortest distance from the source vertex to each vertex. The ",(0,t.jsx)(s.code,{children:"previous"})," is another array used to store the previous vertex that leads to the currently known shortest path from the source vertex to each vertex."]}),"\n",(0,t.jsx)(s.li,{children:"We initially make all the distance from the source to each vertex in the graph to infinity, indicating they are yet to be determined. Except for the source vertex, we will make it 0, because that is where we are going to start."}),"\n",(0,t.jsx)(s.li,{children:"We add the source to the min-heap and start the loop by polling it (remove and return the minimum element). Whatever vertex is returned, if that vertex has been visited before (present in visited set), then we will skip it, else we will continue the loop and add it to the visited set."}),"\n",(0,t.jsx)(s.li,{children:"We will iterate through every neighbor of that vertex. Next, we will add the vertex to the heap for next visit, but we will only add the one that hasn't been visited before."}),"\n",(0,t.jsxs)(s.li,{children:["We will also calculate the cost by adding the previous tracked distance with the new cost from the ",(0,t.jsx)(s.code,{children:"currentVertex"})," to the target ",(0,t.jsx)(s.code,{children:"neighbor"}),". Also update the ",(0,t.jsx)(s.code,{children:"distance"})," and ",(0,t.jsx)(s.code,{children:"previous"})," array with the ",(0,t.jsx)(s.code,{children:"currentVertex"})," and ",(0,t.jsx)(s.code,{children:"cost"})," and update the neighbor's key with the new cost in the min-heap."]}),"\n",(0,t.jsxs)(s.li,{children:["When the heap is empty, indicating there are no more paths to traverse, we will return the ",(0,t.jsx)(s.code,{children:"distance"})," and ",(0,t.jsx)(s.code,{children:"previous"})," array. The ",(0,t.jsx)(s.code,{children:"distance"})," array contains the shortest path from source vertex to all other vertex, and the ",(0,t.jsx)(s.code,{children:"previous"})," array contains the path that correspond to it."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["Using binary heap, we will obtain ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"V"}),(0,t.jsx)(s.mo,{children:"+"}),(0,t.jsx)(s.mi,{children:"E"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"}),(0,t.jsx)(s.mi,{children:"log"}),(0,t.jsx)(s.mo,{children:"\u2061"}),(0,t.jsx)(s.mi,{children:"V"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"(V + E) \\log V"})]})})}),(0,t.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(s.span,{className:"mbin",children:"+"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"}),(0,t.jsx)(s.span,{className:"mclose",children:")"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsxs)(s.span,{className:"mop",children:["lo",(0,t.jsx)(s.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"})]})]})]})," time complexity, where ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsx)(s.mrow,{children:(0,t.jsx)(s.mi,{children:"V"})}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"V"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"})]})})]})," is the number of vertices and ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsx)(s.mrow,{children:(0,t.jsx)(s.mi,{children:"E"})}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"E"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"})]})})]})," is the number of edges."]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Initializing the distance and previous arrays is ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"V"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(V)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]}),"."]}),"\n",(0,t.jsxs)(s.li,{children:["The main part of the algorithm is the while loop, which runs until the priority queue becomes empty. Adding vertex to the heap takes ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"log"}),(0,t.jsx)(s.mo,{children:"\u2061"}),(0,t.jsx)(s.mi,{children:"V"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(\\log V)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsxs)(s.span,{className:"mop",children:["lo",(0,t.jsx)(s.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]})," time, if we add a total of ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsx)(s.mrow,{children:(0,t.jsx)(s.mi,{children:"V"})}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"V"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"})]})})]})," number of vertices, then it will be ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"V"}),(0,t.jsx)(s.mi,{children:"log"}),(0,t.jsx)(s.mo,{children:"\u2061"}),(0,t.jsx)(s.mi,{children:"V"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(V \\log V)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsxs)(s.span,{className:"mop",children:["lo",(0,t.jsx)(s.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]})]}),"\n",(0,t.jsxs)(s.li,{children:["Within the while loop, we iterate over the neighbors of the current vertex. In the worst case, each edge is considered once, resulting in a total of ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"E"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(E)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]})," iterations."]}),"\n",(0,t.jsxs)(s.li,{children:["Performing heap update takes ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"log"}),(0,t.jsx)(s.mo,{children:"\u2061"}),(0,t.jsx)(s.mi,{children:"V"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(\\log V)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsxs)(s.span,{className:"mop",children:["lo",(0,t.jsx)(s.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]}),". Since the total number of vertex-neighbor pairs in the graph is ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsx)(s.mrow,{children:(0,t.jsx)(s.mi,{children:"E"})}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"E"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"})]})})]}),", the time complexity of these operations is ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"E"}),(0,t.jsx)(s.mi,{children:"log"}),(0,t.jsx)(s.mo,{children:"\u2061"}),(0,t.jsx)(s.mi,{children:"V"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(E \\log V)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsxs)(s.span,{className:"mop",children:["lo",(0,t.jsx)(s.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]}),"."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["We can also optimize this using ",(0,t.jsx)(s.strong,{children:"Fibonacci heap"})," instead of binary heap to obtain ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"E"}),(0,t.jsx)(s.mo,{children:"+"}),(0,t.jsx)(s.mi,{children:"V"}),(0,t.jsx)(s.mi,{children:"log"}),(0,t.jsx)(s.mo,{children:"\u2061"}),(0,t.jsx)(s.mi,{children:"V"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(E + V \\log V)"})]})})}),(0,t.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(s.span,{className:"mbin",children:"+"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsxs)(s.span,{className:"mop",children:["lo",(0,t.jsx)(s.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})]})]})," time complexity."]}),"\n",(0,t.jsx)(s.h3,{id:"pathfinding",children:"Pathfinding"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Pathfinding"})," is a similar problem to shortest path, it finds the most efficient path from a starting point (source) to a destination point (target). The efficiency of a path is typically measured based on certain criteria."]}),"\n",(0,t.jsx)(s.p,{children:"Dijkstra's algorithm can be used for pathfinding, it works for non-negative edge weights. It explores the graph in a breadth-first manner, iteratively expanding the vertices with the smallest known distance."}),"\n",(0,t.jsx)(s.h4,{id:"a-search",children:"A* Search"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"A* search algorithm"})," is a popular pathfinding algorithm, which is an extension of Dijkstra's algorithm. While Dijkstra solely considers the weight of edges, a* search algorithm adds another consideration and prioritize that seem more likely to lead to the goal."]}),"\n",(0,t.jsx)(s.p,{children:"The priority value is calculated by :"}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"f"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"v"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"}),(0,t.jsx)(s.mo,{children:"="}),(0,t.jsx)(s.mi,{children:"g"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"v"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"}),(0,t.jsx)(s.mo,{children:"+"}),(0,t.jsx)(s.mi,{children:"h"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"v"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"f(v) = g(v) + h(v)"})]})})}),(0,t.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.10764em"},children:"f"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"v"}),(0,t.jsx)(s.span,{className:"mclose",children:")"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(s.span,{className:"mrel",children:"="}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"g"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"v"}),(0,t.jsx)(s.span,{className:"mclose",children:")"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(s.span,{className:"mbin",children:"+"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",children:"h"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"v"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})]})]})}),"\n",(0,t.jsx)(s.p,{children:"Where :"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"f"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"v"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"f(v)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.10764em"},children:"f"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"v"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]})," : referred as f-score or function score"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"g"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"v"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"g(v)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"g"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"v"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]})," : the cost accumulated so far"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"h"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"v"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"h(v)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",children:"h"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"v"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]})," : heuristic estimate of the remaining cost from the current vertex to the target vertex."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["The key point of a* is the ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"h"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"v"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"h(v)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",children:"h"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"v"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]}),", Dijkstra's algorithm is the case where the ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"h"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"v"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"h(v)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",children:"h"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"v"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]})," is 0, or it doesn't consider the heuristic estimate and solely depends on the weights."]}),"\n",(0,t.jsx)(s.p,{children:"The heuristic estimate is an approximation of the distance or cost from some vertex to the goal. The specific implementation of the function depends on the problem. For example, in a map navigation problem, it can be a straight line distance."}),"\n",(0,t.jsx)(s.p,{children:"The heuristic estimate helps us to only focus on the path that might lead to the target. A* search algorithm doesn't visit every node, it stops when it reached the goal. This is a reason of why a* is more suited for goal-directed search problems, where we don't need to know the distance to all the vertex, unlike Dijkstra's algorithm."}),"\n",(0,t.jsx)(s.p,{children:"Here is the pseudocode :"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"function AStarSearch(start, goal):\n    openSet = PriorityQueue()\n    openSet.add(start)\n    cameFrom = empty map\n    gScore = map with default value of infinity\n    gScore[start] = 0\n    fScore = map with default value of infinity\n    fScore[start] = heuristicCostEstimate(start, goal)\n\n    while openSet is not empty:\n        current = openSet.removeMin()\n\n        if current is goal:\n            return reconstructPath(cameFrom, current)\n\n        for each neighbor in neighbors(current):\n            tentativeGScore = gScore[current] + distance(current, neighbor)\n\n            if tentativeGScore < gScore[neighbor]:\n                cameFrom[neighbor] = current\n                gScore[neighbor] = tentativeGScore\n                fScore[neighbor] = gScore[neighbor] + heuristicCostEstimate(neighbor, goal)\n\n                if neighbor not in openSet:\n                    openSet.add(neighbor)\n\n    return failure\n\nfunction reconstructPath(cameFrom, current):\n    totalPath = [current]\n\n    while current in cameFrom:\n        current = cameFrom[current]\n        totalPath.appendAtFirst(current)\n\n    return totalPath\n"})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.img,{alt:"A-star algorithm animation",src:a(36515).Z+"",width:"657",height:"325"}),(0,t.jsx)(s.br,{}),"\n","Source : ",(0,t.jsx)(s.a,{href:"https://github.com/vittin/A-Star",children:"https://github.com/vittin/A-Star"})]}),"\n",(0,t.jsx)(s.p,{children:"We can see that the path frequently approach the wall that closely covers the target due to the heuristic function. The algorithm may perceive those paths as potentially shorter or more promising."}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["We initialized some data structures, the ",(0,t.jsx)(s.code,{children:"openSet"})," is a data structure, which is a priority queue that keeps track of the vertices that have been discovered but have not yet been fully explored. Similar to Dijkstra's algorithm, we will initialize the distance as infinity. The heuristic function takes source and target vertex, the implementation depends on the specific problem."]}),"\n",(0,t.jsxs)(s.li,{children:["The algorithm runs while the ",(0,t.jsx)(s.code,{children:"openSet"})," is not empty. We will always start from the highest priority, or the one that has the lowest f-score."]}),"\n",(0,t.jsx)(s.li,{children:"If the current vertex is not the goal, the algorithm explores its neighbors. The tentative g-score represents the cost of reaching a target vertex from the starting vertex via the current path being explored. We will compare each g-score of the neighbor, if we found a lower g-score than the current path we are exploring, we will continue in that path, else we will continue with the current path."}),"\n",(0,t.jsxs)(s.li,{children:["If we found the better path, we will update the ",(0,t.jsx)(s.code,{children:"cameFrom"}),", ",(0,t.jsx)(s.code,{children:"gScore"}),", and ",(0,t.jsx)(s.code,{children:"fScore"}),". We will also update that neighbor if it is not already in the open set."]}),"\n",(0,t.jsx)(s.li,{children:'If the open set becomes empty and the goal vertex has not been reached, the algorithm returns "failure" to indicate that no path was found.'}),"\n",(0,t.jsxs)(s.li,{children:["The successful search returns the path constructed by the ",(0,t.jsx)(s.code,{children:"reconstructedPath"})," function. The ",(0,t.jsx)(s.code,{children:"reconstructedPath"})," construct the path that we traversed in reverse manner. It starts from the goal and it finds the source from the ",(0,t.jsx)(s.code,{children:"cameFrom"})," map."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["The complexity of a* search algorithm, again, it depends on the heuristic function. In the terms of vertices and edges in the graph, a* search algorithm results in the worst-case performance of ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"E"}),(0,t.jsx)(s.mi,{children:"log"}),(0,t.jsx)(s.mo,{children:"\u2061"}),(0,t.jsx)(s.mi,{children:"V"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(E \\log V)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsxs)(s.span,{className:"mop",children:["lo",(0,t.jsx)(s.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]}),", with the space complexity being ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"V"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(V)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["The priority queue operation (e.g., using heap) requires ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"log"}),(0,t.jsx)(s.mo,{children:"\u2061"}),(0,t.jsx)(s.mi,{children:"V"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(\\log V)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsxs)(s.span,{className:"mop",children:["lo",(0,t.jsx)(s.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]})," time to remove an element. In the worst case, the number of elements in the priority queue can be proportional to the number of edges, resulting in ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"E"}),(0,t.jsx)(s.mi,{children:"log"}),(0,t.jsx)(s.mo,{children:"\u2061"}),(0,t.jsx)(s.mi,{children:"V"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(E \\log V)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsxs)(s.span,{className:"mop",children:["lo",(0,t.jsx)(s.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]})," time complexity. The space required is ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"V"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(V)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]}),", the algorithm needs to store information in the ",(0,t.jsx)(s.code,{children:"openSet"}),", and other data structures such as the ",(0,t.jsx)(s.code,{children:"cameFrom"}),", ",(0,t.jsx)(s.code,{children:"gScore"}),", and ",(0,t.jsx)(s.code,{children:"fScore"})," maps."]}),"\n",(0,t.jsxs)(s.p,{children:["Another way to represent the complexity of a* algorithm is using ",(0,t.jsx)(s.strong,{children:"branching factor (b)"})," and ",(0,t.jsx)(s.strong,{children:"depth of the solution (d)"}),". (b) represents the average number of neighbors that a node has in a graph. (d) is the length or number of steps required to reach the goal or desired solution from the starting point. Using these, the overall worst-case time complexity becomes ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsxs)(s.msup,{children:[(0,t.jsx)(s.mi,{children:"b"}),(0,t.jsx)(s.mi,{children:"d"})]}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(b^d)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1.0991em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsxs)(s.span,{className:"mord",children:[(0,t.jsx)(s.span,{className:"mord mathnormal",children:"b"}),(0,t.jsx)(s.span,{className:"msupsub",children:(0,t.jsx)(s.span,{className:"vlist-t",children:(0,t.jsx)(s.span,{className:"vlist-r",children:(0,t.jsx)(s.span,{className:"vlist",style:{height:"0.8491em"},children:(0,t.jsxs)(s.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,t.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,t.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,t.jsx)(s.span,{className:"mord mathnormal mtight",children:"d"})})]})})})})})]}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]}),"."]})]})}function o(e={}){const{wrapper:s}={...(0,n.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},36515:(e,s,a)=>{a.d(s,{Z:()=>t});const t=a.p+"assets/images/a-star-algorithm-765cb59f296e1e6569f94c4d9389ea2c.gif"},63901:(e,s,a)=>{a.d(s,{Z:()=>t});const t=a.p+"assets/images/dijkstra-algorithm-def1028ae335a43cac50b2156871f7ce.gif"},19542:(e,s,a)=>{a.d(s,{Z:()=>t});const t=a.p+"assets/images/shortest-path-problem-47c90f9d450a2b0b769eec16986444cb.png"},11151:(e,s,a)=>{a.d(s,{Z:()=>l,a:()=>r});var t=a(67294);const n={},i=t.createContext(n);function r(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);