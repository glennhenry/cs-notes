"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[3407],{90252:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>h,contentTitle:()=>c,default:()=>l,frontMatter:()=>a,metadata:()=>r,toc:()=>o});var n=s(85893),i=s(11151);const a={slug:"/backend-development/caching",id:"caching",title:"Caching",description:"Caching"},c=void 0,r={id:"backend-development/caching/caching",title:"Caching",description:"Caching",source:"@site/docs/backend-development/21-caching/caching.md",sourceDirName:"backend-development/21-caching",slug:"/backend-development/caching",permalink:"/cs-notes/backend-development/caching",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/backend-development/21-caching/caching.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1707321265,formattedLastUpdatedAt:"Feb 7, 2024",frontMatter:{slug:"/backend-development/caching",id:"caching",title:"Caching",description:"Caching"},sidebar:"sidebar",previous:{title:"Backend & Server Security",permalink:"/cs-notes/backend-development/backend-server-security"},next:{title:"Backend Optimization",permalink:"/cs-notes/backend-development/backend-optimization"}},h={},o=[{value:"Type of Caching",id:"type-of-caching",level:3},{value:"Caching Strategy",id:"caching-strategy",level:3},{value:"Cache Invalidation",id:"cache-invalidation",level:3},{value:"Cache Replacement",id:"cache-replacement",level:3}];function d(e){const t={a:"a",br:"br",h3:"h3",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Main Source :"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"https://aws.amazon.com/caching/",children:"Caching Overview - AWS"})})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"https://youtu.be/G1rOthIU-uo?si=ED-VbtEqY25-TZkW",children:"Redis in 100 Seconds - Fireship"})})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"https://medium.com/@mmoshikoo/cache-strategies-996e91c80303",children:"Cache Strategies by Moshe Binieli - Medium Blog"})})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"https://dev.to/satrobit/cache-replacement-algorithms-how-to-efficiently-manage-the-cache-storage-2ne1",children:"Cache Replacement Algorithms: How To Efficiently Manage The Cache Storage by Amir Keshavarz - DEV.to"})})}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Caching"})," is the process of storing frequently accessed data or computation results in temporary storage, typically in a high-speed memory, to improve the performance and efficiency of an application or system. In the context of backend, caching helps server to response to common request by just retrieving data from previous the request."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.img,{alt:"Caching",src:s(93874).Z+"",width:"452",height:"372"}),(0,n.jsx)(t.br,{}),"\n","Source : ",(0,n.jsx)(t.a,{href:"https://pressidium.com/blog/browser-cache-work/",children:"https://pressidium.com/blog/browser-cache-work/"})]}),"\n",(0,n.jsx)(t.h3,{id:"type-of-caching",children:"Type of Caching"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Client-side"})," : The caching technique is implemented in the client side, they are typically handled by the web browsers. This includes caching static resources such as HTML pages, images, files that are loaded when the user visits a website. Web browser also include local storage API, which can be used to store frequently accessed data such as user credentials."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Server-side"})," : Caching where the server or the developer is the one who handles it, they are typically implemented on the server to store and serve frequently accessed data or resources."]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"CDN Caching"})," : CDN is a geographically distributed network of servers that are strategically placed in different locations worldwide. The primary purpose of a CDN is to improve the delivery speed and performance of web content to end-users",(0,n.jsx)(t.br,{}),"\n","For example, a person connecting from Asia is likely to have a better connection to a server located in Asia compared to a server located in a distant region, such as North America or Europe.",(0,n.jsx)(t.br,{}),"\n","We may also cache the resource in the CDN itself, which is what CDN caching is, they are considered ",(0,n.jsx)(t.strong,{children:"distributed caching"}),", which is the practice of distributing cache around multiple servers to allows efficient data access across different machines or locations."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Database Query"})," : When a common type of query is executed, the result is stored in a cache. If the same query is requested again, the server can return the cached result instead of executing the query again."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Redis"})," : ",(0,n.jsx)(t.strong,{children:"REmote DIctionary Server (Redis)"})," is in-memory data structure store that implements ",(0,n.jsx)(t.a,{href:"/data-structures-and-algorithms/hash-table",children:"hash-map like data structure"})," where data is stored as key-value pairs. The keys are unique identifiers, and the corresponding values which is where we store our actual data, it can be of different types, such as strings, lists, sets, hashes, or sorted sets. By using key-value pair, it allows for efficient constant O(1) for read and write speed."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.img,{alt:"Server side caching",src:s(17276).Z+"",width:"533",height:"633"}),(0,n.jsx)(t.br,{}),"\n","Source : ",(0,n.jsx)(t.a,{href:"https://www.wallarm.com/what/difference-between-a-cdn-and-web-accelerator",children:"CDN (top image)"}),", ",(0,n.jsx)(t.a,{href:"https://blog.hackajob.com/how-to-implement-redis-in-go/",children:"Redis cache (bottom image)"})]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"caching-strategy",children:"Caching Strategy"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Cache-Aside"})," : The application is responsible for managing the cache. When data is requested, the application first checks the cache, if the data is found, it is retrieved from the cache and returned to the requester. If the data is not in the cache (called ",(0,n.jsx)(t.strong,{children:"cache miss"}),"), the application retrieves it from the data source, stores it in the cache for future use, and then returns it to the requester."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Write-Through"})," : This is a cache writing strategy where, every time data is written or updated, it is written to both cache and data source simultaneously. Write-through caching ensures data consistency but may have higher write latency due to the additional write operation to the data source."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Write-Back"})," : Write-back caching involves writing or updating data in the cache first and deferring the write to the underlying data source. This will reduce latency compared to write-through strategy, however, this approach introduce the risk of data loss."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Read-Through"})," : When data is requested and not found in the cache (a cache miss), the cache automatically retrieves the data from the underlying data source. The retrieved data is then stored in the cache and returned to the requester."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.img,{alt:"Cache strategies",src:s(83055).Z+"",width:"1183",height:"516"}),(0,n.jsx)(t.br,{}),"\n","Source : ",(0,n.jsx)(t.a,{href:"https://medium.com/@mmoshikoo/cache-strategies-996e91c80303",children:"https://medium.com/@mmoshikoo/cache-strategies-996e91c80303"})]}),"\n",(0,n.jsx)(t.h3,{id:"cache-invalidation",children:"Cache Invalidation"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Cache Invalidation"})," is the process of removing or marking data as invalid in a cache when the corresponding data in the underlying data source is updated or deleted. It ensures that the cached data remains consistent with the source of truth."]}),"\n",(0,n.jsx)(t.p,{children:"The methods are :"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Explicit Invalidation"})," : The application explicitly triggers the invalidation of specific data in the cache when changes are made to the corresponding data in the data source. This can involve calling cache-specific methods or APIs to remove or update the affected data in the cache."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Time-Based Invalidation"})," : Associates a ",(0,n.jsx)(t.strong,{children:"time-to-live (TTL)"})," value with each cached item. When the TTL expires, the cached item is considered invalid and is evicted from the cache."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Event-Based Invalidation"})," : Cache is invalidated by observing events or triggers that signify changes in the data source. These events can be ",(0,n.jsx)(t.a,{href:"/database-system/trigger-and-constraints",children:"database triggers"})," or ",(0,n.jsx)(t.a,{href:"/backend-development/message-broker",children:"message queue notifications"}),"."]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"cache-replacement",children:"Cache Replacement"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Cache Replacement"}),", also known as ",(0,n.jsx)(t.strong,{children:"cache eviction"}),", is the process of selecting which data should be evicted from a cache when the cache reaches its capacity limit and a new item needs to be stored."]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Least Recently Used (LRU)"})," : This policy assumes that recently accessed data is more likely to be accessed again in the near future. The data item that has not been accessed for the longest period is evicted."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Least Frequently Used (LFU)"})," : This policy assumes that frequently accessed items are more valuable and should be retained in the cache. The data item that has been accessed the least number of times will be evicted."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"First-In-First-Out (FIFO)"})," : The data item that was inserted into the cache first is evicted when the cache is full. This follows a ",(0,n.jsx)(t.a,{href:"/data-structures-and-algorithms/queue",children:"queue-like behavior"}),", where the oldest data is removed."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Random Replacement"})," : This will select a random data item from the cache for eviction. It does not take into account the recency or frequency of access."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.img,{alt:"LRU cache",src:s(54173).Z+"",width:"220",height:"250"}),(0,n.jsx)(t.br,{}),"\n","Source : ",(0,n.jsx)(t.a,{href:"https://www.interviewcake.com/concept/java/lru-cache",children:"https://www.interviewcake.com/concept/java/lru-cache"})]}),"\n"]}),"\n"]})]})}function l(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},83055:(e,t,s)=>{s.d(t,{Z:()=>n});const n=s.p+"assets/images/cache-strategy-a1d76d65670b72d3e89c84dd34425ce8.png"},93874:(e,t,s)=>{s.d(t,{Z:()=>n});const n=s.p+"assets/images/caching-b115369dc5fd8ae849de3495f4df4994.png"},54173:(e,t,s)=>{s.d(t,{Z:()=>n});const n=s.p+"assets/images/lru-cache-b288abe94f9e4e91de18145ec18fb708.png"},17276:(e,t,s)=>{s.d(t,{Z:()=>n});const n=s.p+"assets/images/server-side-caching-490bbd3b1c13f841b8f6f3b5315f6348.png"},11151:(e,t,s)=>{s.d(t,{Z:()=>r,a:()=>c});var n=s(67294);const i={},a=n.createContext(i);function c(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);