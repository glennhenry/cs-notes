"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[1161],{18588:(e,r,a)=>{a.r(r),a.d(r,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"computer-and-programming-fundamentals/memory/memory","title":"Memory","description":"Memory","source":"@site/docs/computer-and-programming-fundamentals/07-memory/memory.md","sourceDirName":"computer-and-programming-fundamentals/07-memory","slug":"/computer-and-programming-fundamentals/memory","permalink":"/cs-notes/computer-and-programming-fundamentals/memory","draft":false,"unlisted":false,"editUrl":"https://github.com/glennhenry/cs-notes/tree/main/docs/computer-and-programming-fundamentals/07-memory/memory.md","tags":[],"version":"current","lastUpdatedBy":"glennhenry","lastUpdatedAt":1723455088000,"frontMatter":{"slug":"/computer-and-programming-fundamentals/memory","id":"memory","title":"Memory","description":"Memory"},"sidebar":"sidebar","previous":{"title":"Operating System","permalink":"/cs-notes/computer-and-programming-fundamentals/operating-system"},"next":{"title":"Programming Concepts","permalink":"/cs-notes/computer-and-programming-fundamentals/programming-concepts"}}');var t=a(74848),i=a(28453);const s={slug:"/computer-and-programming-fundamentals/memory",id:"memory",title:"Memory",description:"Memory"},o=void 0,c={},l=[{value:"Terminology",id:"terminology",level:3},{value:"Stack",id:"stack",level:4},{value:"Heap",id:"heap",level:4},{value:"Buffer",id:"buffer",level:4},{value:"Mutability",id:"mutability",level:4},{value:"Object",id:"object",level:4},{value:"Null",id:"null",level:4},{value:"Pointer &amp; Reference",id:"pointer--reference",level:4},{value:"Example",id:"example",level:5},{value:"Purpose of Pointer",id:"purpose-of-pointer",level:5},{value:"Purpose of Reference",id:"purpose-of-reference",level:5},{value:"Type of References",id:"type-of-references",level:5},{value:"Pointer Arithmetic",id:"pointer-arithmetic",level:5},{value:"Pointer &amp; Reference Problems",id:"pointer--reference-problems",level:5},{value:"Memory Management",id:"memory-management",level:3},{value:"Memory Allocation",id:"memory-allocation",level:4},{value:"Garbage Collection",id:"garbage-collection",level:4},{value:"Virtual Memory",id:"virtual-memory",level:4},{value:"Cache",id:"cache",level:4}];function d(e){const r={a:"a",admonition:"admonition",br:"br",code:"code",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Main Source:"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap",children:"What and where are the stack and heap? \u2014 stackoverflow"})})}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Data_buffer",children:"Data buffer \u2014 Wikipedia"})})}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"https://youtu.be/sxHng1iufQE?si=A-qOSCg_Z0oHO6bh",children:"What is the Difference Between a Pointer and a Reference C++ \u2014 Paul Programming"})})}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"https://www.freecodecamp.org/news/a-quick-and-thorough-guide-to-null-what-it-is-and-how-you-should-use-it-d170cea62840/",children:"A quick and thorough guide to \u2018null\u2019: what it is, and how you should use it by Christian Neumanns \u2014 freeCodeCamp"})})}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Memory_management",children:"Memory management \u2014 Wikipedia"})})}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.a,{href:"https://youtu.be/qeOBEOBJREs?si=Ql-qaggCrzP7T8Rt",children:"What is Virtual Memory? What Does it Do? \u2014 Eye on Tech"})})}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Memory"})," is the component in computer that used to store and retrieve data. Computer memory can be categorized into two types: ",(0,t.jsx)(r.strong,{children:"primary memory"})," (also known as main memory or RAM) and ",(0,t.jsx)(r.strong,{children:"secondary memory"})," (such as hard drives or solid-state drives)."]}),"\n",(0,t.jsx)(r.p,{children:"During the execution of program, the program's instructions or code need to be loaded into memory to be executed by the computer's processor. The processor fetches instructions from memory, performs the necessary computations, and stores the results back into memory, the result will then be used by the program."}),"\n",(0,t.jsx)(r.h3,{id:"terminology",children:"Terminology"}),"\n",(0,t.jsx)(r.h4,{id:"stack",children:"Stack"}),"\n",(0,t.jsxs)(r.p,{children:["The stack is a region of memory used for the management of function calls and local variables. It operates on the principle of ",(0,t.jsx)(r.a,{href:"/data-structures-and-algorithms/stack",children:"stack data structure"}),". Each time a function is called, a new stack frame is created and pushed onto the stack. The stack frame contains information such as function parameters, return address, and local variables."]}),"\n",(0,t.jsx)(r.p,{children:"As functions complete their execution, their stack frames are popped off the stack, allowing the program to return to the calling function. This mechanism enables the program to manage the flow of execution and maintain the context of function calls."}),"\n",(0,t.jsx)(r.p,{children:"The stack size is typically fixed and limited, determined by the compiler or the operating system. However, the stack space is generally small and can be quickly exhausted if the program uses deep recursion or has large local variables."}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.img,{alt:"Stack illustration",src:a(26033).A+"",width:"676",height:"416"}),(0,t.jsx)(r.br,{}),"\n","Source: ",(0,t.jsx)(r.a,{href:"https://stackoverflow.com/questions/32418750/stack-and-heap-locations-in-ram",children:"https://stackoverflow.com/questions/32418750/stack-and-heap-locations-in-ram"})]}),"\n",(0,t.jsx)(r.h4,{id:"heap",children:"Heap"}),"\n",(0,t.jsx)(r.p,{children:"A heap (not heap data structure) is a free store or a pool of memory used to store resources like data structures, objects, and variables that have a dynamic lifetime. By dynamic, it means those resources are stored in memory based on specific needs and conditions within the program. Those resources may grow larger or shrink depending on the program, therefore they require a flexible memory allocation."}),"\n",(0,t.jsx)(r.p,{children:"Unlike the stack, where the memory is limited and cannot be dynamically expanded at runtime, the fixed size make it not suitable to store data whose size is not known in advance or can vary significantly such us user's input."}),"\n",(0,t.jsx)(r.p,{children:"The stack is faster than heap for some reasons:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Stack is a LIFO structure, most recently allocated memory is at the top of the stack and can be accessed quickly."}),"\n",(0,t.jsx)(r.li,{children:"The fixed size of stack makes it easy to allocate memory, we can easily move up or down the size by a fixed amount."}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"Heap requires additional bookkeeping, or it requires maintaining additional information to keep track of allocated and deallocated memory blocks. When a memory block is allocated, the heap manager needs to find a suitable free block of the requested size and update the bookkeeping information accordingly."}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.img,{alt:"Heap memory vs stack",src:a(59563).A+"",width:"550",height:"336"}),(0,t.jsx)(r.br,{}),"\n","Source: ",(0,t.jsx)(r.a,{href:"https://www.javatpoint.com/stack-vs-heap-java",children:"https://www.javatpoint.com/stack-vs-heap-java"})]}),"\n",(0,t.jsx)(r.h4,{id:"buffer",children:"Buffer"}),"\n",(0,t.jsx)(r.p,{children:"A buffer is a temporary storage area used to hold data while it is being transferred between different devices or processes. It acts as an intermediate storage space, allowing for smoother and more efficient data transfer."}),"\n",(0,t.jsx)(r.p,{children:'For example, in video playback, we often hear the term "buffering" when there are delays or interruptions during the playback. The buffering process involves temporarily storing video\'s frame in the buffer. Playing each individual frame immediately as it arrives will make the playback looks rough, instead the video player stores the frames in a buffer until a certain amount of playback time is accumulated.'}),"\n",(0,t.jsx)(r.p,{children:"Another usage for buffer is to improve retrieval efficiency in I/O (input-output) operation. Accessing data stored in the storage (e.g., hard drive) can be slower than accessing to computer's main memory (e.g., RAM). When reading a file, the computer can load a chunk of data from hard drive into the buffer, then the application will load the data from the buffer rather than directly accessing the storage device."}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.img,{alt:"Buffering",src:a(19479).A+"",width:"340",height:"314"}),(0,t.jsx)(r.br,{}),"\n","Source: ",(0,t.jsx)(r.a,{href:"http://www.planetoftunes.com/computer/caching-and-streaming.php",children:"http://www.planetoftunes.com/computer/caching-and-streaming.php"})]}),"\n",(0,t.jsx)(r.h4,{id:"mutability",children:"Mutability"}),"\n",(0,t.jsxs)(r.p,{children:["Mutability refers to whether an object, data structure, or a variable can be modified after it is created. An object that can be modified after a value is assigned is called ",(0,t.jsx)(r.strong,{children:"mutable"}),", while the opposite is called ",(0,t.jsx)(r.strong,{children:"immutable"}),"."]}),"\n",(0,t.jsx)(r.p,{children:"In memory, when a mutable object is created, a block if memory is allocated to store its contents. When we change the value of the object, we are modifying it in place, and the memory address remains the same."}),"\n",(0,t.jsx)(r.p,{children:"On the other hand, when someone tries to change an immutable object, the particular address that holds the value won't be changed, instead, a new object with the modified values is created, and a new memory location is allocated to store the new object."}),"\n",(0,t.jsx)(r.p,{children:"Here is an example in code:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"a = 5\na = 3\n"})}),"\n",(0,t.jsxs)(r.p,{children:["When we assign ",(0,t.jsx)(r.code,{children:"a = 5"}),", a memory object representing the value ",(0,t.jsx)(r.code,{children:"5"})," is created and stored. The variable ",(0,t.jsx)(r.code,{children:"a"})," is then associated with this object. Later, when we assign ",(0,t.jsx)(r.code,{children:"a = 3"}),", assuming numbers are immutable, a new memory object representing the value ",(0,t.jsx)(r.code,{children:"3"})," is created. The variable ",(0,t.jsx)(r.code,{children:"a"})," is updated to reference this new object. The original object representing ",(0,t.jsx)(r.code,{children:"5"})," remains in memory until it is cleaned up by the ",(0,t.jsx)(r.a,{href:"/computer-and-programming-fundamentals/memory#garbage-collection",children:"garbage collector"})," or manually released in lower-level programming languages."]}),"\n",(0,t.jsx)(r.h4,{id:"object",children:"Object"}),"\n",(0,t.jsxs)(r.p,{children:["Object can refer to object in ",(0,t.jsx)(r.a,{href:"/computer-and-programming-fundamentals/object-oriented-programming",children:"OOP"}),", which is a particular instance of a class. In general, when we refer to object, we tend to describe it as anything that has name or identifier, such as a variable."]}),"\n",(0,t.jsx)(r.h4,{id:"null",children:"Null"}),"\n",(0,t.jsxs)(r.p,{children:["Null, also known as ",(0,t.jsx)(r.strong,{children:"nil"}),", is a special value that represents the absence of a value. It is often used to indicate that a variable or pointer does not currently point to any valid data."]}),"\n",(0,t.jsx)(r.h4,{id:"pointer--reference",children:"Pointer & Reference"}),"\n",(0,t.jsxs)(r.p,{children:["A ",(0,t.jsx)(r.strong,{children:"pointer"}),' is a variable that stores the memory address of another variable. It "points" to the location in memory where the actual data is stored.']}),"\n",(0,t.jsxs)(r.p,{children:["A ",(0,t.jsx)(r.strong,{children:"reference"}),' is a variable that "refer" to other variable. Reference provides an alternative name or alias for an existing object.']}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.img,{alt:"Pointer and references",src:a(67983).A+"",width:"602",height:"199"}),(0,t.jsx)(r.br,{}),"\n","Source: ",(0,t.jsx)(r.a,{href:"https://youtu.be/sxHng1iufQE?si=qfog89ZUE5UIXQsB&t=463",children:"https://youtu.be/sxHng1iufQE?si=qfog89ZUE5UIXQsB&t=463"})," (cropped and edited)"]}),"\n",(0,t.jsx)(r.h5,{id:"example",children:"Example"}),"\n",(0,t.jsx)(r.p,{children:"Here's an example taken from a YouTube video:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["In the line 1, we are declaring a variable named ",(0,t.jsx)(r.code,{children:"ptr"})," which is a pointer (marked by ",(0,t.jsx)(r.code,{children:"*"}),' symbol), that pointer will "point" to a memory address of an ',(0,t.jsx)(r.code,{children:"int"}),". Currently, it doesn't point to anything yet."]}),"\n",(0,t.jsxs)(r.li,{children:["In the line 2 and 3, we are declaring two variable that holds an ",(0,t.jsx)(r.code,{children:"int"}),", named ",(0,t.jsx)(r.code,{children:"var"})," and ",(0,t.jsx)(r.code,{children:"foo"}),", respectively. Memory will be allocated to store these values, and both variables will hold their respective values."]}),"\n",(0,t.jsxs)(r.li,{children:["We are assigning an address to ",(0,t.jsx)(r.code,{children:"ptr"})," variable, the value will be ",(0,t.jsx)(r.code,{children:"&var"}),". The symbol ",(0,t.jsx)(r.code,{children:"&"})," is the ",(0,t.jsx)(r.strong,{children:"address-of operator"}),", when we say ",(0,t.jsx)(r.code,{children:"&var"}),", it means we are taking the address of ",(0,t.jsx)(r.code,{children:"var"})," variable. Based on the image, the ",(0,t.jsx)(r.code,{children:"ptr"})," will now store the address of ",(0,t.jsx)(r.code,{children:"var"})," variable, which is ",(0,t.jsx)(r.code,{children:"0xA"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:["We are changing the address of ",(0,t.jsx)(r.code,{children:"ptr"})," variable to ",(0,t.jsx)(r.code,{children:"&foo"}),". Now, ",(0,t.jsx)(r.code,{children:"ptr"})," will hold the address of ",(0,t.jsx)(r.code,{children:"foo"})," variable, which is ",(0,t.jsx)(r.code,{children:"0xB"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:["In the line 5, we are creating a variable that named ",(0,t.jsx)(r.code,{children:"ref"})," that holds reference to an ",(0,t.jsx)(r.code,{children:"int"})," variable, which is ",(0,t.jsx)(r.code,{children:"var"}),". The ",(0,t.jsx)(r.code,{children:"ref"})," variable will have the same exact address as ",(0,t.jsx)(r.code,{children:"var"}),"."]}),"\n"]}),"\n",(0,t.jsx)(r.h5,{id:"purpose-of-pointer",children:"Purpose of Pointer"}),"\n",(0,t.jsx)(r.p,{children:"Consider the following code:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-c",children:"int x = 5;\nint* ptr = &x;\n*ptr = 10;\n"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"x"})," is an ",(0,t.jsx)(r.code,{children:"int"})," variable with a value of ",(0,t.jsx)(r.code,{children:"5"}),", while ",(0,t.jsx)(r.code,{children:"ptr"})," is an ",(0,t.jsx)(r.code,{children:"int"})," pointer that stores the memory address of ",(0,t.jsx)(r.code,{children:"x"}),". Now that ",(0,t.jsx)(r.code,{children:"ptr"})," holds the address of ",(0,t.jsx)(r.code,{children:"x"}),", to actually get element stored in it, we would need to ",(0,t.jsx)(r.strong,{children:"dereference"})," the pointer."]}),"\n",(0,t.jsxs)(r.p,{children:["When we say ",(0,t.jsx)(r.code,{children:"*ptr = 10"}),", we are dereferencing the pointer and assigning a value 10 to that address. What we did is changing the value directly from the memory address that holds it. As a result, any variable associated with that address, such as ",(0,t.jsx)(r.code,{children:"x"}),", will also be modified. Using pointer, we can effectively modify other variables indirectly through their shared memory address."]}),"\n",(0,t.jsxs)(r.p,{children:["Pointer which stores memory address allows us to have direct memory access. This is useful for implementing data structures like ",(0,t.jsx)(r.a,{href:"/data-structures-and-algorithms/tree",children:"tree"})," or ",(0,t.jsx)(r.a,{href:"/data-structures-and-algorithms/linked-list",children:"linked list"}),", where each node need to connection with other node. We can allow connection between node by having a pointer that points to other node's address."]}),"\n",(0,t.jsx)(r.h5,{id:"purpose-of-reference",children:"Purpose of Reference"}),"\n",(0,t.jsx)(r.p,{children:"Consider the following code:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-c",children:"int a = 5;\nint b = a;\n"})}),"\n",(0,t.jsxs)(r.p,{children:["In this code, we are declaring an ",(0,t.jsx)(r.code,{children:"int"})," variable named ",(0,t.jsx)(r.code,{children:"a"})," with the value of ",(0,t.jsx)(r.code,{children:"5"}),". In the next line, we are declaring another ",(0,t.jsx)(r.code,{children:"int"})," variable named ",(0,t.jsx)(r.code,{children:"b"})," with the value of variable ",(0,t.jsx)(r.code,{children:"a"}),". When we assign a variable with the value of another variable, we are essentially taking the copy of that variable and save it in the new variable. Because it's just a copy, modifying ",(0,t.jsx)(r.code,{children:"b"})," will not affect the value of ",(0,t.jsx)(r.code,{children:"a"}),", and vice versa."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-c",children:"int a = 5;\nint& b = a;\n"})}),"\n",(0,t.jsxs)(r.p,{children:["However, in this code we added ",(0,t.jsx)(r.code,{children:"&"})," symbol, which mean we are creating a reference instead of just copying the value. When we make change, either to variable ",(0,t.jsx)(r.code,{children:"a"})," or ",(0,t.jsx)(r.code,{children:"b"}),", both variable will be changed. This is because a reference refer to the same memory location."]}),"\n",(0,t.jsx)(r.p,{children:"Some purpose of using reference:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"We can create another name for a variable to make code more readable and expressive."}),"\n",(0,t.jsx)(r.li,{children:"In situations where multiple instances of a value are required, there is no need to create separate copies explicitly. Instead, we can utilize a single value by creating references, each instance will point to the same value stored in a single location. This approach simplifies the process of synchronizing all instances since modifying the referenced value will automatically update all the instances, reducing the processing resources required."}),"\n"]}),"\n",(0,t.jsx)(r.h5,{id:"type-of-references",children:"Type of References"}),"\n",(0,t.jsx)(r.p,{children:"The two important type of reference:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Strong Reference"}),": A strong reference is the default type of reference in many programming languages. It keeps an object in memory as long as there is at least one strong reference pointing to it. As long as there are active strong references, the object will not be ",(0,t.jsx)(r.a,{href:"/computer-and-programming-fundamentals/memory#garbage-collection",children:"garbage-collected"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Weak Reference"}),": A weak reference is a type of reference that does not prevent the object from being garbage-collected. In other word, when a variable have weak reference to an object, we can't guarantee that the variable will always contain that object, as the object may be garbage-collected or cleaned from the memory. If the object is garbage-collected and we are accessing the variable, we may get ",(0,t.jsx)(r.a,{href:"/computer-and-programming-fundamentals/memory#null",children:"null"})," value."]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"There are also soft, phantom, and unreachable reference."}),"\n",(0,t.jsx)(r.h5,{id:"pointer-arithmetic",children:"Pointer Arithmetic"}),"\n",(0,t.jsx)(r.p,{children:"Pointer arithmetic is a feature that allow programmer to perform arithmetic operations (i.e., add, subtract, multiply, divide) on pointers. It enables us to manipulate memory addresses directly."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-c",children:"int arr[5] = {1, 2, 3, 4, 5};\nint* p = arr;\n"})}),"\n",(0,t.jsxs)(r.p,{children:["In this C code, an array of integer called ",(0,t.jsx)(r.code,{children:"arr"})," is created. Then, we create a pointer called ",(0,t.jsx)(r.code,{children:"p"})," that points to ",(0,t.jsx)(r.code,{children:"arr"}),". This works, because essentially ",(0,t.jsx)(r.a,{href:"/data-structures-and-algorithms/array",children:"array is just a pointer under the hood"})," that points to the first element of the array. So, ",(0,t.jsx)(r.code,{children:"arr"})," and ",(0,t.jsx)(r.code,{children:"p"})," both points to the address of element 1."]}),"\n",(0,t.jsxs)(r.p,{children:["In programming languages, array access is typically done with square bracket. ",(0,t.jsx)(r.code,{children:"arr[3]"})," is accessing element of index 3 from the ",(0,t.jsx)(r.code,{children:"arr"}),". Under the hood, we are calculating the memory address of element of index 3 and through that memory address, we obtained the actual element. This can be done using pointer arithmetic."]}),"\n",(0,t.jsxs)(r.p,{children:["The formula of array access is ",(0,t.jsx)(r.code,{children:"memory_address = base_address + (data_types_size * index)"}),". The ",(0,t.jsx)(r.code,{children:"base_address"})," is obtained from the pointer that points to the first element, that is pointer ",(0,t.jsx)(r.code,{children:"p"})," or the ",(0,t.jsx)(r.code,{children:"arr"})," itself. With ",(0,t.jsx)(r.code,{children:"arr[3]"}),", we are essentially specifying that the index is 3. The program knows that ",(0,t.jsx)(r.code,{children:"arr"})," is an integer array, whose size is 4 bytes. If the ",(0,t.jsx)(r.code,{children:"base_address"})," is 200, then element of index 3 would be in address 200 + (4 \xd7 3) = 212."]}),"\n",(0,t.jsx)(r.p,{children:"Let's illustrate this in code."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-c",children:"int arr[5] = {1, 2, 3, 4, 5}; // arr actually holds address of 1\nint* p = arr; // p holds address of 1\n\narr[3]\n// is same as\n*(p + 3)\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Accessing index 3 with ",(0,t.jsx)(r.code,{children:"arr[3]"})," is essentially same as adding 3 to the pointer ",(0,t.jsx)(r.code,{children:"p"}),", then dereference that pointer to actually obtain the element stored in that address (",(0,t.jsx)(r.code,{children:"data_types_size"})," is calculated automatically)."]}),"\n",(0,t.jsx)(r.admonition,{type:"note",children:(0,t.jsx)(r.p,{children:"Array indexing is just one use of pointer arithmetic, it can be thought as pointer arithmetic that is done internally."})}),"\n",(0,t.jsx)(r.h5,{id:"pointer--reference-problems",children:"Pointer & Reference Problems"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"use after free"}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"dangling reference"}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"dangling pointer"}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"null pointer"}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"memory leak"}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"double free"}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"tombstones"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,t.jsx)(r.h4,{id:"memory-allocation",children:"Memory Allocation"}),"\n",(0,t.jsx)(r.p,{children:"Memory allocation refers to the process of assigning and reserving a portion of the computer's memory for the storage and management of data during program execution. It involves determining the size and location of memory blocks that will be used to store variables, objects, data structures, and other program components."}),"\n",(0,t.jsxs)(r.p,{children:["For example, memory allocation on the heap is typically done explicitly by the program. When we store some data on the memory, we need to specify the size of memory needed, and the system finds a suitable block of memory to accommodate that size. When some data is no longer needed, the program needs to release the memory to avoid ",(0,t.jsx)(r.strong,{children:"memory leaks"}),", which a scenario when a memory is allocated but not released, leading to inefficient memory usage."]}),"\n",(0,t.jsx)(r.h4,{id:"garbage-collection",children:"Garbage Collection"}),"\n",(0,t.jsx)(r.p,{children:"Garbage collection is an automatic memory management technique to automatically reclaim memory that is no longer needed by the program. Its primary purpose is to free up memory occupied by objects that are no longer reachable or referenced by the program."}),"\n",(0,t.jsxs)(r.p,{children:["The garbage collector knows a data or an object is no longer needed by the program using a technique called ",(0,t.jsx)(r.strong,{children:"reference counting"}),". It is a technique where each object stores a count and keeps track of the number of references or pointers pointing to that particular object. When the reference count of an object reaches zero, it means that no references exist to that object, indicating that it is no longer reachable and can be safely deallocated."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.img,{alt:"Garbage collection",src:a(25987).A+"",width:"717",height:"166"}),(0,t.jsx)(r.br,{}),"\n","Source: ",(0,t.jsx)(r.a,{href:"https://book.huihoo.com/data-structures-and-algorithms-with-object-oriented-design-patterns-in-java/html/page421.html",children:"https://book.huihoo.com/data-structures-and-algorithms-with-object-oriented-design-patterns-in-java/html/page421.html"})," (with modification)"]}),"\n",(0,t.jsx)(r.h4,{id:"virtual-memory",children:"Virtual Memory"}),"\n",(0,t.jsx)(r.p,{children:"Virtual memory is a memory management technique used by operating systems to provide an illusion of having more memory than is physically available in a computer system."}),"\n",(0,t.jsxs)(r.p,{children:["In a computer system, the physical primary memory (RAM) is finite, and programs require memory to store their instructions and data during execution. Virtual memory allows the operating system to allocate memory to programs in smaller, fixed-size units called ",(0,t.jsx)(r.strong,{children:"pages"}),", the process is called ",(0,t.jsx)(r.strong,{children:"paging"}),". These pages can be stored in both physical memory and secondary storage, such as a hard disk."]}),"\n",(0,t.jsxs)(r.p,{children:["Virtual memory logically combines primary and secondary memory to provide large contiguous memory space for programs to access. The OS component is responsible for mapping the virtual address space of a program to the physical memory or disk space, the mapping is stored in a data structure called ",(0,t.jsx)(r.strong,{children:"page table"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:["When a program accesses a memory location using a virtual address and that particular page is not currently present in physical memory (RAM), a ",(0,t.jsx)(r.strong,{children:"page fault"})," occurs. It could be possible that the required page is stored on secondary memory. To resolve this, the operating system needs to retrieve the required page and load it into physical memory to allows the program to access it."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.img,{alt:"Virtual memory",src:a(94206).A+"",width:"640",height:"437"}),(0,t.jsx)(r.br,{}),"\n","Source: ",(0,t.jsx)(r.a,{href:"https://iboysoft.com/wiki/virtual-memory.html",children:"https://iboysoft.com/wiki/virtual-memory.html"})]}),"\n",(0,t.jsx)(r.h4,{id:"cache",children:"Cache"}),"\n",(0,t.jsx)(r.p,{children:"Cache is a small, high-speed memory that is located closer to the CPU (central processing unit) than the main memory (RAM). The purpose of cache is to speed up retrieval for frequently accessed resource."}),"\n",(0,t.jsxs)(r.p,{children:["When the CPU needs to read data from or write data to the main memory, it first checks the cache to see if the required data is already present. If the data is found in the cache (called ",(0,t.jsx)(r.strong,{children:"cache hit"}),"), it can be quickly accessed by the CPU without the need to access the slower main memory."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.img,{alt:"Caching in memory",src:a(83763).A+"",width:"710",height:"179"}),(0,t.jsx)(r.br,{}),"\n","Source: ",(0,t.jsx)(r.a,{href:"https://witscad.com/course/computer-architecture/chapter/cache-memory",children:"https://witscad.com/course/computer-architecture/chapter/cache-memory"})]})]})}function h(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},19479:(e,r,a)=>{a.d(r,{A:()=>n});const n=a.p+"assets/images/buffering-d7308f2726466951d67c2d504776b5df.png"},25987:(e,r,a)=>{a.d(r,{A:()=>n});const n=a.p+"assets/images/garbage-collection-c4b501d9bc4d830abf08cd3a28592d7a.png"},26033:(e,r,a)=>{a.d(r,{A:()=>n});const n=a.p+"assets/images/stack-memory-9ab2275599beef89bc768473aff14f6b.png"},28453:(e,r,a)=>{a.d(r,{R:()=>s,x:()=>o});var n=a(96540);const t={},i=n.createContext(t);function s(e){const r=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),n.createElement(i.Provider,{value:r},e.children)}},59563:(e,r,a)=>{a.d(r,{A:()=>n});const n=a.p+"assets/images/heap-memory-fa2e5b5d74ce68193babbcfa12bb618c.png"},67983:(e,r,a)=>{a.d(r,{A:()=>n});const n=a.p+"assets/images/pointer-references-754353b0361658b56e7359a9f06d86b6.png"},83763:(e,r,a)=>{a.d(r,{A:()=>n});const n=a.p+"assets/images/cache-314a460463b993bdc61d3a83b1a62e7a.png"},94206:(e,r,a)=>{a.d(r,{A:()=>n});const n=a.p+"assets/images/virtual-memory-5f2675634d232480ab5dbfb576488249.png"}}]);