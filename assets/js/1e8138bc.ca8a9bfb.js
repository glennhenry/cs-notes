"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[8222],{94179:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var r=n(85893),i=n(11151);const a={slug:"/computer-and-programming-fundamentals/interpreter",id:"interpreter",title:"Interpreter",description:"Interpreter"},s=void 0,o={id:"computer-and-programming-fundamentals/interpreter/interpreter",title:"Interpreter",description:"Interpreter",source:"@site/docs/computer-and-programming-fundamentals/16-interpreter/interpreter.md",sourceDirName:"computer-and-programming-fundamentals/16-interpreter",slug:"/computer-and-programming-fundamentals/interpreter",permalink:"/cs-notes/computer-and-programming-fundamentals/interpreter",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/computer-and-programming-fundamentals/16-interpreter/interpreter.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1704193918,formattedLastUpdatedAt:"Jan 2, 2024",frontMatter:{slug:"/computer-and-programming-fundamentals/interpreter",id:"interpreter",title:"Interpreter",description:"Interpreter"},sidebar:"sidebar",previous:{title:"Compilation",permalink:"/cs-notes/computer-and-programming-fundamentals/compilation"},next:{title:"Runtime Environment",permalink:"/cs-notes/computer-and-programming-fundamentals/runtime-environment"}},c={},l=[{value:"Compiler vs Interpreter",id:"compiler-vs-interpreter",level:3},{value:"Interpreter Process",id:"interpreter-process",level:3},{value:"JIT Compilation",id:"jit-compilation",level:3}];function d(e){const t={a:"a",br:"br",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Main Source :"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Interpreter_(computing)",children:"Interpreter (computing) - Wikipedia"})})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Just-in-time_compilation",children:"Just-in-time compilation - Wikipedia"})})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://www.freecodecamp.org/news/just-in-time-compilation-explained/",children:"Just in Time Compilation Explained - freeCodeCamp"})})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://stackoverflow.com/questions/95635/what-does-a-just-in-time-jit-compiler-do",children:"What does a just-in-time (JIT) compiler do? - stackoverflow"})})}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Interpreter"})," is a program that reads and executes source code written in a high-level language directly, without the need for prior compilation to machine language."]}),"\n",(0,r.jsx)(t.h3,{id:"compiler-vs-interpreter",children:"Compiler vs Interpreter"}),"\n",(0,r.jsxs)(t.p,{children:["A compiler takes high-level source code and translate it to lower-level language, without running it. On the other hand, an interpreter takes high-level source code, which doesn't need to be ",(0,r.jsx)(t.a,{href:"/computer-and-programming-fundamentals/compilation#language-abstraction",children:"machine language"})," and directly runs it."]}),"\n",(0,r.jsx)(t.p,{children:"An interpreter executes each statement in the source code line by line, without the need for prior translation into machine code like a compiler. The speed of execution in an interpreter can vary depending on the context. When frequently running a specific piece of code, an interpreter may execute it faster since it avoids the overhead of entire source code compilation. In contrast, a compiler initially takes time to translate the entire source code, but the resulting compiled code can execute more quickly afterwards."}),"\n",(0,r.jsxs)(t.p,{children:["Compiler solely translates code, in some case it will need an interpreter. For instance, in the case of the Java programming language, the source code is compiled into ",(0,r.jsx)(t.a,{href:"/computer-and-programming-fundamentals/compilation#language-abstraction",children:"bytecode"}),", which is an intermediate representation. This bytecode is then interpreted by the ",(0,r.jsx)(t.strong,{children:"Java Virtual Machine (JVM)"}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"interpreter-process",children:"Interpreter Process"}),"\n",(0,r.jsxs)(t.p,{children:["Some steps are quite similar to ",(0,r.jsx)(t.a,{href:"/computer-and-programming-fundamentals/compilation#compilation-process",children:"compilation process"}),"."]}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Lexical Analysis"})," : The interpreter starts by performing lexical analysis or the ",(0,r.jsx)(t.strong,{children:"tokenization process"}),". It breaks down the source code into a sequence of tokens, such as keywords, identifiers, operators, and literals. It removes whitespace, comments, and other non-essential characters."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Parsing"})," : The interpreter proceeds to the parsing phase. It analyzes the sequence of tokens according to the syntax rules of the programming language. This step involves building a representation of the code's structure, such as an ",(0,r.jsx)(t.strong,{children:"abstract syntax tree (AST)"})," (code representation in tree-like structure) or another suitable data structure. The parser ensures that the code is grammatically correct and adheres to the language's syntax rules."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Semantic Analysis"})," : Once the code has been parsed, the interpreter performs semantic analysis, which involves checking the code for semantic errors. The interpreter verifies aspects such as variable declarations, type compatibility, scoping rules, and other language-specific rules. It helps catch errors that may not be identified during parsing."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Execution"})," : After the code has been analyzed and deemed semantically correct, the interpreter proceeds to execute it. It traverses through the generated AST or data structure, interpreting each statement and performing the associated actions or operations."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"jit-compilation",children:"JIT Compilation"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Just-In-Time (JIT) compilation"})," is a technique that compiles code during execution rather than before execution. In traditional compilation, the entire source code is compiled ",(0,r.jsx)(t.strong,{children:"ahead of time (AOT)"})," into machine code, which is then executed directly by the hardware. However, in JIT compilation, the compilation process is deferred until the code is about to be executed."]}),"\n",(0,r.jsx)(t.p,{children:"JIT is typically used for language that uses intermediate representation (e.g., Java bytecode) and usually included in an interpreter. The high-level source code is compiled into bytecode. However, rather than being directly executed by the interpreter, the code is further compiled into machine code, which can be executed directly by the underlying hardware."}),"\n",(0,r.jsx)(t.p,{children:"The advantage of JIT compilation is that it can apply some runtime optimization, because it can access some of runtime information, such as the actual values of variables, the execution context."}),"\n",(0,r.jsx)(t.p,{children:"An example of runtime optimization is the function inlining. Inlining involves replacing a function call with the actual code of the called function. This eliminates the overhead of the function call itself, improving performance by reducing the stack frame (data structure used by a program's to manage function or method calls) setup and teardown."}),"\n",(0,r.jsx)(t.p,{children:"JIT compilation does have a downside related to increased startup time. This is due to the requirement of compiling the code at runtime before it can be executed, which can result in longer startup times compared to programs that are compiled ahead of time (AOT)."}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.img,{alt:"JIT compilation",src:n(73113).Z+"",width:"485",height:"322"}),(0,r.jsx)(t.br,{}),"\n","Source : ",(0,r.jsx)(t.a,{href:"https://aboullaite.me/understanding-jit-compiler-just-in-time-compiler/",children:"https://aboullaite.me/understanding-jit-compiler-just-in-time-compiler/"})]})]})}function p(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},73113:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/jit-75f78a7ad63e73b548c8c4cd50eb4427.png"},11151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>s});var r=n(67294);const i={},a=r.createContext(i);function s(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);