"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[2243],{83529:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var i=t(85893),s=t(11151);const r={slug:"/software-engineering/event-driven",id:"event-driven",title:"Event-Driven",description:"Event-Driven"},c=void 0,a={id:"software-engineering/event-driven/event-driven",title:"Event-Driven",description:"Event-Driven",source:"@site/docs/software-engineering/08-event-driven/event-driven.md",sourceDirName:"software-engineering/08-event-driven",slug:"/software-engineering/event-driven",permalink:"/cs-notes/software-engineering/event-driven",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/software-engineering/08-event-driven/event-driven.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1708786431,formattedLastUpdatedAt:"Feb 24, 2024",frontMatter:{slug:"/software-engineering/event-driven",id:"event-driven",title:"Event-Driven",description:"Event-Driven"},sidebar:"sidebar",previous:{title:"Client-Server",permalink:"/cs-notes/software-engineering/client-server"},next:{title:"Master-Slave",permalink:"/cs-notes/software-engineering/master-slave"}},o={},l=[{value:"Event Handling",id:"event-handling",level:3},{value:"Example",id:"example",level:3}];function d(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Main Source :"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Event-driven_architecture",children:"Event-driven architecture - Wikipedia"})})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/computer-and-programming-fundamentals/concurrency-and-parallelism#reactive-programming",children:"Previous notes on reactive programming"})})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Event-Driven"})," is an architecture that structures an application or system around the production, detection, and consumption of events."]}),"\n",(0,i.jsxs)(n.p,{children:["Flow of data and the triggering of actions are determined by ",(0,i.jsx)(n.strong,{children:"events"}),", which are essentially specific occurrences or changes in the system. Events are considered as notifications or signals."]}),"\n",(0,i.jsx)(n.p,{children:"Events can be generated by various sources such as user interactions, system processes, external systems, or even internal components. These events are typically asynchronous, meaning multiple events can happen at any time."}),"\n",(0,i.jsx)(n.p,{children:"An example would be a user tapping a button, while at the same time a download has finished. The app should respond to the user tap, such as navigating the screen in the case of tapping a navigation button, and also notify the user that the download has been completed."}),"\n",(0,i.jsx)(n.h3,{id:"event-handling",children:"Event Handling"}),"\n",(0,i.jsx)(n.p,{children:"The idea of event-driven architecture is, an entity in the system produces an event, and another entity handles it if necessary."}),"\n",(0,i.jsxs)(n.p,{children:["The entity responsible for generating an event is referred to as a ",(0,i.jsx)(n.strong,{children:"producer"})," (or ",(0,i.jsx)(n.strong,{children:"publisher"}),", ",(0,i.jsx)(n.strong,{children:"emitter"}),"). The event is then broadcasted to the system. The entity interested in the event is known as a ",(0,i.jsx)(n.strong,{children:"consumer"})," and should ",(0,i.jsx)(n.strong,{children:"subscribe"})," to the specific producer to receive notifications whenever an event occurs. Once the event is received, the consumer will then ",(0,i.jsx)(n.strong,{children:"consume"})," it."]}),"\n",(0,i.jsxs)(n.p,{children:["Broadcast of events are sent to ",(0,i.jsx)(n.strong,{children:"channel"}),", which is a medium for publishing and subscribing to events. It serves as a central hub where events are published by event producers and then delivered to the interested event consumers. Channel can be implemented in many ways, such as event bus or ",(0,i.jsx)(n.a,{href:"/backend-development/message-broker",children:"message broker"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.img,{alt:"An event bus",src:t(30737).Z+"",width:"830",height:"445"}),(0,i.jsx)(n.br,{}),"\n","Source : ",(0,i.jsx)(n.a,{href:"https://medium.com/elixirlabs/event-bus-implementation-s-d2854a9fafd5",children:"https://medium.com/elixirlabs/event-bus-implementation-s-d2854a9fafd5"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.img,{alt:"Message broker",src:t(87016).Z+"",width:"651",height:"219"}),(0,i.jsx)(n.br,{}),"\n","Source : ",(0,i.jsx)(n.a,{href:"https://www.vmware.com/topics/glossary/content/message-brokers.html",children:"https://www.vmware.com/topics/glossary/content/message-brokers.html"})]}),"\n",(0,i.jsx)(n.p,{children:"The characteristics of event-driven architecture that decouple producer and consumer make it scalable. Event producers generate events without needing to know if there is someone interested in them. Consumers do not need to periodically check for the occurrence of events; instead, they can be notified about events they are interested in simply by subscribing to the producer."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["See also ",(0,i.jsx)(n.a,{href:"/computer-and-programming-fundamentals/concurrency-and-parallelism#reactive-programming",children:"reactive programming"}),"."]})}),"\n",(0,i.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.p,{children:"Event-driven architecture is typically used in GUI systems. A user interface has buttons which you can click to trigger some event. A theoretical GUI system that follows event-driven architecture would look like :"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"class ClickDetector {\n    val subscribers = mutableListOf<Button>()\n\n    fun addSubscriber(btn: Button) {\n        subscribers.add(btn)\n    }\n\n    fun removeSubscriber(btn: Button) {\n        subscribers.remove(btn)\n    }\n\n    fun didUserClick(): Boolean {\n        return true\n    }\n\n    fun notifySubscribers() {\n        for (subs in subscribers) {\n            subs.click()\n        }\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ClickDetector"})," class is responsible for detecting click and notifying all the subscribers. The ",(0,i.jsx)(n.code,{children:"didUserClick"})," is a simplified implementation of click detection."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"class Button {\n    private var listener: (() -> Unit)? = null\n\n    fun setOnClickListener(listener: () -> Unit) {\n        this.listener = listener\n    }\n\n    fun click() {\n        listener?.invoke()\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The button class consist of ",(0,i.jsx)(n.code,{children:"listener"}),", which is a lambda expression or function that is initially null. This mean initially button won't do anything if clicked. To actually set an action to do when a button is clicked, we provide the lambda and set it from the ",(0,i.jsx)(n.code,{children:"setOnClickListener"})," method. The ",(0,i.jsx)(n.code,{children:"click"})," method invoke the listener that we have set, which will be called from the ",(0,i.jsx)(n.code,{children:"ClickDetector"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Sample usage :"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'fun main() {\n    val clickDetector = ClickDetector()\n\n    val button = Button()\n    button.setOnClickListener {\n        println("Button clicked!")\n    }\n    clickDetector.addSubscriber(button)\n\n    while (true) {\n        if (clickDetector.didUserClick()) {\n            clickDetector.notifySubscribers()\n        }\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:['The action we set whenever a button is clicked is to print "Button clicked!". Again, this is a simplified implementation, the actual logic of ',(0,i.jsx)(n.code,{children:"didUserClick"})," may involve asking mouse click from OS."]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["See also ",(0,i.jsx)(n.a,{href:"/software-engineering/behavioral-patterns#observer",children:"observer design pattern"}),"."]})})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},30737:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/event-bus-33b81adec97546c587513885c4761539.png"},87016:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/message-broker-6ce66a6b75d4d65bfcc55cb2639428f3.png"},11151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>c});var i=t(67294);const s={},r=i.createContext(s);function c(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);