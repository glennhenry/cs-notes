"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[202],{35151:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var i=t(85893),s=t(11151);const r={slug:"/programming-language-theory/data-types",id:"data-types",title:"Data Types",description:"Data Types"},a=void 0,o={id:"programming-language-theory/data-types/data-types",title:"Data Types",description:"Data Types",source:"@site/docs/programming-language-theory/08-data-types/data-types.md",sourceDirName:"programming-language-theory/08-data-types",slug:"/programming-language-theory/data-types",permalink:"/cs-notes/programming-language-theory/data-types",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/programming-language-theory/08-data-types/data-types.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1712830759,formattedLastUpdatedAt:"Apr 11, 2024",frontMatter:{slug:"/programming-language-theory/data-types",id:"data-types",title:"Data Types",description:"Data Types"},sidebar:"sidebar",previous:{title:"Control Flow",permalink:"/cs-notes/programming-language-theory/control-flow"},next:{title:"Subroutines",permalink:"/cs-notes/programming-language-theory/subroutines"}},l={},c=[{value:"Type Systems",id:"type-systems",level:3},{value:"Polymorphism",id:"polymorphism",level:4},{value:"Classification of Types",id:"classification-of-types",level:4},{value:"Orthogonality",id:"orthogonality",level:4},{value:"Type Checking",id:"type-checking",level:3},{value:"Type Equivalence",id:"type-equivalence",level:4},{value:"Type Conversion",id:"type-conversion",level:4},{value:"Type Compatibility",id:"type-compatibility",level:4},{value:"Type Inference",id:"type-inference",level:4},{value:"Structs &amp; Unions",id:"structs--unions",level:3},{value:"Arrays",id:"arrays",level:3},{value:"Strings",id:"strings",level:3},{value:"Sets",id:"sets",level:3},{value:"Pointers &amp; Recursive Types",id:"pointers--recursive-types",level:3},{value:"Lists",id:"lists",level:3},{value:"Files I/O",id:"files-io",level:3},{value:"Equality Testing &amp; Assignment",id:"equality-testing--assignment",level:3}];function d(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Main Source :"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Book chapter 7"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Data type is a classification or categorization of data that determines the type of values that a variable can hold, the operations that can be performed on those values, and the way the values are represented in memory."}),"\n",(0,i.jsx)(n.h3,{id:"type-systems",children:"Type Systems"}),"\n",(0,i.jsx)(n.p,{children:"Type system is a set of rules, constraints, and mechanisms in programming languages that define and enforce the types of values and expressions used in a program. It consists of :"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Built-in types"})," (also called primitive or predefined types), common types include boolean, integer, char, float, double, etc. These are typically supported in hardware."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mechanism to declare and define new types"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rules for type equivalence"}),", how to decide if one name is the same type of another name."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type compatibility"}),", what operation can be performed on some types."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type conversion"}),", a way to convert one type to another, explicitly or implicitly."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type inference"}),", an optional feature to automatically deduces the types of expressions and variables without explicit type annotations."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["With a type system, compilers determine the appropriate operation to perform on operands. For example, if ",(0,i.jsx)(n.code,{children:"a"})," and ",(0,i.jsx)(n.code,{children:"b"})," are integers, then ",(0,i.jsx)(n.code,{children:"a + b"})," will result in an integer addition. If ",(0,i.jsx)(n.code,{children:"b"})," is a floating-point number, the compiler checks whether addition between an integer and a floating-point number is allowed or defined by the user. If both answers are negative, the compiler may choose to throw an error or implicitly convert one type to another."]}),"\n",(0,i.jsx)(n.p,{children:"Some term about type system :"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Strong typing vs weak typing"})," : A strongly typed language will never convert one type to another when the operation between them are not supported. Weak typed language may perform this if needed, which can potentially lead to unexpected errors."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Static typing vs dynamic typing"})," : A statically typed language does type checking at compile-time, which results in variable must be annotated by its type (expect if it has type inference) when declared. Dynamic typed is the opposite, it does type checking at runtime, and variable doesn't require explicit type annotation. By checking the type at runtime, a variable can hold different type of values during the execution of the program."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"polymorphism",children:"Polymorphism"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"/computer-and-programming-fundamentals/object-oriented-programming#polymorphism",children:"Polymorphism"})," allows for entities (variables, functions, etc.) to have multiple types or behave differently depending on the types of their arguments."]}),"\n",(0,i.jsx)(n.p,{children:"While polymorphism depends on type it operates on, it doesn't always imply type checking is done at runtime."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A straightforward ",(0,i.jsx)(n.strong,{children:"ad-hoc polymorphism"})," like function/method overloading, in which multiple functions have the same name, but has different argument(s) or type of the argument(s). Compiler can distinguish between them by comparing the number of parameters or type of the parameters."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Subtype polymorphism"})," allows a subtype to be used where a supertype is expected. This may be encountered in ",(0,i.jsx)(n.a,{href:"/computer-and-programming-fundamentals/object-oriented-programming",children:"OOP"})," languages, where exists concept like inheritance that allows objects of different classes or types to be treated uniformly through common interfaces or base classes."]}),"\n",(0,i.jsxs)(n.li,{children:["A situation where single function or data structure can operate on values of different types, this is called ",(0,i.jsx)(n.strong,{children:"parametric polymorphism"}),". It may be explicit (often known as generics), where programmer specifies the function that can work on some types and another; or implicit (often known as type inference), where the compiler infer the type parameters it works on."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"classification-of-types",children:"Classification of Types"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Numeric Types"})," : Represent numerical values. They include integer types (such as int, long, short) for representing whole numbers, floating-point types (such as float, double) for representing decimal numbers, and sometimes additional types like byte, decimal, complex numbers."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Enumeration Types"})," : Enumeration types define a set of named values. They represent a finite set of distinct options or choices. Each value in an enumeration type is typically assigned an integer (called ordinal value) as an underlying representation. Enums provide a way to express a set of related constants and make the code more readable and expressive."]}),"\n",(0,i.jsx)(n.p,{children:"For example, enum in C++ :"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"enum class Color { RED, GREEN, BLUE };\nColor myColor = Color::GREEN;\n\n// Using the enum values\nif (myColor == Color::RED)\n    // ...\n"})}),"\n",(0,i.jsx)(n.p,{children:"Under the hood, integer comparison are going on."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Subranges Types"})," : Subrange types allow to define a subset of values within a range of values. For example, a subrange type ",(0,i.jsx)(n.code,{children:"Age"})," may restrict values to be within a specific range, like 0 to 120. Pascal language is first to implement subrange type, for example, we can define : ",(0,i.jsx)(n.code,{children:"type test_score = 0..100;"}),", restricting it to only be defined under the range of 0 to 100."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Composite Types"})," : Composite types are types that are composed of multiple values or subtypes. They are created with type constructor and used to represent structured or compound data. Examples of composite are arrays, lists, tuples, records, structs, classes, and objects. Composite types allow grouping related data together, making it easier to organize."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"orthogonality",children:"Orthogonality"}),"\n",(0,i.jsx)(n.p,{children:"Orthogonality is a characteristic of an entity having independent and non-overlapping features or dimensions. An orthogonal type system has independent type features that can be combined in many ways without restrictions or conflicts. In other word, changing feature A doesn't affect feature B. To achieve orthogonality, types need to be well-defined and clear meaning, without being ambiguous with others."}),"\n",(0,i.jsx)(n.p,{children:"For example, a language can support variable being mutable or immutable and nullable or non-nullable."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"mutable x: Int; // mutable variable, non-nullable\nimmutable x: Int; // mutable variable, non-nullable\nmutable x?: Int; // mutable variable, nullable\nimmutable x?: Int; // mutable variable, nullable\n"})}),"\n",(0,i.jsx)(n.p,{children:"We can say immutability is the orthogonal features of this language and the nullable types as the orthogonal feature of the type system."}),"\n",(0,i.jsx)(n.h3,{id:"type-checking",children:"Type Checking"}),"\n",(0,i.jsx)(n.p,{children:"Type checking involves verifying that the types of operands in an operation or expression are compatible, converting between them if necessary, and determining a possibly new type after the operation."}),"\n",(0,i.jsx)(n.h4,{id:"type-equivalence",children:"Type Equivalence"}),"\n",(0,i.jsx)(n.p,{children:"Two types are considered equivalent according to structural equivalence and name equivalence."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Structural Equivalence"})," : Structural equivalence compares the structure of two types to determine if they have the same composition of fields, methods, and properties. It looks at the internal structure of types, disregarding their names or declarations."]}),"\n",(0,i.jsx)(n.p,{children:"The compiler compares their order of declaration, formatting, and evaluate any expression."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// All these three are same.\nstruct Person {\n    int age;\n    string name;\n};\n\nstruct Person {\n    string name;\n    int age;\n};\n\nstruct Person { int age; string name; };\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Another example is the subrange type : ",(0,i.jsx)(n.code,{children:"type test_score = 0..100;"})," should be same as ",(0,i.jsx)(n.code,{children:"type test_score = 0..10*10;"})," (10 times 10), but different with ",(0,i.jsx)(n.code,{children:"type test_score = 0..99;"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Name Equivalence"})," : Name equivalence compares types based on their names or declarations. It assumes that programmer that writes two types definition treat these types differently. If two types have the same name, they are considered equivalent regardless of their internal structure."]}),"\n",(0,i.jsxs)(n.p,{children:["A language is said to have ",(0,i.jsx)(n.strong,{children:"strict name equivalence"})," if aliased types are considered distinct from each other, otherwise, if they are considered equivalent, it is said to have ",(0,i.jsx)(n.strong,{children:"loose name equivalence"}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Aliased types or type aliases allow programmer to create alternative names or aliases for existing types. We can define type alias like ",(0,i.jsx)(n.code,{children:"using age = int"})," in C++. This defines a new type ",(0,i.jsx)(n.code,{children:"age"})," that can be used just like a normal type, but it is actually just an ",(0,i.jsx)(n.code,{children:"int"}),"."]})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"type-conversion",children:"Type Conversion"}),"\n",(0,i.jsx)(n.p,{children:"Type conversion involves changing the type of a value from one data type to another, it can be done explicitly by the programmer (also called type cast), or implicitly by the compiler (also called type coercion)."}),"\n",(0,i.jsx)(n.p,{children:"There are three case in conversion :"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"In languages that use name equivalence, two types are considered the same if they have the same name, regardless of their structural differences. This means that if two types have different names but are structurally equivalent, they are considered interchangeable in terms of type conversions, because they have the same representation under the hood."}),"\n",(0,i.jsx)(n.li,{children:"A potentially unsafe type checking that occurs during runtime, that is when two types are different, but they can be represented as other depending on the actual value in runtime. For example, two subrange types are different, but one subrange is just subrange of another."}),"\n",(0,i.jsx)(n.li,{children:"Types have different low-level representation, but we can define conversion between them."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For example, integer (typically 4 bytes) is a whole number, while double type (typically 8 bytes) is an ",(0,i.jsx)(n.a,{href:"/computer-and-programming-fundamentals/floating-number#floating-number-representation",children:"IEEE floating-point representation"})," with 15 decimal points of precision."]}),"\n",(0,i.jsxs)(n.p,{children:["If that integer were to be converted into double, then this would be no problem because double is essentially more precise than an integer. It would be only converting it into larger data types by adding more bit. This is also called ",(0,i.jsx)(n.strong,{children:"type promotion"})," or ",(0,i.jsx)(n.strong,{children:"widening conversion"}),". Type promotion is typically performed implicitly by the programming language without requiring explicit syntax or cast operators."]}),"\n",(0,i.jsxs)(n.p,{children:["On the other hand, a double conversion into integer is called ",(0,i.jsx)(n.strong,{children:"type demotion"})," or ",(0,i.jsx)(n.strong,{children:"narrowing conversion"}),". Type demotion can result in potential data loss or truncation, as the value may not fit within the smaller type's range or precision. Therefore, type demotion usually requires explicit casting or conversion operations to indicate that the programmer is aware of the potential loss of information."]}),"\n",(0,i.jsxs)(n.p,{children:['For example, converting an integer to a double is "as simple as adding .0" to the number (i.e., ',(0,i.jsx)(n.code,{children:"5"})," becomes ",(0,i.jsx)(n.code,{children:"5.0"}),"). Conversely, converting a double to an integer involves removing the decimal point (i.e., ",(0,i.jsx)(n.code,{children:"5.3"})," becomes ",(0,i.jsx)(n.code,{children:"5"}),"), which results in losing some information."]}),"\n",(0,i.jsx)(n.h4,{id:"type-compatibility",children:"Type Compatibility"}),"\n",(0,i.jsxs)(n.p,{children:["Type doesn't have to be same to be operated together. In other word, both operands must be at least compatible. The compatibility between types can be defined by the language or sometimes by the user. When it is defined by the language, the compiler can implicitly do the type conversion, this is known as ",(0,i.jsx)(n.strong,{children:"type coercion"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Some coercion can be helpful or even lead to an unexpected behavior. For example, it may make sense to allow addition of a string with an integer, this will append the integer to the string. For example, ",(0,i.jsx)(n.code,{children:'"a string" + 1 = "a string1"'}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"In type coercion, the compiler typically prioritizes one conversion over another. For example, in an addition between an integer and a double, the compiler would convert the integer to a double instead of the opposite, in order to avoid information loss."})}),"\n",(0,i.jsx)(n.p,{children:"Other coercion are :"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Integer to boolean : 0 is false, anything not 0 is true (C language)"}),"\n",(0,i.jsx)(n.li,{children:"Truthy and falsy values : In Python, values such as non-zero numeric values, non-empty sequences (e.g., strings, lists, tuples), non-empty containers (e.g., dictionaries, sets) are considered as True."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"We can define our own coercion by overloading operators or overloading the conversion itself. In C++ :"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"class MyInt {\nprivate:\n    int value;\npublic:\n    MyInt(int val) : value(val) {}\n\n    operator int() const {\n        return value;\n    }\n\n    MyInt operator+(const MyInt& other) const {\n        return MyInt(value + other.value);\n    }\n};\n\nint main() {\n    MyInt myInt(42);\n    int regularInt = myInt;  // Implicit conversion using the conversion operator\n    // regularInt now holds the value of myInt\n\n    return 0;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"MyInt"})," simply holds an ",(0,i.jsx)(n.code,{children:"int"}),", but it cannot be coerced or operated with a normal ",(0,i.jsx)(n.code,{children:"int"}),". To enable such operations, we overload the conversion operator to convert ",(0,i.jsx)(n.code,{children:"MyInt"})," to an integer using ",(0,i.jsx)(n.code,{children:"operator int()"})," (called automatically by the compiler), and we also overload the ",(0,i.jsx)(n.code,{children:"+"})," operator to perform addition between two ",(0,i.jsx)(n.code,{children:"MyInt"})," objects. Additionally, we can define other operations between a ",(0,i.jsx)(n.code,{children:"MyInt"})," object and a regular integer or even other types."]}),"\n",(0,i.jsx)(n.h4,{id:"type-inference",children:"Type Inference"}),"\n",(0,i.jsx)(n.p,{children:"Some expressions are straightforward to deduce the resulting type. Arithmetic operation typically yield the same type as the operands, comparison typically produces boolean, and assignment can be inferred based on the expression being assigned to it. For example, if right-hand side assignment is addition of integer and double, resulting type will be double (assuming integer is converted into double)."}),"\n",(0,i.jsx)(n.h3,{id:"structs--unions",children:"Structs & Unions"}),"\n",(0,i.jsx)(n.p,{children:"Structs (also known as records) are used to define custom data types that encapsulate related data fields or members. A union is a special data type that allows different data types to be stored in the same memory location. This mean, union allocate memory that is shared among all its members. As a result, only one member of the union can be stored and accessed at a time. The union will accommodate size for the largest member within the union."}),"\n",(0,i.jsxs)(n.p,{children:["As seen before, the syntax of declaring a named struct (or union with ",(0,i.jsx)(n.code,{children:"union"})," keyword instead of ",(0,i.jsx)(n.code,{children:"struct"}),") in C++ is like :"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"struct StructName {\n    type1 member1;\n    type2 member2;\n    // ...\n    typeN memberN;\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:"In memory, struct will be stored in memory layout like below."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.img,{alt:"Struct in memory",src:t(6799).Z+"",width:"1007",height:"437"}),(0,i.jsx)(n.br,{}),"\n","Source : ",(0,i.jsx)(n.a,{href:"https://nerdyelectronics.com/memory-layout-of-a-structure/",children:"https://nerdyelectronics.com/memory-layout-of-a-structure/"})]}),"\n",(0,i.jsxs)(n.p,{children:["This is an array of ",(0,i.jsx)(n.code,{children:"room"})," structs, each containing 2 ints and 2 floats, with each element having a size of 4 bytes. The fields of struct are stored next to each other in memory. Some structs may have larger size than they should be, due to ",(0,i.jsx)(n.a,{href:"/computer-organization-and-architecture/coa-fundamentals#padding",children:"data alignment"})," with padding."]}),"\n",(0,i.jsx)(n.p,{children:"Memory allocation of struct and union :"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.img,{alt:"Struct vs union memory allocation",src:t(55098).Z+"",width:"748",height:"339"}),(0,i.jsx)(n.br,{}),"\n","Source : ",(0,i.jsx)(n.a,{href:"https://fastbitlab.com/microcontroller-embedded-c-programming-lecture-157-unions/",children:"https://fastbitlab.com/microcontroller-embedded-c-programming-lecture-157-unions/"})," (with modification)"]}),"\n",(0,i.jsx)(n.h3,{id:"arrays",children:"Arrays"}),"\n",(0,i.jsx)(n.h3,{id:"strings",children:"Strings"}),"\n",(0,i.jsx)(n.h3,{id:"sets",children:"Sets"}),"\n",(0,i.jsx)(n.h3,{id:"pointers--recursive-types",children:"Pointers & Recursive Types"}),"\n",(0,i.jsx)(n.h3,{id:"lists",children:"Lists"}),"\n",(0,i.jsx)(n.h3,{id:"files-io",children:"Files I/O"}),"\n",(0,i.jsx)(n.h3,{id:"equality-testing--assignment",children:"Equality Testing & Assignment"})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},6799:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/struct-in-memory-7894986421a5736c383438a99e161dcd.png"},55098:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/struct-vs-union-in-memory-999095d7ff00cc41d7994a105e8ce083.png"},11151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>a});var i=t(67294);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);