"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[8116],{71595:(e,s,a)=>{a.r(s),a.d(s,{assets:()=>l,contentTitle:()=>h,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var t=a(85893),n=a(11151);const i={slug:"/data-structures-and-algorithms/hash-table",id:"hash-table",title:"Hash Table",description:"Hash Table"},h=void 0,r={id:"data-structures-and-algorithms/hash-table/hash-table",title:"Hash Table",description:"Hash Table",source:"@site/docs/data-structures-and-algorithms/06-hash-table/hash-table.md",sourceDirName:"data-structures-and-algorithms/06-hash-table",slug:"/data-structures-and-algorithms/hash-table",permalink:"/cs-notes/data-structures-and-algorithms/hash-table",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/data-structures-and-algorithms/06-hash-table/hash-table.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1706610644,formattedLastUpdatedAt:"Jan 30, 2024",frontMatter:{slug:"/data-structures-and-algorithms/hash-table",id:"hash-table",title:"Hash Table",description:"Hash Table"},sidebar:"sidebar",previous:{title:"Queue",permalink:"/cs-notes/data-structures-and-algorithms/queue"},next:{title:"Set",permalink:"/cs-notes/data-structures-and-algorithms/set"}},l={},c=[{value:"Implementation",id:"implementation",level:3},{value:"Hash Function",id:"hash-function",level:4},{value:"Collision",id:"collision",level:3},{value:"Example",id:"example",level:3}];function o(e){const s={a:"a",annotation:"annotation",br:"br",code:"code",h3:"h3",h4:"h4",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",mtext:"mtext",p:"p",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,n.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Main Source :"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Hash_table",children:"Hash table - Wikipedia"})})}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Hash Table"}),", also known as ",(0,t.jsx)(s.strong,{children:"hash map"}),", is a data structure where we access element based on a unique identifier called ",(0,t.jsx)(s.strong,{children:"key"}),". To add an element, we must provide a key and a ",(0,t.jsx)(s.strong,{children:"value"}),", which contains the actual value of the element. To retrieve back an element, we will need to access it with the associated key, which is the same key used while adding the element."]}),"\n",(0,t.jsx)(s.h3,{id:"implementation",children:"Implementation"}),"\n",(0,t.jsxs)(s.p,{children:["Hash table is a very efficient data structure, it is similar to ",(0,t.jsx)(s.a,{href:"/data-structures-and-algorithms/array",children:"array"}),", it provides an efficient retrieval of an element in constant O(1) time. While array uses index to retrieve specific element, it can change anytime when we modify the array. Hash table uses a unique identifier and this identifier will always map to the same value."]}),"\n",(0,t.jsx)(s.p,{children:"Under the hood, hash table is implemented using an array. Array with a pre-determined size will be allocated in the memory. Every value associated with a key will be stored in that array. The key act as a determinant that will determine in which position in the array should we store the value. This is why the key should be unique, to ensure the hash table doesn't store different value in the same position in the array."}),"\n",(0,t.jsxs)(s.p,{children:["However, we don't use key directly to decide the position of value in the array, we will use something called ",(0,t.jsx)(s.strong,{children:"hash function"}),"."]}),"\n",(0,t.jsx)(s.h4,{id:"hash-function",children:"Hash Function"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.a,{href:"/computer-security/hash-function",children:"Hash function"})})," is a mathematical function that takes input and output a ",(0,t.jsx)(s.strong,{children:"hash code"}),", which is an integer value that can be used as the index of the element in the array. Depending on the hash function logic, the key used as the input doesn't have to be number. The hash function's implementation handles the conversion to a numerical hash code."]}),"\n",(0,t.jsxs)(s.p,{children:["Hash function used doesn't have to be an advanced cryptographic function, the point is, it must be able to produce a good distribution of hash codes, minimizing the chance of different key producing same hash code. When different key produced same hash code, therefore having same index in the array, this is called ",(0,t.jsx)(s.strong,{children:"collision"}),"."]}),"\n",(0,t.jsx)(s.h3,{id:"collision",children:"Collision"}),"\n",(0,t.jsxs)(s.p,{children:["There are many techniques to mitigate collision in hash table, one of the technique is ",(0,t.jsx)(s.strong,{children:"chaining"}),". Chaining is a technique where in the array inside the hash table, a ",(0,t.jsx)(s.a,{href:"/data-structures-and-algorithms/linked-list",children:"linked list"})," is used. Linked list provide a way to chain together collided element, so that when an element collide, it will be appended to the list."]}),"\n",(0,t.jsx)(s.p,{children:"Another technique to mitigate collision, which is a trivial one is just increasing the array size. Hash function generates hash code which will be used to represent index in the array, the hash function typically consider the size of array, this is to ensure the hash function doesn't produce out of bound index. By increasing the array size, we can lower the chance for collision."}),"\n",(0,t.jsx)(s.h3,{id:"example",children:"Example"}),"\n",(0,t.jsxs)(s.p,{children:["One of a simple hash function for hash table is the ",(0,t.jsx)(s.strong,{children:"division hash function"}),". The formula is :",(0,t.jsx)(s.br,{}),"\n",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mtext,{children:"hash\xa0code"}),(0,t.jsx)(s.mo,{children:"="}),(0,t.jsx)(s.mtext,{children:"key\xa0"}),(0,t.jsx)(s.mi,{mathvariant:"normal",children:"%"}),(0,t.jsx)(s.mtext,{children:"\xa0array\xa0size"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\text{hash code} = \\text{key } \\% \\text{ array size}"})]})})}),(0,t.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"0.6944em"}}),(0,t.jsx)(s.span,{className:"mord text",children:(0,t.jsx)(s.span,{className:"mord",children:"hash\xa0code"})}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(s.span,{className:"mrel",children:"="}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"0.9444em",verticalAlign:"-0.1944em"}}),(0,t.jsx)(s.span,{className:"mord text",children:(0,t.jsx)(s.span,{className:"mord",children:"key\xa0"})}),(0,t.jsx)(s.span,{className:"mord",children:"%"}),(0,t.jsx)(s.span,{className:"mord text",children:(0,t.jsx)(s.span,{className:"mord",children:"\xa0array\xa0size"})})]})]})]}),(0,t.jsx)(s.br,{}),"\n","The hash code for some key will be obtained by calculating the remainder (% modulo) of dividing the key by the array size."]}),"\n",(0,t.jsxs)(s.p,{children:["For example, when we have ",(0,t.jsx)(s.code,{children:"key = 10"})," and the ",(0,t.jsx)(s.code,{children:"array size = 1000"}),", the hash code will be ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mn,{children:"10"}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mi,{mathvariant:"normal",children:"%"}),(0,t.jsx)(s.mtext,{children:"\xa0"}),(0,t.jsx)(s.mn,{children:"1000"}),(0,t.jsx)(s.mo,{children:"="}),(0,t.jsx)(s.mn,{children:"3"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"10 \\space \\% \\space 1000 = 3"})]})})}),(0,t.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"0.8056em",verticalAlign:"-0.0556em"}}),(0,t.jsx)(s.span,{className:"mord",children:"10"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mord",children:"%"}),(0,t.jsx)(s.span,{className:"mspace",children:"\xa0"}),(0,t.jsx)(s.span,{className:"mord",children:"1000"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(s.span,{className:"mrel",children:"="}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"0.6444em"}}),(0,t.jsx)(s.span,{className:"mord",children:"3"})]})]})]}),", which mean the value associated with the key will be stored in the index 3 of the array."]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{alt:"Hash table illustration",src:a(2938).Z+"",width:"1283",height:"679"})}),"\n",(0,t.jsx)(s.p,{children:"Lastly, we may also put the key inside the array, so that we can identify which key does a value belong to."})]})}function d(e={}){const{wrapper:s}={...(0,n.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},2938:(e,s,a)=>{a.d(s,{Z:()=>t});const t=a.p+"assets/images/hash-table-illustration-3ef88b6bf5dcde303df2f608fdcaef83.png"},11151:(e,s,a)=>{a.d(s,{Z:()=>r,a:()=>h});var t=a(67294);const n={},i=t.createContext(n);function h(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:h(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);