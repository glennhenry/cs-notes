"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[9980],{2895:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/process-queue-33e72e5127a8729b9ffc2a225fa7458c.png"},4679:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/fcfs-d44b7bc07f9481c0fe8b843489fea41d.png"},9943:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"operating-system/process-management/process-management","title":"Process Management","description":"Process Management","source":"@site/docs/operating-system/03-process-management/process-management.md","sourceDirName":"operating-system/03-process-management","slug":"/operating-system/process-management","permalink":"/cs-notes/operating-system/process-management","draft":false,"unlisted":false,"editUrl":"https://github.com/glennhenry/cs-notes/tree/main/docs/operating-system/03-process-management/process-management.md","tags":[],"version":"current","lastUpdatedBy":"glennhenry","lastUpdatedAt":1723455088000,"frontMatter":{"slug":"/operating-system/process-management","id":"process-management","title":"Process Management","description":"Process Management"},"sidebar":"sidebar","previous":{"title":"Kernel","permalink":"/cs-notes/operating-system/kernel"},"next":{"title":"Multithreading","permalink":"/cs-notes/operating-system/multithreading"}}');var r=t(74848),n=t(28453);const o={slug:"/operating-system/process-management",id:"process-management",title:"Process Management",description:"Process Management"},a=void 0,c={},h=[{value:"Process &amp; Thread",id:"process--thread",level:3},{value:"PCB",id:"pcb",level:4},{value:"Thread",id:"thread",level:4},{value:"Multitasking",id:"multitasking",level:3},{value:"Process State",id:"process-state",level:3},{value:"Process Scheduling",id:"process-scheduling",level:3},{value:"CPU-I/O Burst Cycle",id:"cpu-io-burst-cycle",level:4},{value:"Process Queue",id:"process-queue",level:4},{value:"Process Scheduler",id:"process-scheduler",level:4},{value:"Context Switch",id:"context-switch",level:4},{value:"Process Attributes",id:"process-attributes",level:4},{value:"Scheduling Algorithms",id:"scheduling-algorithms",level:4},{value:"Scheduling Problems",id:"scheduling-problems",level:4},{value:"Priority Inversion",id:"priority-inversion",level:5}];function l(e){const s={a:"a",br:"br",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Main Source:"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Process_management_(computing)",children:"Process (computing) \u2014 Wikipedia"})})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Process_management",children:"Process management (computing) \u2014 Wikipedia"})})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Scheduling_(computing)",children:"Scheduling (computing) \u2014 Wikipedia"})})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Context_switch",children:"Context switch \u2014 Wikipedia"})})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.strong,{children:"[Chapter 6 CPU Scheduling - Abraham Silberschatz-Operating System Concepts (9th,2012_12)]"})}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Process Management"})," is a fundamental component of an operating system that involves the management and control of processes."]}),"\n",(0,r.jsx)(s.h3,{id:"process--thread",children:"Process & Thread"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Process"})," is an instance of a program that is being executed by a computer system. To execute a program, the program's code and data will need to be loaded into the memory. This mean each process will have its own memory space and system resources allocated to it."]}),"\n",(0,r.jsxs)(s.p,{children:["Processes are isolated from each other, meaning they cannot directly access each other's memory or resources. However, they can still communicate through an ",(0,r.jsx)(s.a,{href:"/operating-system/inter-process-communication",children:"inter-process communication (IPC)"})," if they need to share data or information."]}),"\n",(0,r.jsx)(s.h4,{id:"pcb",children:"PCB"}),"\n",(0,r.jsxs)(s.p,{children:["Process has many information associated with it, individual process is organized in a data structure called ",(0,r.jsx)(s.strong,{children:"Process Control Block (PCB)"}),", which contains ",(0,r.jsx)(s.a,{href:"#process-state",children:"process state"}),", ",(0,r.jsx)(s.strong,{children:"process identifier (PID)"}),", various registers such as ",(0,r.jsx)(s.a,{href:"/computer-organization-and-architecture/registers-and-ram#type-of-registers",children:"program counter"}),", etc."]}),"\n",(0,r.jsxs)(s.p,{children:["Those individual process are organized together with the ",(0,r.jsx)(s.a,{href:"/data-structures-and-algorithms/linked-list",children:"linked list data structure"}),", where each process has a pointer to the next process."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.img,{alt:"PCB data structure",src:t(19809).A+"",width:"719",height:"365"}),(0,r.jsx)(s.br,{}),"\n","Source: ",(0,r.jsx)(s.a,{href:"https://byjus.com/gate/process-control-block-notes/",children:"https://byjus.com/gate/process-control-block-notes/"})]}),"\n",(0,r.jsx)(s.h4,{id:"thread",children:"Thread"}),"\n",(0,r.jsxs)(s.p,{children:["A process consists of a sequence of instructions, the unit of processing that executes instruction is called a ",(0,r.jsx)(s.strong,{children:"thread"}),". A thread represents a single sequence of instructions that can be scheduled and executed independently by the operating system."]}),"\n",(0,r.jsx)(s.p,{children:"Modern OS supports multiple threads within a single process, sharing the same memory space and system resources. Having multiple thread meaning we can execute a set of instruction much faster."}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.img,{alt:"Single and multi thread",src:t(23595).A+"",width:"565",height:"281"}),(0,r.jsx)(s.br,{}),"\n","Source: ",(0,r.jsx)(s.a,{href:"https://www.javatpoint.com/process-vs-thread",children:"https://www.javatpoint.com/process-vs-thread"})]}),"\n",(0,r.jsx)(s.p,{children:"In contrast to multiprocess, each process has different memory space"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.img,{alt:"Multiprocess",src:t(54362).A+"",width:"400",height:"309"}),(0,r.jsx)(s.br,{}),"\n","Source: ",(0,r.jsx)(s.a,{href:"https://www.javamex.com/tutorials/threads/how_threads_work.shtml",children:"https://www.javamex.com/tutorials/threads/how_threads_work.shtml"})]}),"\n",(0,r.jsx)(s.p,{children:"Threads also have their own unique thread identifier (TID). Because threads are working together, they can communicate and share data with each other within the same process by accessing or modifying the same memory and resources."}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.img,{alt:"The execution of process through various steps",src:t(31956).A+"",width:"640",height:"367"}),(0,r.jsx)(s.br,{}),"\n","Source: ",(0,r.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Process_(computing)#/media/File:Concepts-_Program_vs._Process_vs._Thread.jpg",children:"https://en.wikipedia.org/wiki/Process_(computing)#/media/File:Concepts-_Program_vs._Process_vs._Thread.jpg"}),", The execution of process through various steps"]}),"\n",(0,r.jsx)(s.h3,{id:"multitasking",children:"Multitasking"}),"\n",(0,r.jsx)(s.p,{children:"A single CPU core executes a single process at a time, meaning one program can only be run at a time. Multitasking is a technique where the CPU core switches rapidly between different processes, allocating a small-time slice to each process. This gives the impression that multiple processes are executing concurrently, even though only one process is actually being executed at any given moment."}),"\n",(0,r.jsxs)(s.p,{children:["This is made possible by ",(0,r.jsx)(s.strong,{children:"scheduling"}),", the scheduler will allocate CPU time to different processes based on various factors such as priorities, fairness, etc."]}),"\n",(0,r.jsx)(s.p,{children:"There are two types of multitasking:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Preemptive Multitasking"}),": This technique allocates CPU time to multiple processes by forcibly interrupting and suspending the execution of one process to give time to another process."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Cooperative Multitasking"}),": This technique relies on processes voluntarily yielding control to other processes. In this approach, each process is responsible for explicitly relinquishing the CPU when it has completed its task or when it wants to allow other processes to run."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["Preemptive multitasking introduces overhead as it relies on the OS to schedule and manage the execution between tasks, while cooperative multitasking manages the execution themselves. Cooperative multitasking can be an up or down, it's important to manage the execution fairly between thread, or an issue called ",(0,r.jsx)(s.a,{href:"/operating-system/multithreading#multithreading-problems",children:"starvation"})," may occur. ",(0,r.jsx)(s.a,{href:"#thread",children:(0,r.jsx)(s.strong,{children:"Thread"})})," is the construct that allows you to multitask preemptively, the construct that allows you to multitask cooperatively is called ",(0,r.jsx)(s.a,{href:"/computer-and-programming-fundamentals/concurrency#coroutine",children:(0,r.jsx)(s.strong,{children:"coroutine"})}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["When trying to switch the execution between process, the current state of process being executed will be saved, so it can be restored and resumed later. This process is called ",(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.a,{href:"#context-switch",children:"context switch"})}),"."]}),"\n",(0,r.jsx)(s.h3,{id:"process-state",children:"Process State"}),"\n",(0,r.jsx)(s.p,{children:"A process has several states which represents the current condition or status."}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"New or Created"}),': The process is in the "new" state when it is being created or initialized by the operating system. It is being loaded from secondary storage such as hard drive into main memory.']}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Ready or Waiting"}),": In this state, the process is loaded into main memory, has all required resources allocated, and is awaiting execution. It is eligible to run, but it is waiting for the CPU scheduler to allocate CPU time to it."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Running"}),': When a process is in the "running" state, it is actively being executed by the CPU. Only one process can be in the running state on a single CPU core at any given time. The CPU scheduler allocates CPU time to the process, and the process executes its instructions. The process transitions back to the "waiting" state when it is not actively executing again.']}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Blocked"}),': The process enters the "blocked" state when it cannot proceed further until a certain event or condition occurs. This could be waiting for user input, waiting for a resource to become available (e.g., waiting for I/O completion), or waiting for a signal from another process. In this state, the process is suspended, and it is not eligible for execution until the event or condition it is waiting for is satisfied. Once the condition is met, the process moves back to the "waiting" state.']}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Terminated"}),": The \"terminated\" state represents the end of the process's execution. It occurs when a process completes its execution or is explicitly terminated by the operating system or another process because of exceptions. In this state, the process is no longer running or eligible for execution. The operating system releases the resources held by the terminated process, removes it from the system's process table, and cleans up associated resources in the main memory."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.img,{alt:"Process state",src:t(60037).A+"",width:"300",height:"300"}),(0,r.jsx)(s.br,{}),"\n","Source: ",(0,r.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Process_(computing)#/media/File:Process_states.svg",children:"https://en.wikipedia.org/wiki/Process_(computing)#/media/File:Process_states.svg"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"process-scheduling",children:"Process Scheduling"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Scheduling"})," is the process of determining the order in which tasks or processes are executed on the CPU. Since the CPU can only execute one task at a time, scheduling determines which task gets CPU time and for how long. Scheduling is important for multitasking, where multiple programs are executed at a time, and it is essential to ensure fair execution for all of them."]}),"\n",(0,r.jsx)(s.p,{children:"Efficient scheduling scenario:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Throughput is high"}),": The scheduler maximizes the number of tasks completed within a given time frame."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"CPU utilization is high, or wait time is short"}),": The scheduler keeps the CPU busy by promptly assigning tasks to it, minimizing idle time. When a program is waiting for an I/O operation to complete, instead of wasting time on waiting and doing nothing, it is more efficient to allow other programs to execute in the meantime."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Response time is low"}),": Interactive tasks or user interface interactions receive quick CPU time, ensuring a responsive system. In an efficient scheduling scenario, interactions from user such as clicking a button should be given high priority, thus will minimize response time and improve the user experience."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Fairness is maintained"}),": Each program or process is allocated a reasonable share of CPU time, preventing starvation, which is the case when a process or task is unable to make progress to complete its execution. In a priority-based scheduling, fairness is a classic problem. The idea of priority is that tasks with higher priority should be executed first. However, if there exist many high priority task, the lower-priority task may not have the opportunity to complete."]}),"\n"]}),"\n",(0,r.jsx)(s.h4,{id:"cpu-io-burst-cycle",children:"CPU-I/O Burst Cycle"}),"\n",(0,r.jsx)(s.p,{children:"The CPU-I/O burst cycle is the alternating pattern of CPU computation and I/O operations that occur during the execution of a program or process. The CPU burst actively utilizes the CPU for computation or processing tasks. The I/O burst phase initiates input/output operations, this phase causes the CPU to wait."}),"\n",(0,r.jsx)(s.p,{children:"This cycle can be inefficient, as it leads to long wait times and underutilization of resources."}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{alt:"CPU-I/O burst",src:t(72958).A+"",width:"885",height:"484"})}),"\n",(0,r.jsx)(s.h4,{id:"process-queue",children:"Process Queue"}),"\n",(0,r.jsx)(s.p,{children:"Running processes are stored in queue based on their current state. For example, processes that are in ready state are put in ready queue."}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.img,{alt:"Process queue",src:t(2895).A+"",width:"663",height:"230"}),(0,r.jsx)(s.br,{}),"\n","Source: ",(0,r.jsx)(s.a,{href:"https://byjus.com/gate/process-scheduling-in-operating-system-notes/",children:"https://byjus.com/gate/process-scheduling-in-operating-system-notes/"})]}),"\n",(0,r.jsx)(s.p,{children:"The job queue consists of all processes awaiting execution. It represents a queue of tasks or jobs that are submitted to the system for processing. Process in I/O queue is waiting for I/O completion."}),"\n",(0,r.jsx)(s.h4,{id:"process-scheduler",children:"Process Scheduler"}),"\n",(0,r.jsx)(s.p,{children:"The process scheduler is responsible for determining the execution order and allocation of system resources to processes. Based on how often scheduling decision is made, there are 3 time frames:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Short-Term Scheduling (CPU Scheduling)"}),": This scheduling focuses on selecting processes from the ready queue for execution on the CPU. Its primary goal is to allocate CPU time efficiently among competing processes. Short-term scheduling decisions are made frequently, typically on the order of milliseconds or microseconds, to quickly switch between processes and provide the illusion of concurrent execution."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Medium-Term Scheduling (Process Swapping)"}),": Medium-term scheduling swap processes in and out of main memory (RAM). When the system's memory becomes heavily utilized or overloaded, the medium-term scheduler may decide to move some processes from memory to secondary storage (such as a hard disk) to free up memory space. This process is called swapping out. Later, when more memory becomes available, the medium-term scheduler may select processes from the swap area and bring them back into main memory (swapping in) for execution."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Long-Term Scheduling (Job Scheduler)"}),": Long-term scheduling focuses on deciding which processes should be admitted into the ready queue, which occurs when a new process is created. Long-term scheduling determines if the system has enough resources (CPU, memory, I/O) to accommodate the new process. Long-term scheduling helps to control the degree of multitasking, it ensures that the system does not become overwhelmed with too many processes."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h4,{id:"context-switch",children:"Context Switch"}),"\n",(0,r.jsxs)(s.p,{children:["During context switch, which is done by the ",(0,r.jsx)(s.strong,{children:"dispatcher"}),", the current state of the running process, including the contents of CPU registers, program counter, and other relevant information will be saved. This step ensures that the process can be resumed from the same point when it regains CPU execution time."]}),"\n",(0,r.jsx)(s.p,{children:"It is important for context switch to be fast as possible, because it is invoked very frequently, and during invocation the CPU does nothing."}),"\n",(0,r.jsxs)(s.p,{children:["Each process has its own ",(0,r.jsx)(s.a,{href:"#pcb",children:"PCB"}),", which holds important information about the process. When context switch occurs, the corresponding PCB of current process is accessed and modified to reflect the current state. After that, the PCB associated with the new process, is retrieved, and its relevant data, including register values, is loaded into the CPU registers."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.img,{alt:"Context switch",src:t(21982).A+"",width:"584",height:"361"}),(0,r.jsx)(s.br,{}),"\n","Source: ",(0,r.jsx)(s.a,{href:"https://byjus.com/gate/context-switching-in-os-notes/",children:"https://byjus.com/gate/context-switching-in-os-notes/"})]}),"\n",(0,r.jsx)(s.h4,{id:"process-attributes",children:"Process Attributes"}),"\n",(0,r.jsx)(s.p,{children:"Process has several attributes, in the context of process scheduling, they can be used to determine the scheduling:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Priority"}),": In priority-based scheduling, priority is the main attributes that represents the relative importance or urgency of a process compared to other processes, where the higher value indicates a higher priority process. Priority can be assigned based on factors such as system requirements, process characteristics, or user-defined criteria."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Burst Time"}),": Burst time, also known as execution time or CPU time, is the amount of time required by a process to complete its execution on the CPU. It represents the duration of time during which a process actively utilizes the CPU for computation or processing tasks. The burst time can be obtained by estimation, observation based on historical data, or tasks that are influenced by user input."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Arrival Time"}),": Time in which process arrives at the system's ready queue or scheduler. The arrival time can be used as the measurement for the start of the scheduling algorithm."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Waiting Time"}),": Waiting time is the total amount of time a process spends waiting in the ready queue before it gets the CPU for execution. It is the difference between the arrival time of the process and the time it starts executing."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Turnaround Time"}),": Turnaround time is the total time taken by a process to complete its execution, including both waiting time and burst time. It is the difference between the completion time of the process and its arrival time."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Response Time"}),": Response time is the time taken from when a process enters the system until it starts its first execution. It is particularly relevant in interactive systems, where users expect quick responses."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.img,{alt:"The process&#39; attributes",src:t(21704).A+"",width:"513",height:"291"}),(0,r.jsx)(s.br,{}),"\n","Source: ",(0,r.jsx)(s.a,{href:"https://www.shiksha.com/online-courses/articles/turnaround-time-in-cpu-scheduling/",children:"https://www.shiksha.com/online-courses/articles/turnaround-time-in-cpu-scheduling/"})," (copy and modified)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h4,{id:"scheduling-algorithms",children:"Scheduling Algorithms"}),"\n",(0,r.jsx)(s.p,{children:"There are many algorithms to schedule processes or tasks, different algorithm has different objectives and target specific aspects of process or task scheduling."}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"First in, first out (FIFO) or First come, first served (FCFS)"}),": This is the simplest algorithm, the next process to be executed is the order they arrive in the ready queue. While it is simple and easy to implement, it may result in poor average response time, especially if long-running processes are ahead in the queue."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.img,{alt:"FCFS",src:t(4679).A+"",width:"400",height:"207"}),(0,r.jsx)(s.br,{}),"\n","Source: ",(0,r.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Scheduling_(computing)#/media/File:Thread_pool.svg",children:"https://en.wikipedia.org/wiki/Scheduling_(computing)#/media/File:Thread_pool.svg"})]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Priority Scheduling"}),": Processes are assigned priorities, and the process with the highest priority is selected for execution. The priority can be anything, for example it could be deadline."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.img,{alt:"Priority scheduling",src:t(97761).A+"",width:"569",height:"280"}),(0,r.jsx)(s.br,{}),"\n","Source: ",(0,r.jsx)(s.a,{href:"https://www.embedded.com/tasks-and-scheduling/",children:"https://www.embedded.com/tasks-and-scheduling/"})]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Shortest Remaining Time First or Shortest Job First (SJF)"}),": Strategy where the process with the smallest total execution time is selected for execution next. However, this requires knowledge of the total execution time of each process (or at least estimation), which is often not available or accurate in practice."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.img,{alt:"SJF scheduling",src:t(72489).A+"",width:"1133",height:"471"}),(0,r.jsx)(s.br,{}),"\n","Source: ",(0,r.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Shortest_remaining_time",children:"https://en.wikipedia.org/wiki/Shortest_remaining_time"})]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Round Robin (RR)"}),": Each process is allocated a fixed time slice, and processes are executed circularly. This strategy provides fair sharing of CPU time among processes, however, shorter processes may still experience longer response times due to the fixed time slice."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.img,{alt:"Round Robin",src:t(71349).A+"",width:"1082",height:"402"}),(0,r.jsx)(s.br,{}),"\n","Source: ",(0,r.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Round-robin_scheduling",children:"https://en.wikipedia.org/wiki/Round-robin_scheduling"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h4,{id:"scheduling-problems",children:"Scheduling Problems"}),"\n",(0,r.jsx)(s.h5,{id:"priority-inversion",children:"Priority Inversion"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Priority Inversion"})," is a phenomenon that can occur in systems where different tasks or processes have different priorities. It refers to a situation where a lower-priority task or process holds a resource needed by a higher-priority task, thereby causing a delay in the execution of the higher-priority task."]}),"\n",(0,r.jsx)(s.p,{children:"Example scenario:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:["Three tasks/processes are involved: a ",(0,r.jsx)(s.strong,{children:"high-priority task (H)"}),", a ",(0,r.jsx)(s.strong,{children:"medium-priority task (M)"}),", and a ",(0,r.jsx)(s.strong,{children:"low-priority task (L)"}),"."]}),"\n",(0,r.jsx)(s.li,{children:"H need to access some resource, but the resource is currently held by L."}),"\n",(0,r.jsx)(s.li,{children:"H couldn't preempt L, because L has much lower priority than H. The reason low-priority tasks can't be preempted is due to the avoidance of starvation, if high-priority task keep preempting, lower-priority task may never get a chance to execute."}),"\n",(0,r.jsx)(s.li,{children:"Suppose that M is ready, M can preempt L because it is not the highest priority. Now, M is currently executing and holds the resource."}),"\n",(0,r.jsx)(s.li,{children:"This phenomenon causes H takes longer to complete, because of waiting for M additionally."}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["One way to mitigate is the ",(0,r.jsx)(s.strong,{children:"priority inheritance"})," technique, which temporarily raise the priority of a lower-priority task to a higher-priority task when the lower-priority task holds a resource needed by the higher-priority task. So, L priority can be changed to H, this way we don't prevent M for preempting, because essentially it has higher priority. After the resource access is complete, the priority is back to original."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.img,{alt:"Priority inversion and priority inheritance",src:t(28240).A+"",width:"1038",height:"301"}),(0,r.jsx)(s.br,{}),"\n","Source: ",(0,r.jsx)(s.a,{href:"https://www.digikey.com/en/maker/projects/introduction-to-rtos-solution-to-part-11-priority-inversion/abf4b8f7cd4a4c70bece35678d178321",children:"https://www.digikey.com/en/maker/projects/introduction-to-rtos-solution-to-part-11-priority-inversion/abf4b8f7cd4a4c70bece35678d178321"})]})]})}function d(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},19809:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/pcb-6387eea550888b25e8b17c9c7ba12f48.png"},21704:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/process-attributes-182053a48857754b97132a24afe2db78.png"},21982:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/context-switch-c16d8de80b814cd78ece0e56f4de3ac4.png"},23595:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/single-multi-thread-acb293522d6bdd326608867f35577a7e.png"},28240:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/priority-inversion-817d2a35ec8cb699b8c0a68b3dd27170.png"},28453:(e,s,t)=>{t.d(s,{R:()=>o,x:()=>a});var i=t(96540);const r={},n=i.createContext(r);function o(e){const s=i.useContext(n);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(n.Provider,{value:s},e.children)}},31956:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/process-thread-a024d9825baed8ae54993efb5b9a7839.png"},54362:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/multiprocess-189f75b68491a27c0c61d3886934f3db.png"},60037:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/process-state-576b6192a4550d73e0b402ad169471c1.png"},71349:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/round-robin-1bcbef343775b578c8b047c3a8e2a925.png"},72489:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/sjf-81733d93c87e589c822caec8bda89313.png"},72958:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/cpu-io-burst-cada9d5a6aef830de9eb81884b91898a.png"},97761:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/priority-scheduling-49f5dd7ef9402719ef2662bbe8b8ca57.png"}}]);