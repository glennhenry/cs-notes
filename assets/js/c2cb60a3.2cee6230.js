"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[3270],{35090:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var r=t(85893),a=t(11151);const s={slug:"/computer-and-programming-fundamentals/compilation",id:"compilation",title:"Compilation",description:"Compilation"},i=void 0,o={id:"computer-and-programming-fundamentals/compilation/compilation",title:"Compilation",description:"Compilation",source:"@site/docs/computer-and-programming-fundamentals/15-compilation/compilation.md",sourceDirName:"computer-and-programming-fundamentals/15-compilation",slug:"/computer-and-programming-fundamentals/compilation",permalink:"/cs-notes/computer-and-programming-fundamentals/compilation",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/computer-and-programming-fundamentals/15-compilation/compilation.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1708786431,formattedLastUpdatedAt:"Feb 24, 2024",frontMatter:{slug:"/computer-and-programming-fundamentals/compilation",id:"compilation",title:"Compilation",description:"Compilation"},sidebar:"sidebar",previous:{title:"Concurrency & Parallelism",permalink:"/cs-notes/computer-and-programming-fundamentals/concurrency-and-parallelism"},next:{title:"Interpreter",permalink:"/cs-notes/computer-and-programming-fundamentals/interpreter"}},c={},l=[{value:"Language Abstraction",id:"language-abstraction",level:3},{value:"Compilation Process",id:"compilation-process",level:3}];function d(e){const n={a:"a",admonition:"admonition",br:"br",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Main Source :"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Compiler",children:"Compiler"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"https://stackoverflow.com/questions/1782415/what-is-the-difference-between-assembly-code-and-bytecode",children:"What is the difference between assembly code and bytecode? - stackoverflow"})})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"When we write code using a particular programming language, it is still in the form of high-level source code. By high-level source code, it means the code is human-readable and involves less direct interaction with the underlying hardware. The purpose high-level programming language is to provide abstraction that make it easier for programmer to make a program."}),"\n",(0,r.jsxs)(n.p,{children:["However, computer doesn't understand high-level code. At the lowest level, computer can only understand binary instructions (1s and 0s). So, writing code in high-level language is just one way to program computer through natural language. The code written in programming language will need to be translated into binary code before they can be executed. The translation process may include more than once, it may be translated into intermediate representation before translated to final binary code. The translation process is done by ",(0,r.jsx)(n.strong,{children:"compilers"})," or ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/computer-and-programming-fundamentals/interpreter",children:"interpreters"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Compiler"})," is a program that translates code written in one language into another, typically converting high-level language code into low-level language code."]}),"\n",(0,r.jsx)(n.h3,{id:"language-abstraction",children:"Language Abstraction"}),"\n",(0,r.jsx)(n.p,{children:"Computer executes the lowest-level codes, which is binary instruction, this has gone through many abstractions up to high-level programming language source code. Here are some of different levels of language abstraction :"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"High-Level Code"})," : High-level code refers to code written in a high-level programming language, such as Python, Java, C++, etc. These languages provide a high level of abstraction and are designed to be human-readable. High-level code is typically written using some programming constructs like ",(0,r.jsx)(n.a,{href:"/computer-and-programming-fundamentals/programming-concepts#variables--data-types",children:"variables"}),", ",(0,r.jsx)(n.a,{href:"/computer-and-programming-fundamentals/programming-concepts#functions",children:"functions"}),", or even some ",(0,r.jsx)(n.a,{href:"/computer-and-programming-fundamentals/object-oriented-programming",children:"OOP concepts"})," like ",(0,r.jsx)(n.a,{href:"/computer-and-programming-fundamentals/object-oriented-programming#object",children:"object"})," and ",(0,r.jsx)(n.a,{href:"/computer-and-programming-fundamentals/object-oriented-programming#class",children:"classes"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Bytecode"})," : Bytecode is an intermediate representation of code for certain programming languages. It is a lower-level representation compared to high-level code, and is designed to be executed by a virtual machine. In the virtual machine itself, the code must undergo translation into machine code before being executed. Examples of languages that use bytecode include Java and Python."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Assembly Language"})," : Assembly language is a low-level programming language that represent machine code instructions in human-readable form. It provides a close representation to machine code and is specific to a particular hardware architecture."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Machine Language & Binary"})," : Machine language is the lowest level of abstraction in programming. It can be ",(0,r.jsx)(n.a,{href:"/computer-and-programming-fundamentals/number-system#binary",children:"binary"})," code (sequences of 0s and 1s) or ",(0,r.jsx)(n.a,{href:"/computer-and-programming-fundamentals/number-system#hexadecimal",children:"hexadecimal"})," that directly represents the instructions and data that a computer's hardware can execute. Machine language instructions are specific to the hardware architecture and are directly understood and executed by the processor."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Another term that is often encountered is ",(0,r.jsx)(n.strong,{children:"operation code (opcode)"}),". Opcode refers to the instruction of machine language that specifies the operation to be performed by the computer's processor. It represents the fundamental operations that the hardware can execute, such as arithmetic operations, memory access, and control flow instructions."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.img,{alt:"Language abstraction comparison",src:t(41307).Z+"",width:"1455",height:"423"}),(0,r.jsx)(n.br,{}),"\n","Source : ",(0,r.jsx)(n.a,{href:"https://stackify.com/python-tips-10-tricks-for-optimizing-your-code/",children:"High-level code"}),", ",(0,r.jsx)(n.a,{href:"https://www.sciencedirect.com/topics/computer-science/bytecode",children:"Bytecode"}),", ",(0,r.jsx)(n.a,{href:"https://www.nayuki.io/page/a-fundamental-introduction-to-x86-assembly-programming",children:"assembly and machine code"})]}),"\n",(0,r.jsx)(n.h3,{id:"compilation-process",children:"Compilation Process"}),"\n",(0,r.jsx)(n.p,{children:"The compilation process typically involves the following stages :"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Preprocessor"}),' : The preprocessor is a tool or component that processes the source code before it goes through compilation. It performs preprocessing directives tasks, which is special instructions in programming language like C and C++. The instruction starts with the "#" symbol, basically it provides a way to modify the source code before it is passed to the compiler.']}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Compiler"})," : The compiler takes the preprocessed source code as input and translates it into low-level code or an intermediate representation such as bytecode. The compiler checks the syntax and semantics of the code, processes the code, generates optimized code if applicable, and produces output. Compiler does the following process :"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Lexical Analysis"})," : In this stage, the source code is broken down into a sequence of ",(0,r.jsx)(n.strong,{children:"tokens"}),". Tokens are the smallest meaningful units in the programming language, such as keywords, identifiers, operators, and literals. The ",(0,r.jsx)(n.strong,{children:"lexical analyzer (lexer)"})," scans the source code character by character and groups characters into tokens based on predefined rules and patterns. The tokens are then passed to the next stage."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Syntax Analysis"})," : The syntax analysis, also known as parsing, checks whether the sequence of tokens generated by the lexical analyzer is valid according to the grammar rules of the programming language. It builds a ",(0,r.jsx)(n.strong,{children:"parse tree"})," or an ",(0,r.jsx)(n.strong,{children:"abstract syntax tree (AST)"})," that represents the structure of the code in a tree-like structure. The parser analyzes the relationships and arrangements of the tokens according to the language's grammar rules and detects syntax errors if the code violates those rules."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Semantic Analysis"})," : Once the syntax analysis is complete and the code is determined to be syntactically correct, the compiler moves on to the semantic analysis stage. Here, the compiler checks the meaning and validity of the code in terms of its semantics. It verifies things like checking if variable has been declared before it used, checking if variables types are valid, scoping rules, function calls, and other language-specific rules. The semantic analyzer ensures that the code adheres to the language's semantics and detects potential ",(0,r.jsx)(n.strong,{children:"semantic errors"})," or ",(0,r.jsx)(n.a,{href:"/computer-and-programming-fundamentals/programming-concepts#type-of-error",children:"compile-time error"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Code Generation"})," : After the semantic analysis, the compiler proceeds to generate target code based on the analyzed and validated input. The code generation stage involves transforming the high-level representation (such as the AST) into a lower-level form, which may be assembly language, machine code, bytecode, or an intermediate representation. The code generator translates the code into a format that can be executed by the target platform, while also applying optimizations to improve performance and efficiency."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.img,{alt:"Compiler operation",src:t(33544).Z+"",width:"1264",height:"654"}),(0,r.jsx)(n.br,{}),"\n","Source : ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Abstract_syntax_tree",children:"Abstract syntax tree"}),", ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Compiler#/media/File:Xxx_Scanner_and_parser_example_for_C.gif",children:"Lexer - parser"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Assembler"})," : The assembler is responsible for translating assembly language code into machine code. It takes the output of the compiler and converts it into machine code that can be directly executed by the computer's processor. The assembler replaces the instructions and symbolic representations with their corresponding binary representations (opcodes)."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Linker"})," : The linker is a separate program that combines multiple object files, libraries, and other dependencies to create a complete executable program or a shared library. It resolves external references and ensures that all the necessary components are linked together correctly. The linker also handles tasks like memory address assignment, relocation, and generating the final executable file or library."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.img,{alt:"Compilation process",src:t(42971).Z+"",width:"450",height:"400"}),(0,r.jsx)(n.br,{}),"\n","Source : ",(0,r.jsx)(n.a,{href:"https://medium.com/@3681/steps-of-compilation-5c02935a3904",children:"https://medium.com/@3681/steps-of-compilation-5c02935a3904"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["Find out more about ",(0,r.jsx)(n.a,{href:"/compilers",children:"compilers"})]})})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},42971:(e,n,t)=>{t.d(n,{Z:()=>r});const r=t.p+"assets/images/compilation-process-a70643221a88384ec06e8db9478646ba.png"},33544:(e,n,t)=>{t.d(n,{Z:()=>r});const r=t.p+"assets/images/compiler-operation-7b9123c6044c0a5cea1065bed4a0ecf3.png"},41307:(e,n,t)=>{t.d(n,{Z:()=>r});const r=t.p+"assets/images/language-abstraction-e238d1ff6ba81e79caac442daab6fb9a.png"},11151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>i});var r=t(67294);const a={},s=r.createContext(a);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);