"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[8966],{72068:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var i=n(85893),r=n(11151);const s={slug:"/computer-graphics/gpu-pipeline",id:"gpu-pipeline",title:"GPU Pipeline",description:"GPU Pipeline"},a="GPU Pipeline",o={id:"computer-graphics/gpu-pipeline/gpu-pipeline",title:"GPU Pipeline",description:"GPU Pipeline",source:"@site/docs/computer-graphics/05-gpu-pipeline/gpu-pipeline.md",sourceDirName:"computer-graphics/05-gpu-pipeline",slug:"/computer-graphics/gpu-pipeline",permalink:"/cs-notes/computer-graphics/gpu-pipeline",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/computer-graphics/05-gpu-pipeline/gpu-pipeline.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1710672481,formattedLastUpdatedAt:"Mar 17, 2024",frontMatter:{slug:"/computer-graphics/gpu-pipeline",id:"gpu-pipeline",title:"GPU Pipeline",description:"GPU Pipeline"},sidebar:"sidebar",previous:{title:"3D Transfomation",permalink:"/cs-notes/computer-graphics/3d-transformation"},next:{title:"Low Level Graphics",permalink:"/cs-notes/computer-graphics/low-level-graphics"}},c={},p=[{value:"GPU",id:"gpu",level:3},{value:"GPU Pipeline",id:"gpu-pipeline-1",level:3},{value:"Scene Data",id:"scene-data",level:3},{value:"Vertex Shader",id:"vertex-shader",level:3},{value:"Rasterizer",id:"rasterizer",level:3},{value:"Fragment Shader",id:"fragment-shader",level:3}];function l(e){const t={a:"a",br:"br",h1:"h1",h3:"h3",img:"img",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"gpu-pipeline",children:"GPU Pipeline"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.strong,{children:["Main Source : ",(0,i.jsx)(t.a,{href:"https://youtu.be/UzlnprHSbUw",children:"Intro to Graphics 07 - GPU Pipeline"})]})}),"\n",(0,i.jsx)(t.h3,{id:"gpu",children:"GPU"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"GPU (Graphics Processing Unit)"}),", is specialized cpu designed to do graphics calculation. GPU has many small core and are optimized for parallel processing or performing many calculations simultaneously. Parallel processing are used extensively in graphics where many things happen at once and all need to be updated. The use of specialized hardware components like GPU is called hardware accelaration."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"Video card and GPU",src:n(86158).Z+"",width:"347",height:"148"}),(0,i.jsx)(t.br,{}),"\n","Source : ",(0,i.jsx)(t.a,{href:"https://www.electronicshub.org/apu-vs-cpu/",children:"https://www.electronicshub.org/apu-vs-cpu/"})]}),"\n",(0,i.jsx)(t.h3,{id:"gpu-pipeline-1",children:"GPU Pipeline"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"GPU Pipeline"})," is a series of stages that a graphics processing unit (GPU) uses to render and display 3D graphics. The 3 main stages are ",(0,i.jsx)(t.strong,{children:"vertex shader"}),", ",(0,i.jsx)(t.strong,{children:"rasterization"}),", and ",(0,i.jsx)(t.strong,{children:"fragment shader"}),". In other word, they are sequence of tasks done to reproduce a virtual graphics world (in the application) into a 2D representation to the screen.\nOut of 3, vertex shader and fragment shader are programmable meaning they can be modified or customized based specific needs."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"GPU Pipeline including vertex shader, rasterizer, and fragment shader",src:n(59368).Z+"",width:"366",height:"331"}),(0,i.jsx)(t.br,{}),"\n","Source : ",(0,i.jsx)(t.a,{href:"https://youtu.be/UzlnprHSbUw?t=1704",children:"https://youtu.be/UzlnprHSbUw?t=1704"})]}),"\n",(0,i.jsx)(t.h3,{id:"scene-data",children:"Scene Data"}),"\n",(0,i.jsxs)(t.p,{children:["Graphics application interact with graphics API such as OpenGL or DirectX. Graphics API produce a 3D object by modeling the object using primitives such as point, lines, curve, and triangle. Modeling is a process of representing object such as shapes within the graphics environment. Shapes are defined by something called ",(0,i.jsx)(t.strong,{children:"vertices"}),", they are connected together forming shapes. Each vertices will contain an information about their position."]}),"\n",(0,i.jsxs)(t.p,{children:["After objects are modelled, they are put into the 3D world and this is called ",(0,i.jsx)(t.strong,{children:"scene data"})," which represent 3D environment of the world. Scene data contain anything that describe the graphics environment including geometry, color, materials, lighting, and other properties of the objects in the scene."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"A triangle modelled with 3 point",src:n(42549).Z+"",width:"255",height:"204"}),(0,i.jsx)(t.br,{}),"\n","Source : ",(0,i.jsx)(t.a,{href:"https://youtu.be/UzlnprHSbUw?t=2792",children:"https://youtu.be/UzlnprHSbUw?t=2792"})]}),"\n",(0,i.jsx)(t.h3,{id:"vertex-shader",children:"Vertex Shader"}),"\n",(0,i.jsx)(t.p,{children:"Vertex shader receives 2D / 3D scene data from graphics application. In this stage transformations such as translation, rotation, and scaling are applied to vertices. In addition to transforming vertices, the vertex shader can also perform other operations, such as normalizing vertex coordinates (scaling vertex position to ensure they are in certain range) and performing lighting calculations."}),"\n",(0,i.jsx)(t.p,{children:"After these operations, 3D objects are transformed into 2D to be displayed in computer screen"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"Vertex shader connecting line between points",src:n(20663).Z+"",width:"602",height:"166"}),(0,i.jsx)(t.br,{}),"\n","Source : ",(0,i.jsx)(t.a,{href:"https://learnopengl.com/Getting-started/Hello-Triangle",children:"https://learnopengl.com/Getting-started/Hello-Triangle"})]}),"\n",(0,i.jsx)(t.h3,{id:"rasterizer",children:"Rasterizer"}),"\n",(0,i.jsx)(t.p,{children:"This stage, GPU takes the 2D object and convert them into raster images or in other words, it \u201cpixelize\u201d the object. Rasterizer is responsible for converting primitives into something that can be displayed on screen. For example, rasterizer will draw pixel on the triangle path which is specified by 3 vertices connected together and also clips the object if it\u2019s outside of the screen (to make sure unnecesarry things being rendered)."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"A triangle modelled using line is rasterized",src:n(98753).Z+"",width:"454",height:"116"}),(0,i.jsx)(t.br,{}),"\n","Source : ",(0,i.jsx)(t.a,{href:"https://www.techspot.com/article/1888-how-to-3d-rendering-rasterization-ray-tracing/",children:"https://www.techspot.com/article/1888-how-to-3d-rendering-rasterization-ray-tracing/"}),(0,i.jsx)(t.br,{}),"\n","* The red color is not the actual color shown"]}),"\n",(0,i.jsx)(t.h3,{id:"fragment-shader",children:"Fragment Shader"}),"\n",(0,i.jsx)(t.p,{children:"Fragment shader are responsible for coloring each pixel and performs operations such as lighting\ncalculations, texture mapping, and other effects. In simple term, they decide what is the final color of each pixel after taking account all important effect."}),"\n",(0,i.jsx)(t.p,{children:"For example in the image below, there is a triangle that is formed by 3 vertices. These vertices all have different color, color interpolation are done to determine the color for any pixel inside the triangle."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"A triangle is interpolated between three colors",src:n(79453).Z+"",width:"203",height:"215"}),(0,i.jsx)(t.br,{}),"\n","Source : ",(0,i.jsx)(t.a,{href:"https://unsoundscapes.com/slides/2017-06-08-bringing-the-fun-to-graphics-programming/",children:"https://unsoundscapes.com/slides/2017-06-08-bringing-the-fun-to-graphics-programming/"})]})]})}function h(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},79453:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/fragment-shader-f6a949830132bd14dd682cf8151165b1.png"},59368:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/gpu-pipeline-95dd87c3782a1e99360bc62017bd5325.png"},98753:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/rasterization-9bf7420800c84e2e3debf9bda0321869.png"},42549:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/scene-data-413eddf1b7b12842400505b28aae40f4.png"},20663:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/vertex-shader-6bfe4af67106a4534e2a7ff3eee9bf84.png"},86158:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/videocard-gpu-32af3ada3a7fddb6486f9921e269f0ba.png"},11151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>a});var i=n(67294);const r={},s=i.createContext(r);function a(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);