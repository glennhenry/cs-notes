"use strict";(self.webpackChunkcs_notes=self.webpackChunkcs_notes||[]).push([[9508],{93682:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>n,metadata:()=>r,toc:()=>c});var s=i(85893),a=i(11151);const n={slug:"/cloud-computing-and-distributed-systems/distributed-database",id:"distributed-database",title:"Distributed Database",description:"Distributed Database"},o=void 0,r={id:"cloud-computing-and-distributed-systems/distributed-database/distributed-database",title:"Distributed Database",description:"Distributed Database",source:"@site/docs/cloud-computing-and-distributed-systems/05-distributed-database/distributed-database.md",sourceDirName:"cloud-computing-and-distributed-systems/05-distributed-database",slug:"/cloud-computing-and-distributed-systems/distributed-database",permalink:"/cs-notes/cloud-computing-and-distributed-systems/distributed-database",draft:!1,unlisted:!1,editUrl:"https://github.com/glennhenry/cs-notes/tree/main/docs/cloud-computing-and-distributed-systems/05-distributed-database/distributed-database.md",tags:[],version:"current",lastUpdatedBy:"glennhenry",lastUpdatedAt:1709795968,formattedLastUpdatedAt:"Mar 7, 2024",frontMatter:{slug:"/cloud-computing-and-distributed-systems/distributed-database",id:"distributed-database",title:"Distributed Database",description:"Distributed Database"},sidebar:"sidebar",previous:{title:"Distributed File System",permalink:"/cs-notes/cloud-computing-and-distributed-systems/distributed-file-system"},next:{title:"Client-Server",permalink:"/cs-notes/cloud-computing-and-distributed-systems/client-server"}},d={},c=[{value:"Concurrency Mechanism",id:"concurrency-mechanism",level:3},{value:"Locking",id:"locking",level:4},{value:"Atomic Commit",id:"atomic-commit",level:4}];function l(e){const t={a:"a",admonition:"admonition",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Main Source :"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"[]"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Distributed Database page"}),"\n",(0,s.jsx)(t.h3,{id:"concurrency-mechanism",children:"Concurrency Mechanism"}),"\n",(0,s.jsx)(t.p,{children:"With a bunch of nodes communicating and potentially sharing data, concurrency will always be a concern. Mechanism to used to manage and coordinate concurrent access to shared resources in a distributed system are required."}),"\n",(0,s.jsxs)(t.p,{children:["A data operation can be classified as ",(0,s.jsx)(t.strong,{children:"read"})," or ",(0,s.jsx)(t.strong,{children:"write"}),". A read retrieves the value of a data item from a storage location or a shared resource, without modifying. A write operation modifies the value of a data item, updating or overwriting the existing value. A concurrency problem typically occurs when there are two nodes accessing the same resource, and one of them are writing operation."]}),"\n",(0,s.jsxs)(t.p,{children:["Consider a scenario of node A and node B, where node A writes and node B reads, both accessing the resource C. Assume that node A and B execute their operation at the same time. Even if their operation is started at the same time, the end result depend on the actual execution. If the initial value of C is 100, B is supposed to read 100, but if node A executed first, then it will read whatever node A was writing. This scenario is often called ",(0,s.jsx)(t.a,{href:"/operating-system/multithreading#multithreading-problems",children:"race condition"}),"."]}),"\n",(0,s.jsx)(t.h4,{id:"locking",children:"Locking"}),"\n",(0,s.jsx)(t.p,{children:"Access of resource by nodes are exclusive, meaning a resource can only be accessed by a single node. A lock can be acquired by a node, meaning that particular node gain exclusive access to the resource, or released, the node makes it available for other node to acquire."}),"\n",(0,s.jsx)(t.p,{children:"The component that holds the resource should implement the locking mechanism, keeping track of which node is currently acquiring the lock. When a node wants to access a resource, it will need to request the lock to the lock tracker. If there's another node acquiring the lock, then the access request will simply be delayed. Otherwise, that particular node will now acquire the lock and gain access to the resource."}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsxs)(t.p,{children:["See also ",(0,s.jsx)(t.a,{href:"/operating-system/multithreading#locks--mutex",children:"mutual exclusion"}),"."]})}),"\n",(0,s.jsx)(t.h4,{id:"atomic-commit",children:"Atomic Commit"}),"\n",(0,s.jsxs)(t.p,{children:["Atomic commit is a protocol or mechanism that ensures a set of operations or ",(0,s.jsx)(t.a,{href:"/database-system/transactions",children:"transactions"})," are either all committed or all aborted, maintaining consistency across multiple nodes or databases."]}),"\n",(0,s.jsx)(t.p,{children:"A transaction is a logical unit of work that consists of multiple operations that need to be executed as an indivisible unit. If any part of the transaction fails, all changes made by the transaction are rolled back, leaving the system in its original state. On the other hand, if all parts of the transaction succeed, all changes are committed, and the system reflects the updated state."}),"\n",(0,s.jsxs)(t.p,{children:["One implementation of atomic commit is the ",(0,s.jsx)(t.strong,{children:"two-phase commit (2PC)"})," protocol. This protocol consist of two phases, prepare and commit phase. A coordinator node responsible for managing the transaction communicates with all participating nodes and asks them to prepare for the commit. Each participating node performs its portion of the transaction and prepares to commit. If any node encounters an issue during this phase or cannot prepare for the commit, it indicates a failure. Based on the responses received during the prepare phase, the coordinator makes a final decision about whether to commit or abort the transaction. If all nodes are prepared to commit, the coordinator sends a commit message to all participating nodes, instructing them to permanently apply the changes. If any node is unable to commit or if there is a failure detected, the coordinator sends an abort message, instructing all nodes to roll back the changes."]}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsxs)(t.p,{children:["See also similar topic about ",(0,s.jsx)(t.a,{href:"/database-system/concurrency-control",children:"concurrency control in database system"}),"."]})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"distributed database, data store"}),"\n",(0,s.jsx)(t.li,{children:"distriubted query processing"}),"\n",(0,s.jsx)(t.li,{children:"distributed transaction"}),"\n",(0,s.jsx)(t.li,{children:"sharding"}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},11151:(e,t,i)=>{i.d(t,{Z:()=>r,a:()=>o});var s=i(67294);const a={},n=s.createContext(a);function o(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);